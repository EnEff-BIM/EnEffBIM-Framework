// Copyright (C) 2012-2015 Institute of Energy Efficient Building E3D,
// RWTH Aachen University, Germany.
//
// This program was developed for the EnEff-BIM project. In EnEff-BIM, 
// a project participating in IEA Annex 60, translators between Building 
// Information Models (BIM) and Modelica are developed to support building
// and community energy performance simulation. This is accomplished through 
// extending existing standards for exchanging energy calculation data, and 
// through data representation formats such as the Industry Foundation Classes (IFC).
//
// This program is free software; you can redistribute it and/or modify it 
// under the terms of the GNU General Public License version 2 as published 
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, simmodel2c++ gives permission to 
// link this program with the XML data binding framework generated by the 
// Code Synthesis Tools CC, and distribute linked combinations including 
// the two. You must obey the GNU General Public License version 2 in all 
// respects for all of the code used. If you modify this copy of the program, 
// you may extend this exception to your version of the program, but you are 
// not obligated to do so. If you do not wish to do so, delete this exception 
// statement from your version.
//

// include the head files
#include <QtCore/QtGlobal>
#include "include_files.h"

#if defined TEST
#define TEST_COMMON_DLLSPEC  Q_DECL_EXPORT
#else
#define TEST_COMMON_DLLSPEC Q_DECL_IMPORT
#endif

#ifndef SIMMODELAPI_H
#define SIMMODELAPI_H


// the SimModel data filtered by mapping rule
// used to initilize the Modelica code template
// for the generation of .mo file

// save property data
// filttered by mapping rules
class property_data
{
public:
    property_data() { is_single=true; single_property_name=""; property_value=""; property_value_group=""; target_location=""; record_instance=""; record_location=""; record_instance_location="";}
	~property_data() {}

	// retrieve
	string get_property_name() { return single_property_name; }
	string get_property_value() { return property_value; }
	//string get_target_location() { return target_location; }
	//string get_record_instance() { return record_instance; }
	//string get_record_location() { return record_location; }
	string get_property_value_group() { return property_value_group; }
	bool get_flag() { return is_single; }

	// set value
	void set_property_name(string _t) { single_property_name = _t; }
	void set_property_value(string _t) { property_value = _t; }
	void set_target_location(string _t) { target_location = _t; }
	void set_record_instance(string _t) { record_instance = _t; }
	void set_record_location(string _t) { record_location = _t; }
	void set_property_value_group(string _t) { property_value_group = _t; is_single=false; }

    // property for ctypes
    const char* get_name() { return single_property_name.c_str(); }
    const char* get_value() { return property_value.c_str(); }
    const char* get_target_location() { return target_location.c_str(); }
    const char* get_record_instance() { return record_instance.c_str(); }
    const char* get_record_location() { return record_location.c_str(); }
    const char* get_value_group() { return property_value_group.c_str(); }

private:
	string single_property_name;
	// string, int, double, or array (matrix)
	string property_value; 
	// a group of properties and their values
	string property_value_group;
	// the flag, true: is a single property
	// false: is a group of property and value pairs
	bool is_single;
	// additional paramter
	string target_location;
	string record_instance;
	string record_location;
	string record_instance_location;
};

// save component data
// filttered by mapping rules
class component_data
{
public:
    component_data() { target_component_name=""; target_location=""; }
	~component_data() {}

	// retrieve
	string get_target_component_name() { return target_component_name; }
	//string get_target_location() { return target_location; }
	vector<property_data>& get_proptery_list() { return proptery_list; }


	// set value
	void set_target_component_name(string _t) { target_component_name = _t; }
	void set_target_location(string _t) { target_location = _t; }
	void save_target_property(property_data& _p) { proptery_list.push_back(_p); }

    // component for ctypes
    const char* get_target_name() { return target_component_name.c_str(); }
    const char* get_target_location() { return target_location.c_str(); }
    property_data* get_property(int id) { return &proptery_list.at(id); }
    int get_property_total_number() { return proptery_list.size(); }

private:
	string target_component_name;
	string target_location;
	// a list of internal properties
	vector<property_data> proptery_list;
};

#endif
