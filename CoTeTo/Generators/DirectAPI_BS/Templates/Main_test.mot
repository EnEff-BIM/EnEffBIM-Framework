<%
##
## Set surface temperatures as an output of the building model: surTemOut = True
surTemOut = True
#surTemOut = False
import numpy as np
import math

## Classes for storing the information of the building model instances
class Construction:
  def __init__(self, name = "", nLayers = 1, thickness = [], material = []):
    self.name = name
    self.nLayers = nLayers
    self.thickness = thickness
    self.material = material

class Zone:
  def __init__(self, name, nElements, volume, height, TSetHeating, TSetCooling, airchange, heatsource):
    self.name = name
    self.nElements = nElements
    self.volume = volume
    self.height = height
    self.TSetHeating = TSetHeating
    self.TSetCooling = TSetCooling
    self.airchange = airchange
    self.heatsource = heatsource

class Element:
  def __init__(self, name, angleDegAzi, angleDegTil, height, width):
    self.name = name
    self.angleDegAzi = angleDegAzi
    self.angleDegTil = angleDegTil
    self.height = height
    self.width = width

class ElementOpaque(Element):
  def __init__(self, name, angleDegAzi, angleDegTil, height, width, constructionData, nInnSur = 0, innerSurfaces = []):
    Element.__init__(self, name, angleDegAzi, angleDegTil, height, width)
    self.constructionData = constructionData
    self.nInnSur = nInnSur
    self.innerSurfaces = innerSurfaces

class ElementTransparent(Element):
  def __init__(self, name, angleDegAzi, angleDegTil, height, width):
    Element.__init__(self, name, angleDegAzi, angleDegTil, height, width)

class ConnectionElementZone:
  def __init__(self, element, elementPort, zone, zonePort):
    self.element = element
    self.elementPort = elementPort
    self.zone = zone
    self.zonePort = zonePort

class ConnectionElementAmbient:
  def __init__(self, element, elementPort, ambientPort):
    self.element = element
    self.elementPort = elementPort
    self.ambientPort = ambientPort

class ConnectionElementSolid:
  def __init__(self, element, elementPort, solidPort):
    self.element = element
    self.elementPort = elementPort
    self.solidPort = solidPort

class BuildingSystem:
  def __init__(self, name = "BuildingSystem", location = ""):
    self.name = name
    self.location = location

## Definition of the multi-zone building
##for filename in json_files:
##  jdata = json_files[filename]
## Zugriff auf SimModel-API (Low-Level)

import os,sys

def importSwigApis():
    """The SimModel classes are loaded.It gives access to the properties
    defined within the classes. Otherwise one will have SwigPyObjects!.
    help: use dir /b /a-d > filenames.txt"""		
    import base
    import SimModel_Hierachy
    import SimModel_Mapping
    import SimAddress_Postal_Default
    import SimAppLibraryDefault_AppLibraryDefault_GlobalLibrary
    import SimAppObjNameDefaultDistributionSystemHvacChilledWaterLoop
    import SimAppObjNameDefault_BldgComponentGroup_HvacComponent
    import SimAppObjNameDefault_BldgComponentGroup_HvacComponentGroup
    import SimAppObjNameDefault_DistributionSystemSitePowerGeneration
    import SimAppObjNameDefault_DistributionSystem_HvacAirLoop
    import SimAppObjNameDefault_DistributionSystem_HvacCondenserLoop
    import SimAppObjNameDefault_DistributionSystem_HvacHotWaterLoop
    import SimAppObjNameDefault_DistributionSystem_HvacSteamLoop
    import SimAppObjNameDefault_DistributionSystem_MixedWaterLoop
    import SimAppObjNameDefault_DistributionSystem_RefrigerationLoop
    import SimAppObjNameDefault_DistributionSystem_SitePowerDemand
    import SimAppObjNameDefault_DistributionSystem_VarRefrigerantFlow
    import SimAppObjNameDefault_SiteContext_AdjacentSite
    import SimAppObjNameDefault_SiteContext_SolarObstruction
    import SimAppObjNameDefault_Space_Space
    import SimAppObjNameDefault_SpatialContainer_Building
    import SimAppObjNameDefault_SpatialContainer_BuildingStory
    import SimAppObjNameDefault_SpatialContainer_Project
    import SimAppObjNameDefault_SpatialContainer_Site
    import SimAppObjNameDefault_SpatialZone_CeilingPlenumZone
    import SimAppObjNameDefault_SpatialZone_FloorPlenumZone
    import SimAppObjNameDefault_SpatialZone_ThermalZone
    import SimAppObjNameDefault_ZoneGroup_CeilingPlenumZoneGroup
    import SimAppObjNameDefault_ZoneGroup_DaylightingZoneGroup
    import SimAppObjNameDefault_ZoneGroup_FloorPlenumZoneGroup
    import SimAppObjNameDefault_ZoneGroup_HvacEquipmentGroup
    import SimAppObjNameDefault_ZoneGroup_NatVentZoneGroup
    import SimAppObjNameDefault_ZoneGroup_ThermalZoneGroup
    import SimAppPreferences_AppPreferences_AutoSave
    import SimAppPreferences_AppPreferences_AutoSaveInterval
    import SimAppPreferences_AppPreferences_MinMonthlyChargeType
    import SimAppUnitDefault_AppUnitDefault_DatabaseDefault
    import SimArbitraryProfileDef_ArbitraryProfile_Closed
    import SimBldgSiteParams_BuildingSite_Default
    import SimBldgStoryParams_BuildingStory_Default
    import SimBuildingStory_BuildingStory_Default
    import SimBuilding_Building_Default
    import SimCartesianTransformOperator_3D_Uniform
    import SimClassificationClassificationReferenceSpaceCategoryOwner
    import SimClassification_ClassificationReferenceSpaceCategoryBoma
    import SimClassification_ClassificationReference_SpaceTypeOwner
    import SimClassification_ClassificationSystem_Default
    import SimClassification_ClassificationSystem_OmniClass
    import SimConnectedFaceSet_ConnectedFaceSet_ClosedShell
    import SimConnectedFaceSet_ConnectedFaceSet_Default
    import SimConnection_HotWaterFlow_Default
    import SimConnection_ZoneAirFlow_Default
    import SimController_SupplyWater_Temperature
    import SimController_ZoneControlTemperature_Thermostat
    import SimControlScheme_AvailabilityManagerScheme_Scheduled
    import SimControlScheme_ControlAndSequencingScheme_HeatingLoad
    import SimControlScheme_SetpointManagerScheme_ScheduledSetpoint
    import SimControlScheme_SetpointScheme_SingleHeating
    import SimDerivedUnitType_DerivedUnit_Default
    import SimDistributionPort_AirFlowPort_Air_In
    import SimDistributionPort_AirFlowPort_Air_Out
    import SimDistributionPort_HotWaterFlowPort_Water_In
    import SimDistributionPort_HotWaterFlowPort_Water_InOrOut
    import SimDistributionPort_HotWaterFlowPort_Water_Out
    import SimFaceBound_FaceBound_Default
    import SimFaceBound_FaceBound_FaceOuterBound
    import SimFace_Face_Default
    import SimFeatureElementSubtraction_Void_Opening
    import SimFlowController_Valve_Default
    import SimFlowController_Valve_TemperingValve
    import SimFlowEnergyTransferStorage_HotWaterTank_Expansion
    import SimFlowEnergyTransferStorage_HotWaterTank_Mixed
    import SimFlowEnergyTransfer_ConvectiveHeater_Radiant_Water
    import SimFlowEnergyTransfer_ConvectiveHeater_Water
    import SimFlowFitting_Default_Default
    #no module named: import SimFlowFitting_FlowElementProxy_DemandProxy_WaterLoop
    #no module named: import SimFlowFitting_FlowElementProxy_SupplyProxy_AirLoop
    import SimFlowFitting_Mixer_DemandProxyMixerWater
    import SimFlowFitting_Splitter_DemandProxySplitterWater
    import SimFlowMover_Pump_VariableSpeedReturn
    import SimFlowPlant_Boiler_BoilerHotWater
    import SimFlowSegment_Pipe_Indoor
    import SimGeomBooleanResult_BooleanClippingResult_Default
    import SimGeomCurve_Polyline_Default
    import SimGeomHalfSpaceSolid_HalfSpaceSolid_PolygonalBoundedHalfSpace
    import SimGeomPoint_Point_CartesianPoint
    import SimGeomSolidModel_FacetedBrep_Default
    import SimGeomSolidModel_SweptAreaSolid_ExtrudedAreaSolid
    import SimGeomSurfaceModel_FaceBasedSurfaceModel_Default
    import SimGeomSurface_BoundedSurface_CurveBoundedPlane
    import SimGeomSurface_ElementarySurface_Plane
    import SimGeomVector_Vector_Default
    import SimGeomVector_Vector_Direction
    import SimGroup_BldgCompGroup_ZoneEquipment
    import SimGroup_HvacDemandGroup_WaterSystem
    import SimGroup_SpatialZoneGroup_ZoneGroup
    import SimGroup_SpatialZoneGroup_ZoneHvacGroup
    import SimInternalLoad_Equipment_Electric
    import SimInternalLoad_Lights_Default
    import SimInternalLoad_People_Default
    import SimList_ConnectorList_SimConnections
    import SimList_EquipmentList_ZoneHvac
    import SimList_MaterialList_Default
    import SimList_SchemeList_AirLoopAvailabilityMgrScheme
    import SimList_SchemeList_DemandManagerScheme
    import SimList_SchemeList_PlantOperatingScheme
    import SimList_SchemeList_WaterTempControlScheme
    import SimLocalPlacement_LocalPlacement_AbsolutePlacement
    import SimLocalPlacement_LocalPlacement_RelativePlacement
    import SimLocationAndWeather_DesignDay_Default
    import SimLocationAndWeather_Location_Default
    import SimLoop_Loop_PolyLoop
    import SimMappedRepresentationItem_Default_Default
    import SimMaterialLayerSet_Default_Default
    import SimMaterialLayerSet_GlazingLayerSet_Window
    import SimMaterialLayerSet_OpaqueLayerSet_Ceiling
    import SimMaterialLayerSet_OpaqueLayerSet_Door
    import SimMaterialLayerSet_OpaqueLayerSet_Floor
    import SimMaterialLayerSet_OpaqueLayerSet_InternalSource
    import SimMaterialLayerSet_OpaqueLayerSet_Roof
    import SimMaterialLayerSet_OpaqueLayerSet_Wall
    import SimMaterialLayer_GlazingMaterialLayer_Default
    import SimMaterialLayer_OpaqueMaterialLayer_Default
    import SimMaterial_Default_Default
    import SimMaterial_GlazingMaterial_Gas
    import SimMaterial_GlazingMaterial_Glazing
    import SimMaterial_GlazingMaterial_SimpleGlazingSystem
    import SimMaterial_OpaqueMaterial_AirGap
    import SimMaterial_OpaqueMaterial_Default
    import SimModel
    # No module named ... RepresentationContex import SimModelRepresentationContextGeometricRepresentationSubCon
    import SimModelRepresentationContext_GeometricRepresentationContext_Default
    import SimModel_Hierachy
    import SimModel_Mapping
    import SimModel_PyCallBack
    import SimNode_AirFlowPort_Air_In
    import SimNode_AirFlowPort_Air_Out
    import SimNode_DigitalControl_AirLoop_DigitalSignal_In
    import SimNode_DigitalControl_HWLoop_DigitalSignal_In
    import SimNode_Docking_Default
    import SimNode_HotWaterFlowPort_Water_In
    import SimNode_HotWaterFlowPort_Water_Out
    import SimOrganization_Organization_Default
    import SimOwnerHistory_Default_Default
    import SimParameterizedProfileDef_ParameterizedProfile_Rectangle
    import SimPerformanceCurve_Mathematical_Cubic
    #Dll load failed import SimPersonAndOrganization_PersonAndOrganization_Default
    import SimPerson_Person_Default
    import SimPlacement_Axis2Placement2D_Default
    import SimPlacement_Axis2Placement3D_Default
    import SimPresentationLayerAssignment_Default_Default
    import SimProject_Project_DesignAlternative
    import SimRepresentationMap_RepresentationMap_Default
    import SimSensor_TemperatureSensor_DryBulb
    import SimShapeRepresentation_ShapeRepresentation_Default
    import SimSimulationConfiguration_SimulationConfiguration_Default
    import SimSimulationParameters_HvacDesign_WaterLoopSizing
    import SimSite_BuildingSite_Default
    import SimSIUnitType_SiUnit_Default
    import SimSlabParams_Slab_Floor
    import SimSlab_Default_Default
    import SimSlab_Floor_FloorOverEarth
    import SimSlab_Floor_InterzoneFloor
    import SimSlab_RoofSlab_RoofUnderAir
    import SimSoftwareApplication_Default_Default
    import SimSolarShade_Fin_Default
    import SimSolarShade_Overhang_Default
    import SimSpaceBoundary_SecondLevel_SubTypeA
    import SimSpaceParams_Space_Default
    import SimSpace_Occupied_Default
    import SimSpatialZone_ThermalZone_Default
    import SimSpatialZone_ThermalZone_TemplateForZoneGroup
    import SimSystem_HvacHotWater_Control
    import SimSystem_HvacHotWater_Demand
    import SimSystem_HvacHotWater_FullSystem
    import SimSystem_HvacHotWater_Supply
    import SimSystem_ZoneHvacGroup_Control
    import SimSystem_ZoneHvacGroup_Demand
    import SimSystem_ZoneHvacGroup_FullSystem
    import SimSystem_ZoneHvacGroup_Supply
    import SimTemplateConstructions_Constructions_Default
    import SimTemplateLocation_Location_Default
    import SimTemplateZoneConditions_ZoneConditions_Default
    import SimTemplateZoneLoads_ZoneLoads_Default
    import SimTimeSeriesSchedule_Calendar_Configuration
    import SimTimeSeriesSchedule_Day_Interval
    import SimTimeSeriesSchedule_Limits_Default
    import SimTimeSeriesSchedule_Week_Daily
    import SimTimeSeriesSchedule_Year_Default
    import SimWallParams_Wall_Default
    import SimWallType_Wall_Default
    import SimWall_Wall_Default
    import SimWall_Wall_ExteriorAboveGrade
    import SimWall_Wall_Interior
    import SimWindowArrayParams_WindowArray_Default
    import SimWindowLiningProps_WindowLiningProps_Default
    import SimWindowParams_Window_Default
    import SimWindowType_Window_Default
    import SimWindow_Window_Default
    import SimWindow_Window_Exterior
print("module path: ", modulePath)
print("sys.path ", sys.path)
sys.path.insert(0, modulePath)
importSwigApis()
from SimModel_Translator import SimTranslator	
translator = SimTranslator()
simxml_data = translator.loadSimModel(pathList[0], pathList[1])
sim_hierarchy = translator.getSimHierarchy()
nodeList = sim_hierarchy.getHierarchyNodeList()	

## Construction types
constructions = []
##for con in jdata['constructions']:
##  constructions.append(Construction(con['name'],con['nLay'],con['thi'],con['mat']))
for i in range(1):
  constructions.append(Construction("ConstructionStandard",3,[0.015,0.2,0.02],["BuildingSystems.HAM.Data.MaterialProperties.Thermal.Masea.HighGradePlaster","BuildingSystems.HAM.Data.MaterialProperties.Thermal.Masea.Concrete","BuildingSystems.HAM.Data.MaterialProperties.Thermal.Masea.ExpandedPolystyrene"]))
 
  
###
# BEGIN CREATE CONSTRUCTIONS:
# SimMatLayer_LayerThickness is used instead of LayerThickness (more common)
# SimMaterialLayerSet_GlazingLayerSet_Window are ignored so far.
constructions_new = []
for id in range(0, nodeList.size()):
    hierarchy_node = nodeList[id]
    if hierarchy_node.isClassType("SimMaterialLayerSet_OpaqueLayerSet_Wall") or hierarchy_node.isClassType("SimMaterialLayerSet_OpaqueLayerSet_Floor"):
        child_node_list = hierarchy_node.getChildList()
        thickness=[]
        MatName=[]
        for node in child_node_list:
            class_name = getattr(node.getSimModelObject(),"SimMatLayer_LayerThickness")
            thickness.append(class_name().getValue()/1000)
            class_name = getattr(node.getSimModelObject(),"SimModelName")
            #MatName.append(class_name().getValue().replace("_","").replace(",","_").replace(" ","").replace(")","").replace("(",""))
            MatName.append("BuildingSystems.HAM.Data.MaterialProperties.Thermal.Masea.Concrete")
        #print("id: ", id, " --> construction with ID: ", hierarchy_node.getSimModelObject().RefId())
        #print("thicknes: ", thickness, " Material: ", MatName)
        constructions_new.append(Construction(hierarchy_node.getSimModelObject().RefId(),len(child_node_list),thickness,MatName))
# END CREATE CONSTRUCTIONS
###  

###
# BEGIN CREATE DICTIONARY WITH KEYS = ZONE AND VALUES = WINDOWS AND DOORS:
DoorsInZone   = {}  # key = Zone's Id, value = list of door's Id
WindowsInZone = {}  # key = Zone's Id, value = list of window's Id
WindowsToVoid = {}  # key = Window's Id, value = void's Id 
DoorsToVoid   = {}  # key = Door's Id, value = void's Id
 
# FIRST PART: SimWindow_Window_Exterior are supported and can be identified:
for id in range(0, nodeList.size()):
    hierarchy_node = nodeList[id]
    if hierarchy_node.isClassType("SimSpace_Occupied_Default"):
        child_node_list = hierarchy_node.getChildList()
        zoneName = hierarchy_node.getSimModelObject().RefId()
        ListOfWindows=[] 		
        for node in child_node_list:
            chil2lvl_node_list=node.getChildList()
            for node2lvl in chil2lvl_node_list:
                if node2lvl.isClassType("SimWindow_Window_Exterior"):		
                    ListOfWindows.append(node2lvl.getSimModelObject().RefId())
                    class_name = getattr(node2lvl.getSimModelObject(),"OpeningFilledByWindow")								
                    WindowsToVoid[node2lvl.getSimModelObject().RefId()] = class_name().getValue()                    
		WindowsInZone[zoneName]=ListOfWindows
        DoorsInZone[zoneName] = [] # We initialize this dictionary.		

# SECOND PART: Because not all window and door classes are supported, it is necessary to look inside the file.
# updating/completing the dictionary. Once the Classes are supported the above code can be updated and the following deleted.
 
with open(pathList[0]) as inF:
    Id = ""
    for line in inF:	
        if "<SimWindow_Window_Interior" in line: # We have a window							
            Id = line.split("RefId=\"")[1].split("\"")[0]		
        elif "<simbldg:OpeningFilledByWindow>" in line and Id != "":
            value = line.split(">")[1].split("<")[0]			
            WindowsToVoid[Id] = value
            Id=""			
        elif "<SimDoor_GlazedDoor_Interior" in line: # We have a door
            Id = line.split("RefId=\"")[1].split("\"")[0]
        elif "<simbldg:OpeningFilledByDoor>" in line and Id != "":				
            value = line.split(">")[1].split("<")[0]			
            DoorsToVoid[Id] = value
            Id=""				

# THIRD PART: We need to add the information from WindowsToVoid and DoorsToVoid into the Dictionary using the 
# name of the zones: DoorsInZone and WindowsInZone.
# The SimSpaceBoundary_SecondLevel_SubTypeA that contain one only child and are PHYSICAL are the corresponding boundary 
# of the unsupported classes. The boundaries of each zone (SimSpace_Occupied_Default) are inspected, looking for
# for such PHYSICAL and not completely/well defined boundaries. 
for id in range(0, nodeList.size()):
    hierarchy_node = nodeList[id]
    if hierarchy_node.isClassType("SimSpace_Occupied_Default"):
        child_node_list = hierarchy_node.getChildList()
        zoneName = hierarchy_node.getSimModelObject().RefId()
        RelatedElement=[] 		
        for node in child_node_list:
            chil2lvl_node_list=node.getChildList()
            class_name = getattr(node.getSimModelObject(),"PhysicalOrVirtualBoundary")
            PhysicalOrVirtual = class_name().getValue()			
            if len(chil2lvl_node_list) <= 1 and PhysicalOrVirtual == "PHYSICAL":
                class_name = getattr(node.getSimModelObject(),"RelatedBuildingElement")			
                RelatedElement.append(class_name().getValue())
        #Update Dict:	
        for ele in RelatedElement:
            if ele in DoorsToVoid.keys():		
                DoorsInZone[zoneName].append(ele)				
            elif ele in WindowsToVoid.keys():		
                WindowsInZone[zoneName].append(ele)		 
# END CREATE DICTIONARY OF WINDOWS AND DOORS
###  
print("WindowsInZone: ", WindowsInZone)
print("DoorsInZone: ", DoorsInZone)
print("WindowsToVoid: ", WindowsToVoid)
print("DoorsToVoid: ", DoorsToVoid)

# A new Dictionary relating zone with void elements is created.
# It will be later easier to work with.
WindowVoidInZone = {}
DoorVoidInZone = {}
print(type(WindowsInZone), " ---> ", WindowsInZone.keys())
for ele in WindowsInZone.keys():
    print("Zone: ", ele)
    AuxList = []	
    for Window in WindowsInZone[ele]: 
        print("Window: ",Window)
        AuxList.append(WindowsToVoid[Window])
    WindowVoidInZone[ele]=AuxList
    AuxList = []	
    for Door in DoorsInZone[ele]:
        AuxList.append(DoorsToVoid[Door])		
    DoorVoidInZone[ele]=AuxList	
#
#
print("WindowVoidInZone: ", WindowVoidInZone)
print("DoorVoidInZone: ", DoorVoidInZone)



elementsOpaque_new = []
elementsTransparent_new = []
conEleZon_new = []
conEleAmb_new = []
conEleSol_new = []

nVIRTUAL = 0
contoground = 0
contoambient = 0
connectionsZoneDict = {}
for id in range(0, nodeList.size()):
    hierarchy_node = nodeList[id]
    if hierarchy_node.isClassType("SimSpace_Occupied_Default"):	
        connectionsZoneDict[hierarchy_node.getSimModelObject().RefId()]=0
#
# Regarding the name Id. Each boundary have a different even when the same element is defined with it:
# If we have an inner window or door we can use Window or Door Id. 
# If we have a wall we cannot do it. walls might be shared for many zones and will be accordingly splitted. 
# A more general approach is to create a nameId for INTERNAL boundaries based on the two attached boundaries
# Like we do for the interior wall.
for id in range(0, nodeList.size()):
    hierarchy_node = nodeList[id]
    if hierarchy_node.isClassType("SimSpaceBoundary_SecondLevel_SubTypeA"):	
        hierarchy_obj = hierarchy_node.getSimModelObject()
        class_name = getattr(hierarchy_obj,"PhysicalOrVirtualBoundary")		
        PhysicalOrVirtual = class_name().getValue()	
        if PhysicalOrVirtual == "PHYSICAL":
            nameId = hierarchy_obj.RefId()
            #print("Dealing with: ", nameId)			
            class_name = getattr(hierarchy_obj,"RelatingSpace")		
            RelatingSpace = class_name().getValue()
            class_name = getattr(hierarchy_obj,"InternalOrExternalBoundary")
            InternalOrExternal = class_name().getValue()			
            child_node_list = hierarchy_node.getChildList()
            if len(child_node_list)<=1:
                print("The SimSpaceBoundary ", nameId ," corresponds to an unsupported boundary class. ")
                class_name = getattr(hierarchy_obj,"RelatedBuildingElement")		
                nameId = class_name().getValue()
                angTil = 90
                angAzi = 0
                height = 1
                width  = 1				
                if nameId in WindowsInZone[RelatingSpace]:
                    print("We add a dummy-window")				
                    opaque = False					
                else:
                    print("We add a dummy-door")					
                    opaque = True
                    conDat = constructions_new[0].name
                    nInnSur=0
                    innSur=[]					
            else:			
                for node in child_node_list:
                    child_obj = node.getSimModelObject()
                    #print("Dealing with child: ", child_obj.RefId(), " boundary element of zone ", RelatingSpace)					
                    if node.isClassType("SimWall_Wall_Interior"):				
                        opaque = True				
                        class_name = getattr(child_obj,"WallHeight")
                        height = class_name().getValue()/1000
                        class_name = getattr(hierarchy_obj,"GrossSurfaceArea")
                        GrossSurfaceArea = class_name().getValue()/(1000*1000)	
                        width = GrossSurfaceArea/height					
                        class_name = getattr(hierarchy_obj,"OthersideSpaceBoundary")
                        OthersideSpaceBoundary = class_name().getValue()						
                        BoundariesNames = [OthersideSpaceBoundary,nameId]					
                        child2lvl_node_list = node.getChildList()					
                        nInnSur= 0
                        innSur = []
                        #Need to obtain Id of other Zone.						
                        OtherSpaceBoundary_node = sim_hierarchy.getHierarchyNode(OthersideSpaceBoundary)
                        OtherSpaceBoundary_obj  = OtherSpaceBoundary_node.getSimModelObject()
                        class_name = getattr(OtherSpaceBoundary_obj,"RelatingSpace")
                        OtherZone_id = class_name().getValue()						
						#
                        for node2lvl in child2lvl_node_list:						
                            if node2lvl.isClassType("SimFeatureElementSubtraction_Void_Opening"):
                                node2lvlobj=node2lvl.getSimModelObject()							
                                #Check if this Void_Opening is actually attached to the zone:						
                            	if 	(node2lvlobj.RefId() in DoorVoidInZone[RelatingSpace] and node2lvlobj.RefId() in DoorVoidInZone[OtherZone_id]) or (node2lvlobj.RefId() in WindowVoidInZone[RelatingSpace] and node2lvlobj.RefId() in WindowVoidInZone[OtherZone_id]):
                                    class_name1 = getattr(node2lvlobj,"OpeningWidth")
                                    class_name2 = getattr(node2lvlobj,"OpeningHeight")									
                                    innSur.append(class_name1().getValue()*class_name2().getValue()/(1000*1000))
                                    nInnSur = nInnSur + 1										
                            elif node2lvl.isClassType("SimMaterialLayerSet_OpaqueLayerSet_Wall"):
                                conDat = node2lvl.getSimModelObject().RefId()
                            else:
                                print("Within SimWall_Wall_Interior: We need to add some code in order to deal with the following class ", node2lvl.ClassType())								
                        nameId = "".join(sorted(BoundariesNames)) 						
                    elif node.isClassType("SimWall_Wall_ExteriorAboveGrade"):				
                        opaque = True					
                        class_name = getattr(child_obj,"WallHeight")
                        height = class_name().getValue()/1000
                        class_name = getattr(hierarchy_obj,"GrossSurfaceArea")
                        GrossSurfaceArea = class_name().getValue()/(1000*1000)	
                        width =  GrossSurfaceArea/height
                        child2lvl_node_list = node.getChildList()
                        nInnSur= 0
                        innSur = []						
                        for node2lvl in child2lvl_node_list:						
                            if node2lvl.isClassType("SimFeatureElementSubtraction_Void_Opening"):
                                #Check if this Void_Opening is actually attached to the zone:						
                            	if 	node2lvl.getSimModelObject().RefId() in DoorVoidInZone[RelatingSpace] or node2lvl.getSimModelObject().RefId() in WindowVoidInZone[RelatingSpace]:
                                    class_name1 = getattr(node2lvl.getSimModelObject(),"OpeningWidth")
                                    class_name2 = getattr(node2lvl.getSimModelObject(),"OpeningHeight")									
                                    innSur.append(class_name1().getValue()*class_name2().getValue()/(1000*1000))
                                    nInnSur = nInnSur + 1										
                            elif node2lvl.isClassType("SimMaterialLayerSet_OpaqueLayerSet_Wall"):
                                conDat = node2lvl.getSimModelObject().RefId()
                            else:
                                print("Within SimWall_Wall_ExteriorAboveGrade: We need to add some code in order to deal with the following class ", node2lvl.ClassType())								
                    elif node.isClassType("SimGeomVector_Vector_Direction"):
                        class_name = getattr(node.getSimModelObject(),"DirectionRatios")					
                        v1 = np.array(class_name().getNumberList())		
                        v1_module = np.sum(v1*v1)		 			
                        angTil = math.acos((v1[2])/v1_module)*180/math.pi							
                        v2 = np.array([v1[0],v1[1],0])					
                        v2_module = np.sum(v2*v2)
                        if v2_module != 0: #south = 0째, east = -90째, west=90째, north= 180째				
                            angAzi = np.sign(v2[1])*math.acos(v2[0]/np.sum(v2*v2))*180/math.pi
                            if v2[0] >= 0:
                                pass
                            else:					
                                angAzi= angAzi-180					
                        else:
                            angAzi = 0				
                    elif node.isClassType("SimWindow_Window_Exterior"):			
                        opaque = False						
                        class_name = getattr(child_obj,"WindowHeight")
                        height = class_name().getValue()/1000
                        class_name = getattr(child_obj,"WindowWidth")
                        width = class_name().getValue()/1000
                    elif node.isClassType("SimSlab_Floor_InterzoneFloor"):			
                        opaque = True				
                        class_name = getattr(hierarchy_obj,"GrossSurfaceArea")
                        GrossSurfaceArea = class_name().getValue()/(1000*1000)
                        height = math.sqrt(GrossSurfaceArea)
                        width = height
                        child2lvl_node_list = node.getChildList()
                        nInnSur=0
                        innSur=[]
                        for node2lvl in child2lvl_node_list:						
                            if node2lvl.isClassType("SimMaterialLayerSet_OpaqueLayerSet_Floor"):
                                conDat = node2lvl.getSimModelObject().RefId()
                            else:
                                print("... need to review code section of SimSlab_Floor_InterzoneFloor")							
                    else:
                        print("We need to add code to deal with ", hierarchy_node.ClassType())
            #Children were examined -> Create instance for boundary:
            connectionsZoneDict[RelatingSpace] = connectionsZoneDict[RelatingSpace] + 1			
            if opaque:
                if InternalOrExternal == "EXTERNAL":
                    elementsOpaque_new.append(ElementOpaque(nameId,angAzi,angTil,height,width,conDat,nInnSur,innSur))
                    conEleZon_new.append(ConnectionElementZone(nameId,"1",RelatingSpace,connectionsZoneDict[RelatingSpace]))						
                    if v1[2] == -1:
                        contoground = contoground + 1						
                        conEleSol_new.append(ConnectionElementSolid(nameId,"2",contoground))							
                    else:
                        contoambient = contoambient + 1						
                        conEleAmb_new.append(ConnectionElementAmbient(nameId,"2",contoambient)) 							
                else:
                    if nameId in [x.name for x in elementsOpaque_new]:
                        conEleZon_new.append(ConnectionElementZone(nameId,"2",RelatingSpace,connectionsZoneDict[RelatingSpace]))					
                    else:					
                        elementsOpaque_new.append(ElementOpaque(nameId,angAzi,angTil,height,width,conDat,nInnSur,innSur))
                        conEleZon_new.append(ConnectionElementZone(nameId,"1",RelatingSpace,connectionsZoneDict[RelatingSpace]))							
            else:				
                if InternalOrExternal == "EXTERNAL":					
                    elementsTransparent_new.append(ElementTransparent(nameId,angAzi,angTil,height,width))			
                    conEleZon_new.append(ConnectionElementZone(nameId,"1",RelatingSpace,connectionsZoneDict[RelatingSpace]))
                    contoambient = contoambient + 1						
                    conEleAmb_new.append(ConnectionElementAmbient(nameId,"2",contoambient))						
                else:
                    if nameId in [x.name for x in elementsTransparent_new]:
                        conEleZon_new.append(ConnectionElementZone(nameId,"2",RelatingSpace,connectionsZoneDict[RelatingSpace]))							
                    else:					
                        elementsTransparent_new.append(ElementTransparent(nameId,angAzi,angTil,height,width))			
                        conEleZon_new.append(ConnectionElementZone(nameId,"1",RelatingSpace,connectionsZoneDict[RelatingSpace]))							
        else:#VIRTUAL -> Ignore boundary
            print("The boundary element ", hierarchy_obj.RefId() ," is VIRTUAL and will be therefore disregarded")	
            nVIRTUAL = nVIRTUAL + 1
            #FOR TESTING: WE ADD A DUMMY CEILING:
            nameId = "ID_"+str(nVIRTUAL)
            class_name = getattr(hierarchy_obj,"RelatingSpace")		
            RelatingSpace = class_name().getValue()			
            elementsOpaque_new.append(ElementOpaque(nameId,0,0,1,1,constructions_new[0].name,0,[]))
            contoambient = contoambient + 1
            connectionsZoneDict[RelatingSpace] = connectionsZoneDict[RelatingSpace] + 1			
            conEleZon_new.append(ConnectionElementZone(nameId,"1",RelatingSpace,connectionsZoneDict[RelatingSpace]))
            conEleAmb_new.append(ConnectionElementAmbient(nameId,"2",contoambient)) 			


ModelName = pathList[0].split(".")[0].split("\\")[-1]
print("Number of elementsOpaque_new: ", len(elementsOpaque_new))
print("Number of elementsTransparent_new: ", len(elementsTransparent_new))
print("Contoambient: ", contoambient)	
print("Contoground: " , contoground)		
print("connectionsZoneDict: ", connectionsZoneDict)
print("VIRTUAL ELEMENTS: ", nVIRTUAL)
print("Name of the model: ", ModelName)	
#print("\n OpaqueElements: ")
#for el in elementsOpaque_new:
#    print( el.name, " innerSurfaces: ", el.nInnSur)

	
## Thermal zones
zones = []
#for zone in jdata['zones']:
#  zones.append(Zone(zone['name'],zone['nEle'],zone['vol'],zone['hei'],zone['TSetHea'],zone['TSetCoo'],zone['ach'],zone['heaSou']))
#for i in range(1):
#  zones.append(Zone("zone_"+str(i),8,1.0,1.0,293.15,298.15,0.5,0.0))

 
zones_new = []
	
for hierarchy_node in nodeList:	
    if hierarchy_node.isClassType("SimSpatialZone_ThermalZone_Default"): # We have a zone!
        child = hierarchy_node.getChildList()[0]
# We use RefId of SimSpace_Occupied as name/Id (alternative: combination of Id with LongName?)		
        name = child.getSimModelObject().RefId()		
        # Retrieve needed info to instantiate Zone:		
        class_name = getattr(child.getSimModelObject(),"SpaceGrossVolume")	
        volume = class_name().getValue()	
        class_name = getattr(child.getSimModelObject(),"SpaceHeight")	
        height = class_name().getValue()/1000
        nBoundaries = len(child.getChildList())		
        zones_new.append(Zone(name,nBoundaries,volume,height,20,25,0.5,0.0))
	
## Opaque elements
elementsOpaque = []
#for eleOpa in jdata['elementsOpaque']:
#  elementsOpaque.append(ElementOpaque(eleOpa['name'],eleOpa['angAzi'],eleOpa['angTil'],eleOpa['hei'],eleOpa['wid'],eleOpa['conDat'],eleOpa['nInnSur'],eleOpa['innSur']))

for i in range(7):
  elementsOpaque.append(ElementOpaque("wall_"+str(i),0.0,90.0,1.0,1.0,"ConstructionStandard",0,""))

## Transparent elements
elementsTransparent = []
##for eleTra in jdata['elementsTransparent']:
##  elementsTransparent.append(ElementTransparent(eleTra['name'],eleTra['angAzi'],eleTra['angTil'],eleTra['hei'],eleTra['wid']))
for i in range(1):
  elementsTransparent.append(ElementTransparent("window_"+str(i),0.0,90.0,1.0,1.0))
  
## Element <-> zone
conEleZon = []
## for con in jdata['conEleZon']:
##  conEleZon.append(ConnectionElementZone(con['ele'],con['elePor'],con['zon'],con['zonPor']))
for i in range(7):
  conEleZon.append(ConnectionElementZone("wall_"+str(i),"1","zone_0",str(i+1)))
for i in range(1):
  conEleZon.append(ConnectionElementZone("window_"+str(i),"1","zone_0",str(7+i+1)))

  
## Element <-> ambient
conEleAmb = []
##for con in jdata['conEleAmb']:
##  conEleAmb.append(ConnectionElementAmbient(con['ele'],con['elePor'],con['ambPor']))

 
for i in range(6):
  conEleAmb.append(ConnectionElementAmbient("wall_"+str(i),"2",str(i+1)))
for i in range(1):
  conEleAmb.append(ConnectionElementAmbient("window_"+str(i),"2",str(6+i+1)))
	
## Element <-> solid ambient
conEleSol = []
## for con in jdata['conEleSol']:
##  conEleSol.append(ConnectionElementSolid(con['ele'],con['elePor'],con['solPor']))
for i in range(1):
  conEleSol.append(ConnectionElementSolid("wall_6","2",str(i+1)))

constructions = constructions_new  
zones = zones_new
conEleZon = conEleZon_new 
conEleAmb = conEleAmb_new  
conEleSol = conEleSol_new
elementsOpaque = elementsOpaque_new  
elementsTransparent = elementsTransparent_new  

## Building sytems
buildingSystem = BuildingSystem(ModelName,"BuildingSystems.Climate.WeatherDataMeteonorm.WeatherDataFile_Germany_Berlin()")
%>\
within;
model ${buildingSystem.name}
  "Model of a building with its climate ambient"
  extends Modelica.Icons.Example;

  % for con in constructions:
  record ${con.name}
    extends BuildingSystems.Buildings.Data.Constructions.OpaqueThermalConstruction(
      nLayers=${con.nLayers},
      thickness={
      % for value in con.thickness:
        ${value}${',' if not loop.last else ''}
      % endfor
      },
      material={
      % for value in con.material:
        ${value}()${',' if not loop.last else ''}
      % endfor
      });
  end ${con.name};
  % endfor

  model Building
    "Automatically generated multi-zone building model"
    extends BuildingSystems.Buildings.BaseClasses.BuildingTemplate(
    nZones = ${len(zones)},
    surfacesToAmbient(nSurfaces = ${len(conEleAmb)}),
    nSurfacesSolid = ${len(conEleSol)},
    surfacesToSolids(nSurfaces = nSurfacesSolid),
    convectionOnSurfaces = BuildingSystems.HAM.ConvectiveHeatTransfer.Types.Convection.forced,
    useAirPathes = false,
    heatSources = true,
    nHeatSources = ${len(zones)});

    parameter BuildingSystems.Buildings.Data.Constructions.Transparent.HeatProtectionDoubleGlazingUVal14 constructionWindow;

  % for zone in zones:
    BuildingSystems.Buildings.Zones.ZoneTemplateAirvolumeMixed ${zone.name}(
      V=${zone.volume},
      height=${zone.height},
      nConstructions1=${zone.nElements},
      heatSources=true,
      nHeatSources=1);
  % endfor

  % for ele in elementsOpaque:
    BuildingSystems.Buildings.Constructions.Walls.WallThermal1DNodes ${ele.name}(
    % if surTemOut == True:
      show_TSur = true,
    % endif
      redeclare ${ele.constructionData} constructionData,
      angleDegAzi = ${ele.angleDegAzi},
      angleDegTil = ${ele.angleDegTil},
      nInnSur = ${ele.nInnSur}, ${'AInnSur = ' if ele.nInnSur > 0 else ''}${'{' if ele.nInnSur > 0 else ''}${ele.innerSurfaces[0] if ele.nInnSur > 0 else ''}${'}' if ele.nInnSur > 0 else ''}${',' if ele.nInnSur > 0 else ''}
      height = ${ele.height},
      width = ${ele.width});
  % endfor

  % for ele in elementsTransparent:
    BuildingSystems.Buildings.Constructions.Windows.Window ${ele.name}(
    % if surTemOut == True:
      show_TSur = true,
    % endif
      angleDegAzi = ${ele.angleDegAzi},
      angleDegTil = ${ele.angleDegTil},
      height = ${ele.height},
      width = ${ele.width},
      UVal = (1.0 - ${ele.name}.framePortion) * constructionWindow.UValGla + ${ele.name}.framePortion * constructionWindow.UValFra,
      tauDir0 = constructionWindow.g,
      tauDif = constructionWindow.g);
  % endfor

  equation
    // connections between construction elements and zones
  % for con in conEleZon:
    connect(${con.element}.toSurfacePort_${con.elementPort}, ${con.zone}.toConstructionPorts1[${con.zonePort}]);
  % endfor
    // connections between construction elements and ambient
  % for con in conEleAmb:
    connect(${con.element}.toSurfacePort_${con.elementPort}, surfacesToAmbient.toConstructionPorts[${con.ambientPort}]);
  % endfor
    // connections between construction elements and ground
  % for con in conEleSol:
    connect(${con.element}.toSurfacePort_${con.elementPort}, surfacesToSolids.toConstructionPorts[${con.solidPort}]);
  % endfor
  // Heating set temperature of each thermal zones
  % for i in range(len(zones)):
    connect(${zones[i].name}.T_setHeating, T_setHeating[${i+1}]);
  % endfor
  // Cooling set temperatures of each thermal zones
  % for i in range(len(zones)):
    connect(${zones[i].name}.T_setCooling, T_setCooling[${i+1}]);
  % endfor
  // airchange rates of each thermal zones
  % for i in range(len(zones)):
    connect(${zones[i].name}.airchange, airchange[${i+1}]);
  % endfor
  // ambient temperature of each thermal zones
  % for i in range(len(zones)):
    connect(${zones[i].name}.TAirAmb, TAirAmb);
  % endfor
  // ambient moisture of each thermal zones
  % for i in range(len(zones)):
    connect(${zones[i].name}.xAirAmb, xAirAmb);
  % endfor
  // Cooling load of each thermal zones
  % for i in range(len(zones)):
    connect(${zones[i].name}.Q_flow_cooling, Q_flow_cooling[${i+1}]);
  % endfor
  // Heating load of each thermal zones
  % for i in range(len(zones)):
    connect(${zones[i].name}.Q_flow_heating, Q_flow_heating[${i+1}]);
  % endfor
  // Radiative heating source of each thermal zones
  % for i in range(len(zones)):
    connect(${zones[i].name}.radHeatSourcesPorts[1], radHeatSourcesPorts[${i+1}]);
  % endfor
  // Convective heating source of each thermal zones
  % for i in range(len(zones)):
    connect(${zones[i].name}.conHeatSourcesPorts[1], conHeatSourcesPorts[${i+1}]);
  % endfor
  % if surTemOut == True:
  // Connections for surface temperatures
<% i = 1 %>\
    % for ele in elementsOpaque:
    connect(${ele.name}.TSur_1, TSur[${i}]);<% i = i + 1 %>
    connect(${ele.name}.TSur_2, TSur[${i}]);<% i = i + 1 %>
    % endfor
    % for ele in elementsTransparent:
    connect(${ele.name}.TSur_1, TSur[${i}]);<% i = i + 1 %>
    connect(${ele.name}.TSur_2, TSur[${i}]);<% i = i + 1 %>
    % endfor
  % endif
  end Building;

  Building building(
  % if surTemOut == True:
    show_TSur = true,
    nSurfaces = ${2*len(elementsOpaque)+2*len(elementsTransparent)},
  % endif
    nZones = ${len(zones)});

  BuildingSystems.Buildings.Ambient ambient(
    nSurfaces = building.nSurfacesAmbient,
    weatherDataFile = ${buildingSystem.location});

    // Heating set temperature of the thermal zones
    % for zone in zones:
    Modelica.Blocks.Sources.Constant TSetHeating_${zone.name}(k=273.15 + ${zone.TSetHeating});
    % endfor
    // Cooling set temperature of each thermal zones
    % for zone in zones:
    Modelica.Blocks.Sources.Constant TSetCooling_${zone.name}(k=273.15 + ${zone.TSetCooling});
    % endfor
    // Air change rate of each thermal zones
    % for zone in zones:
    Modelica.Blocks.Sources.Constant airchange_${zone.name}(k=${zone.airchange});
    % endfor
    // Heating source of each thermal zones
    % for zone in zones:
    Modelica.Blocks.Sources.Constant heatsources_${zone.name}(k=${zone.heatsource});
    % endfor
    Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow heatFlow[${len(zones)}];
    BuildingSystems.Buildings.BaseClasses.RelationRadiationConvection relationRadiationConvection[${len(zones)}](each radiationportion = 0.5);
  equation
    connect(ambient.toSurfacePorts, building.toAmbientSurfacesPorts);
    connect(ambient.toAirPorts, building.toAmbientAirPorts);
    connect(ambient.TAirRef, building.TAirAmb);
    connect(ambient.xAir, building.xAirAmb);
    // Heating set temperature of each thermal zones
    % for i in range(len(zones)):
    connect(TSetHeating_${zones[i].name}.y, building.T_setHeating[${i+1}]);
    % endfor
    // Cooling set temperature of each thermal zones
    % for i in range(len(zones)):
    connect(TSetCooling_${zones[i].name}.y, building.T_setCooling[${i+1}]);
    % endfor
    // Air change rate of each thermal zones
    % for i in range(len(zones)):
    connect(airchange_${zones[i].name}.y, building.airchange[${i+1}]);
    % endfor
    // Heating source of each thermal zones
    % for i in range(len(zones)):
    connect(heatsources_${zones[i].name}.y, heatFlow[${i+1}].Q_flow);
    % endfor
    connect(relationRadiationConvection.heatPort, heatFlow.port);
    connect(relationRadiationConvection.heatPortCv, building.conHeatSourcesPorts[1:${len(zones)}]);
    connect(relationRadiationConvection.heatPortLw, building.radHeatSourcesPorts[1:${len(zones)}]);

  annotation(experiment(StartTime=0, StopTime=31536000),
    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}})));
end ${buildingSystem.name};