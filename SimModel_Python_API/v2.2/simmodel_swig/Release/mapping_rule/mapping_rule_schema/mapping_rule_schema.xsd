<?xml version="1.0" encoding="utf-8"?>
<xs:schema targetNamespace="http://www.e3d.rwth-aachen.de/namespaces/Sim/DataMap" xmlns:datamap="http://www.e3d.rwth-aachen.de/namespaces/Sim/DataMap" xmlns:xs="http://www.w3.org/2001/XMLSchema"  elementFormDefault="qualified" attributeFormDefault="unqualified">
	<!-- Copyright (C) 2012-2015 Institute of Energy Efficient Building E3D, -->
	<!-- RWTH Aachen University, Germany. -->
	<!-- This program was developed for the EnEff-BIM project. In EnEff-BIM, -->
	<!-- a project participating in IEA Annex 60, translators between Building -->
	<!-- Information Models (BIM) and Modelica are developed to support building -->
	<!-- and community energy performance simulation. This is accomplished through -->
	<!-- extending existing standards for exchanging energy calculation data, and -->
	<!-- through data representation formats such as the Industry Foundation Classes (IFC). -->
	<!-- This program is free software; you can redistribute it and/or modify it -->
	<!-- under the terms of the GNU General Public License version 2 as published -->
	<!-- by the Free Software Foundation. -->
	<!-- This program is distributed in the hope that it will be useful, -->
	<!-- but WITHOUT ANY WARRANTY; without even the implied warranty of -->
	<!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
	<!-- GNU General Public License for more details. -->
	<!-- You should have received a copy of the GNU General Public License -->
	<!-- along with this program; if not, write to the Free Software -->
	<!-- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA -->
	<!-- In addition, as a special exception, simmodel2c++ gives permission to -->
	<!-- link this program with the XML data binding framework generated by the -->
	<!-- Code Synthesis Tools CC, and distribute linked combinations including -->
	<!-- the two. You must obey the GNU General Public License version 2 in all -->
	<!-- respects for all of the code used. If you modify this copy of the program, -->
	<!-- you may extend this exception to your version of the program, but you are -->
	<!-- not obligated to do so. If you do not wish to do so, delete this exception -->
	<!-- statement from your version. -->
	<!--==============================Data Mapping Schema =================================-->
	<!-- a list of strings -->
	<xs:simpleType name="StringList">
		<xs:list itemType="xs:string"/>
	</xs:simpleType>
	<!-- store a list of double values -->
	<xs:simpleType name="Map_DoubleList">
		<xs:list itemType="xs:double"/>
	</xs:simpleType>
	<!-- store a list of Id values -->
	<xs:simpleType name="IdList">
		<xs:list itemType="xs:ID"/>
	</xs:simpleType>
	<!-- an enumeration of different value types -->
	<!-- single: a single real value, e.g., double, integer -->
	<!-- range: we define the value by giving upper and lower bounds of the value -->
	<!-- array: we define the value by giving an array storing a set of discreted values (i.e., 1xN matrix) -->
	<!-- matrix: the given value or output values of an function will be stored in an NxN matrix -->
	<xs:simpleType name="ValueType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="single"/>
			<xs:enumeration value="range"/>
			<xs:enumeration value="array"/>
			<xs:enumeration value="matrix"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- extended string type by adding an attribute 'RefId' -->
	<!-- set the 'RefId' value by an integer, such as 0, 1, 2, ... -->
	<!-- we can use 'RefId' to index or identify this string element -->
	<xs:complexType name="RefString">
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="RefId" type="xs:integer"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!-- extended string list by adding an attribute 'RefId' -->
	<!-- set the 'RefId' value by an integer, such as 0, 1, 2, ... -->
	<!-- we can use 'RefId' to index or identify this string list element -->
	<xs:complexType name="RefStringList">
		<xs:simpleContent>
			<xs:extension base="datamap:StringList">
				<xs:attribute name="RefId" type="xs:integer"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!-- rule or object description -->
	<xs:element name="Description" type="xs:string"/>
	<!-- name of a function paramter -->
	<!-- relative parameter location + parameter name, seperated by blank space -->
	<xs:element name="ParameterName" type="datamap:StringList"/>
	<!-- name of a function coeffcient -->
	<xs:element name="CoefficientName" type="xs:string"/>
	<!-- propetry name defined in traget model, e.g., Modelica -->
	<xs:element name="TargetPropertyName" type="xs:string"/>
	<!-- propetry name list defined in traget model, e.g., Modelica -->
	<!-- support regular expression to define nested property assignment -->
	<!-- by nested format: locations + multiple property names, the location directory is separated by '(' and ')' -->
	<xs:element name="TargetPropertyNameList" type="datamap:RefStringList"/>
	<!-- component name in source model: SimModel -->
	<xs:element name="SourceComponentName" type="datamap:RefString"/>
	<!-- component name in target model: Modelica -->
	<xs:element name="TargetComponentName" type="xs:string"/>
	<!-- the library saving target data model: AixLib, BuidingSystems, Buildings -->
	<xs:element name="TargetLibraryName" type="xs:string"/>
	<!-- component and propety location in the target data model: Modelica -->
	<!-- the direcotry is separated by blank space -->
	<xs:element name="TargetLocation" type="datamap:StringList"/>
	<!-- the name of a record instance declared in the target data model: Modelica -->
	<xs:element name="RecordInstance" type="xs:string"/>
	<!-- a record instance location in the target data model: Modelica -->
	<xs:element name="RecordInstanceLocation" type="xs:string"/>
	<!-- a record location in the target data model: Modelica -->
	<xs:element name="RecordLocation" type="xs:string"/>
	<!-- default value assigned to the newly added property -->
	<xs:element name="DefaultValueNumber" type="xs:double"/>
	<xs:element name="DefaultValueString" type="xs:string"/>
	<!-- a list of default value assigned to the newly added properties -->
	<xs:element name="DefaultValueList" type="datamap:StringList"/>
	<!-- a single value stored as the referenced string type -->
	<xs:element name="RefValue" type="datamap:RefStringList"/>
	<!-- an Id refers to a property mapping rule -->
	<xs:element name="PropertyId" type="xs:ID"/>
	<!-- a list of Ids refer to different property mapping rules -->
	<xs:element name="PropertyIdList" type="datamap:IdList"/>
	<!-- a single real value stored as a double type -->
	<xs:element name="Value" type="xs:double"/>
	<!-- a list of real values stored as double types -->
	<xs:element name="ValueList" type="datamap:Map_DoubleList"/>
	<!-- check if the value (e.g., propetry, component) is defined in a referenced element -->
	<!-- outside the scope of current element -->
	<!-- a boolean type enumeration: true or false -->
	<xs:element name="IsReferenced" type="xs:boolean"/>
	<!-- represent the type of a given value -->
	<xs:element name="ValueType" type="datamap:ValueType"/>
	<!-- specify the data format of a given value -->
	<!-- if it is a matrix, then we specify each column of it -->
	<xs:element name="ValueFormat" type="datamap:StringList"/>
	<!-- the value bounds for a range value -->
	<xs:group name="ValueBounds">
		<xs:sequence>
			<xs:choice minOccurs="1" maxOccurs="1">
				<!-- lower bound for a range value -->
				<xs:element name="LowerBoundRef" type="datamap:StringList"/>
				<xs:element name="LowerBoundValue" type="xs:double"/>
			</xs:choice>
			<xs:choice minOccurs="1" maxOccurs="1">
				<!-- upper bound for a range value -->
				<xs:element name="UpperBoundRef" type="datamap:StringList"/>
				<xs:element name="UpperBoundValue" type="xs:double"/>
			</xs:choice>
		</xs:sequence>
	</xs:group>
	<!-- store an input paramter of the given function -->
	<xs:complexType name="InputParameter">
		<xs:sequence>
			<xs:element ref="datamap:Description" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:ParameterName" minOccurs="1" maxOccurs="1"/>
			<!-- for range value, we need to set the interpolation step -->
			<xs:element ref="datamap:ValueType" minOccurs="0" maxOccurs="1"/>
			<!-- if set, then the value is defined in a referenced element (outside current scope) -->
			<xs:element ref="datamap:IsReferenced" minOccurs="0" maxOccurs="1"/>
			<xs:choice minOccurs="1" maxOccurs="1">
				<!-- a single referenced value -->
				<xs:element ref="datamap:RefValue"/>
				<!-- a list of discreted values -->
				<xs:element ref="datamap:ValueList"/>
				<!-- a range type saving lower and upper bounds -->
				<xs:group ref="datamap:ValueBounds"/>
			</xs:choice>
		</xs:sequence>
		<xs:attribute name="RefId" type="xs:ID" use="required"/>
	</xs:complexType>
	<!-- store an input coefficient of the given function -->
	<xs:complexType name="InputCoefficient">
		<xs:sequence>
			<xs:element ref="datamap:Description" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:CoefficientName" minOccurs="1" maxOccurs="1"/>
			<!-- if set, then the value is defined in a referenced element (outside current scope) -->
			<xs:element ref="datamap:IsReferenced" minOccurs="0" maxOccurs="1"/>
			<xs:choice minOccurs="1" maxOccurs="1">
				<xs:element ref="datamap:Value"/>
				<xs:element ref="datamap:RefValue"/>
			</xs:choice>
		</xs:sequence>
		<xs:attribute name="RefId" type="xs:ID" use="required"/>
	</xs:complexType>
	<!-- a function defined for propetry transformation -->
	<xs:element name="Function" type="datamap:StringList"/>
	<!-- store the output parameter value of an given function -->
	<xs:complexType name="OutputParameter">
		<xs:sequence>
			<xs:element ref="datamap:Description" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:ParameterName" minOccurs="1" maxOccurs="1"/>
			<xs:element ref="datamap:ValueType" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:ValueFormat" minOccurs="0" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="RefId" type="xs:ID" use="required"/>
	</xs:complexType>
	<!-- propetry mapping relationship: value transformation process -->
	<!-- this process represents two different kinds of transformations: -->
	<!-- one2one transformation/map: convert single property into an output property by the transformation function -->
	<!-- many2one transformation/map: covert multiple properties into an output property -->
    <!-- one2many transformation/map: convert one property into multiple output properties. This can be divided into -->
    <!-- a set of one2one conversions -->
	<xs:complexType name="Property_Map_Transformation">
		<xs:sequence>
			<xs:element ref="datamap:Description" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:InputParameterName" minOccurs="1" maxOccurs="unbounded"/> <!-- xs:IDREF -->
			<xs:element ref="datamap:InputCoefficientName" minOccurs="0" maxOccurs="unbounded"/> <!-- xs:IDREF -->
			<xs:element ref="datamap:Function" minOccurs="1" maxOccurs="1"/>
			<xs:element ref="datamap:OutputParameterName" minOccurs="1" maxOccurs="unbounded"/> <!-- xs:IDREF -->
			<xs:element ref="datamap:TargetLocation" minOccurs="0" maxOccurs="unbounded"/>
			<!-- map properties from SimModel into a record structure declared in Modelica -->
			<xs:element ref="datamap:RecordInstance" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:RecordInstanceLocation" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:RecordLocation" minOccurs="0" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="RefId" type="xs:ID" use="required"/>
	</xs:complexType>

	<!-- propetry mapping relationship: one to one mapping -->
	<xs:complexType name="Property_Map_One2One">
		<xs:sequence>
			<xs:element ref="datamap:Description" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:RefValue" minOccurs="1" maxOccurs="1"/>
			<xs:element ref="datamap:TargetPropertyName" minOccurs="1" maxOccurs="1"/>
			<xs:element ref="datamap:TargetLocation" minOccurs="0" maxOccurs="1"/>
			<!-- map properties from SimModel into a record structure declared in Modelica -->
			<xs:element ref="datamap:RecordInstance" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:RecordInstanceLocation" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:RecordLocation" minOccurs="0" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="RefId" type="xs:ID" use="required"/>
	</xs:complexType>
	<!-- propetry mapping relationship: Gap (add missing propteries) -->
	<xs:complexType name="Property_Map_Gap">
		<xs:sequence>
			<xs:element ref="datamap:Description" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:TargetPropertyName" minOccurs="1" maxOccurs="1"/>
			<xs:element ref="datamap:TargetLocation" minOccurs="0" maxOccurs="1"/>
			<xs:choice>
				<xs:element ref="datamap:DefaultValueNumber"/>
				<xs:element ref="datamap:DefaultValueString"/>
			</xs:choice>
			<!-- map properties from SimModel into a record structure declared in Modelica -->
			<xs:element ref="datamap:RecordInstance" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:RecordInstanceLocation" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:RecordLocation" minOccurs="0" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="RefId" type="xs:ID" use="required"/>
	</xs:complexType>
	<!-- a group of different property mapping rules: one2one, gap, transformation -->
	<!-- used to define internal properties of components -->
	<xs:group name="Property_Map_Rules">
		<xs:sequence>
			<!-- xs:IDREF -->
			<xs:element ref="datamap:Property_Map_One2One_Name" minOccurs="0" maxOccurs="unbounded"/>
			<!-- xs:IDREF -->
			<xs:element ref="datamap:Property_Map_Gap_Name" minOccurs="0" maxOccurs="unbounded"/>
			<!-- xs:IDREF -->
			<xs:element ref="datamap:Property_Map_Transformation_Name" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:group>
	<!-- component mapping rule 1: one to one mapping -->
	<!-- map one component to another one -->
	<xs:complexType name="Component_Map_One2One">
		<xs:sequence>
			<xs:element ref="datamap:Description" minOccurs="0"/>
			<xs:element ref="datamap:SourceComponentName"/>
			<xs:element ref="datamap:TargetComponentName"/>
			<xs:element ref="datamap:TargetLocation" minOccurs="0"/>
			<xs:group ref="datamap:Property_Map_Rules" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="RefId" type="xs:ID" use="required"/>
	</xs:complexType>
	<!-- element instance of the mapping group -->
	<!-- a mapping group contains: the target component, location, and its property mapping process -->
	<xs:complexType name="ComponentMappingGroup">
		<xs:sequence>
			<xs:element ref="datamap:Description" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:TargetComponentName" minOccurs="1" maxOccurs="1"/>
			<xs:element ref="datamap:TargetLocation" minOccurs="0" maxOccurs="1"/>
			<!-- if not declared in XML, use default property values of the target library -->
			<xs:group ref="datamap:Property_Map_Rules" minOccurs="0" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="RefId" type="xs:ID" use="required"/>
	</xs:complexType>
	<!-- component mapping rule 2: one to many mapping -->
	<!-- map one component to multiple components -->
	<xs:complexType name="Component_Map_One2Many">
		<xs:sequence>
			<xs:element ref="datamap:Description" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:SourceComponentName" minOccurs="1" maxOccurs="1"/>
			<xs:element ref="datamap:ComponentMappingGroupName" minOccurs="1" maxOccurs="unbounded"/>
			<!-- xs:IDREF -->
		</xs:sequence>
		<xs:attribute name="RefId" type="xs:ID" use="required"/>
	</xs:complexType>
	<!-- component mapping rule 3: Gap (add missing components) -->
	<!-- add a new component in target model: e.g., Modelica -->
	<xs:complexType name="Component_Map_Gap">
		<xs:sequence>
			<xs:element ref="datamap:Description" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:TargetComponentName" minOccurs="1" maxOccurs="1"/>
			<xs:element ref="datamap:TargetLocation" minOccurs="0" maxOccurs="1"/>
			<xs:group ref="datamap:Property_Map_Rules" minOccurs="0" maxOccurs="1"/>
			<!-- xs:IDREF -->
		</xs:sequence>
		<xs:attribute name="RefId" type="xs:ID" use="required"/>
	</xs:complexType>
	<!-- a list of component mapping rules -->
	<!-- define a model translation/mapping processing between source model and traget model -->
	<!-- by a sequcence of mapping process stages -->
	<xs:group name="Component_Map_Rules">
		<xs:sequence>
			<!-- xs:IDREF -->
			<xs:element ref="datamap:Component_Map_One2One_Name" minOccurs="0" maxOccurs="unbounded"/>
			<!-- xs:IDREF -->
			<xs:element ref="datamap:Component_Map_One2Many_Name" minOccurs="0" maxOccurs="unbounded"/>
			<!-- xs:IDREF -->
			<xs:element ref="datamap:Component_Map_Gap_Name" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:group>
	<!-- data translation/mapping process defintion for different target Modelica libraries -->
	<!-- contains: the target library name and its data mapping process -->
	<xs:complexType name="Library_Mapping_Rule">
		<xs:sequence>
			<xs:element ref="datamap:Description" minOccurs="0" maxOccurs="1"/>
			<xs:element ref="datamap:TargetLibraryName" minOccurs="1" maxOccurs="1"/>
			<xs:group ref="datamap:Component_Map_Rules" minOccurs="1" maxOccurs="1"/>
		</xs:sequence>
	</xs:complexType>
	<!-- an element of input paramter -->
	<xs:element name="InputParameter" type="datamap:InputParameter"/>
	<!-- Id refers to the InputParameter -->
	<xs:element name="InputParameterName" type="xs:IDREF"/>
	<!-- an element of input coefficient -->
	<xs:element name="InputCoefficient" type="datamap:InputCoefficient"/>
	<!-- Id refers to the InputCoefficient -->
	<xs:element name="InputCoefficientName" type="xs:IDREF"/>
	<!-- an element of output parameter -->
	<xs:element name="OutputParameter" type="datamap:OutputParameter"/>
	<!-- Id refers to the OutputParameter -->
	<xs:element name="OutputParameterName" type="xs:IDREF"/>
	<!-- an element of propetry mapping -->
	<xs:element name="Property_Map_Transformation" type="datamap:Property_Map_Transformation"/>
	<!-- Id refers to the Property_Map_Transformation -->
	<xs:element name="Property_Map_Transformation_Name" type="xs:IDREF"/>
	<!-- an element of propetry mapping -->
	<xs:element name="Property_Map_One2One" type="datamap:Property_Map_One2One"/>
	<!-- Id refers to the Property_Map_One2One -->
	<xs:element name="Property_Map_One2One_Name" type="xs:IDREF"/>
	<!-- an element of propetry mapping -->
	<xs:element name="Property_Map_Gap" type="datamap:Property_Map_Gap"/>
	<!-- Id refers to the Property_Map_Gap -->
	<xs:element name="Property_Map_Gap_Name" type="xs:IDREF"/>
	<!-- an element of component mapping -->
	<xs:element name="Component_Map_One2One" type="datamap:Component_Map_One2One"/>
	<!-- Id refers to the Component_Map_One2One -->
	<xs:element name="Component_Map_One2One_Name" type="xs:IDREF"/>
	<!-- an element of component mapping -->
	<xs:element name="ComponentMappingGroup" type="datamap:ComponentMappingGroup"/>
	<!-- Id refers to the ComponentMappingGroup -->
	<xs:element name="ComponentMappingGroupName" type="xs:IDREF"/>
	<!-- an element of component mapping -->
	<xs:element name="Component_Map_One2Many" type="datamap:Component_Map_One2Many"/>
	<!-- Id refers to the Component_Map_Many2Many -->
	<xs:element name="Component_Map_One2Many_Name" type="xs:IDREF"/>
	<!-- an element of component mapping -->
	<xs:element name="Component_Map_Gap" type="datamap:Component_Map_Gap"/>
	<!-- Id refers to the Component_Map_Gap -->
	<xs:element name="Component_Map_Gap_Name" type="xs:IDREF"/>
	<!-- an element of data translation/mapping process defintion for different target Modelica libraries -->
	<xs:element name="Library_Mapping_Rule" type="datamap:Library_Mapping_Rule"/>
	<xs:element name="Data_Model_Map">
		<xs:annotation>
			<xs:documentation>XML representation of mapping rules between SimModel and differnt Modelica libraries. Two different levels: First: Component mapping, Second: Property mapping</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="datamap:RefValue" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="datamap:InputParameter" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="datamap:InputCoefficient" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="datamap:OutputParameter" minOccurs="0" maxOccurs="unbounded"/>
				<!-- property mapping -->
				<xs:element ref="datamap:Property_Map_One2One" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="datamap:Property_Map_Gap" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="datamap:Property_Map_Transformation" minOccurs="0" maxOccurs="unbounded"/>
				<!-- component mapping -->
				<xs:element ref="datamap:Component_Map_One2One" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="datamap:ComponentMappingGroup" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="datamap:Component_Map_One2Many" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="datamap:Component_Map_Gap" minOccurs="0" maxOccurs="unbounded"/>
				<!-- library mapping -->
				<xs:element ref="datamap:Library_Mapping_Rule"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!--===================================end=====================================-->
</xs:schema>
