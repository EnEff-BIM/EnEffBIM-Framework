// Copyright (C) 2012-2015 Institute of Energy Efficient Building E3D,
// RWTH Aachen University, Germany.
//
// This program was developed for the EnEff-BIM project. In EnEff-BIM, 
// a project participating in IEA Annex 60, translators between Building 
// Information Models (BIM) and Modelica are developed to support building
// and community energy performance simulation. This is accomplished through 
// extending existing standards for exchanging energy calculation data, and 
// through data representation formats such as the Industry Foundation Classes (IFC).
//
// This program is free software; you can redistribute it and/or modify it 
// under the terms of the GNU General Public License version 2 as published 
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, simmodel2c++ gives permission to 
// link this program with the XML data binding framework generated by the 
// Code Synthesis Tools CC, and distribute linked combinations including 
// the two. You must obey the GNU General Public License version 2 in all 
// respects for all of the code used. If you modify this copy of the program, 
// you may extend this exception to your version of the program, but you are 
// not obligated to do so. If you do not wish to do so, delete this exception 
// statement from your version.
//

// include the head file
#include "ruleFilter.h"

// count the number of components
int map_rule_filter::next_id = 0;

//! load mapping rules: filter each rules, build the index for them
void map_rule_filter::load_rule_data(auto_ptr<SimMap>& rule_model)
{
	// load component mapping rules
	// one2one mapping
	SimMap::Component_Map_One2one_sequence& _component_one2one_list = rule_model->Component_Map_One2one();
	for(SimMap::Component_Map_One2one_iterator _com_one2one_it=_component_one2one_list.begin(); _com_one2one_it!=_component_one2one_list.end(); ++_com_one2one_it)
	{
		component_one2one_index.insert( pair<string, SimMap::Component_Map_One2one_iterator>(_com_one2one_it->SourceComponentName(), _com_one2one_it) );
	}
	//! many2one
	SimMap::Component_Map_Many2One_sequence& _component_many2one_list = rule_model->Component_Map_Many2One();
	// one2many
	SimMap::Component_Map_One2Many_sequence& _component_one2many_list = rule_model->Component_Map_One2Many();
	for(SimMap::Component_Map_One2Many_iterator _com_one2many_it=_component_one2many_list.begin(); _com_one2many_it!=_component_one2many_list.end(); ++_com_one2many_it)
	{
		component_one2many_index.insert( pair<string, SimMap::Component_Map_One2Many_iterator>(_com_one2many_it->SourceComponentName(), _com_one2many_it) );
	}
	// gap: load the given components
	// that are not defined in SimModel
	_component_gap_list_ptr = &rule_model->Component_Map_Gap();

	// load property mapping rules
	// mapping group
	SimMap::ComponentMappingGroup_sequence& _component_map_group_list = rule_model->ComponentMappingGroup();
	for(SimMap::ComponentMappingGroup_iterator _com_map_group_it=_component_map_group_list.begin(); _com_map_group_it!=_component_map_group_list.end(); ++_com_map_group_it)
	{
		component_map_group_index.insert( pair<string, SimMap::ComponentMappingGroup_iterator>(_com_map_group_it->RefId(), _com_map_group_it) );
	}
	// one2one
	SimMap::Property_Map_One2one_sequence& _property_one2one_list = rule_model->Property_Map_One2one();
	for(SimMap::Property_Map_One2one_iterator _pro_one2one_it=_property_one2one_list.begin(); _pro_one2one_it!=_property_one2one_list.end(); ++_pro_one2one_it)
	{
		property_one2one_index.insert( pair<string, SimMap::Property_Map_One2one_iterator>(_pro_one2one_it->RefId(), _pro_one2one_it) );
	}
	// gap
	SimMap::Property_Map_Gap_sequence& _property_gap_list = rule_model->Property_Map_Gap();
	for(SimMap::Property_Map_Gap_iterator _pro_gap_it=_property_gap_list.begin(); _pro_gap_it!=_property_gap_list.end(); ++_pro_gap_it)
	{
		property_gap_index.insert( pair<string, SimMap::Property_Map_Gap_iterator>(_pro_gap_it->RefId(), _pro_gap_it) );
	}
	// combination
	SimMap::Property_Map_Combination_sequence& _property_combination_list = rule_model->Property_Map_Combination();
	for(SimMap::Property_Map_Combination_iterator _pro_combination_it=_property_combination_list.begin(); _pro_combination_it!=_property_combination_list.end(); ++_pro_combination_it)
	{
		property_combination_index.insert( pair<string, SimMap::Property_Map_Combination_iterator>(_pro_combination_it->RefId(), _pro_combination_it) );
	}
	// ...
	
}

// filter the SimModel data of given component
bool map_rule_filter::filter_component(sim_base* component_ptr, vector<component_data>& _component_list)
{
	// check one2one component mapping
	map<string, SimMap::Component_Map_One2one_iterator>::iterator _com_one2one_it =  component_one2one_index.find( component_ptr->get_com_name() );
	if( _com_one2one_it!=component_one2one_index.end() )
	{
		component_data _component;
		// call one2one mapping rule
		filter_component_map_one2one(_com_one2one_it->second, component_ptr, _component);
		// save the component data
		_component_list.push_back(_component);
		return true;
	}
	//! many2one
	// check one2many component mapping
	map<string, SimMap::Component_Map_One2Many_iterator>::iterator _com_one2many_it = component_one2many_index.find( component_ptr->get_com_name() );
	if( _com_one2many_it!=component_one2many_index.end() )
	{
		// call one2many mapping rule
		filter_component_map_one2many(_com_one2many_it->second, component_ptr, _component_list);
		return true;
	}

	// filter is not found
	return false;
}

// add the missing components
bool map_rule_filter::add_gap_component(vector<component_data>& _component_list)
{
	// check gap component mapping
	for(SimMap::Component_Map_Gap_iterator _com_gap_it=_component_gap_list_ptr->begin(); _com_gap_it!=_component_gap_list_ptr->end(); ++_com_gap_it)
	{
		component_data _component;
		// call gap mapping rule
		filter_component_map_gap(_com_gap_it, _component);
		// save the component data
		_component_list.push_back(_component);
	}

	return true;
}

// propetry mapping template: one to one mapping
void map_rule_filter::filter_property_map_one2one(SimMap::Property_Map_One2one_iterator property_it, sim_base* component_ptr, property_data& _property)
{
	// retrieve the target property name
	_property.set_property_name( property_it->TargetPropertyName() );
	// retrieve the target property value from current component class
	QObject* myClassPtr = dynamic_cast<QObject*>(component_ptr);
	if(property_it->RefValue().size()==1)
	{
		string method_name = "get_" + *property_it->RefValue().begin() + "()";
		int fid = myClassPtr->metaObject()->indexOfMethod(method_name.c_str());
		if(fid!=-1)
        {
            QMetaMethod method = myClassPtr->metaObject()->method(fid);
            string retVal = "";
			//! determine the return value type
			// get_value_type() or retVal
			method.invoke(myClassPtr,
                          Q_RETURN_ARG(string, retVal));
			//! save property value
			_property.set_property_value(retVal);
        }
	}
	//! retrieve target property location in the Modelica lib
	if(property_it->TargetLocation().present())
	{
		_property.set_target_location( *property_it->TargetLocation().get().begin() );
	}
	// retrieve record instance name
	if(property_it->RecordInstance().present())
	{
		_property.set_record_instance( property_it->RecordInstance().get() );
	}
	// retrieve record structure location in the Modelica lib
	if(property_it->RecordLocation().present())
	{
		_property.set_record_location( property_it->RecordLocation().get() );
	}
}

// propetry mapping template: gap
void map_rule_filter::filter_property_map_gap(SimMap::Property_Map_Gap_iterator property_it, property_data& _property)
{
	// retrieve the target property name
	_property.set_property_name( property_it->TargetPropertyName() );
	// retrieve the default value for target property
	_property.set_property_value( property_it->DefaultValue() );
	//! retrieve target property location in the Modelica lib
	if(property_it->TargetLocation().present())
	{
		_property.set_target_location( *property_it->TargetLocation().get().begin() );
	}
	// retrieve record instance name
	if(property_it->RecordInstance().present())
	{
		_property.set_record_instance( property_it->RecordInstance().get() );
	}
	// retrieve record structure location in the Modelica lib
	if(property_it->RecordLocation().present())
	{
		_property.set_record_location( property_it->RecordLocation().get() );
	}
}

//! propetry mapping template: combination
void map_rule_filter::filter_property_map_combination(SimMap::Property_Map_Combination_iterator property_it, property_data& _property)
{
	// init property and value group
	string property_value_group = "";
	//! gap value list
	StringList::iterator _val_list_it = property_it->DefaultValueList().get().begin();
	// retrieve target properties and their values
	for(StringList::iterator _pro_list_it=property_it->TargetPropertyNameList().begin(); _pro_list_it!=property_it->TargetPropertyNameList().end();)
	{
		// current property string
		string cur_pro = *_pro_list_it++;
		if( cur_pro=="(" )
		{
			property_value_group += "(";
		}
		else if( cur_pro==")" )
		{
			property_value_group += ")";
		}
		else
		{
			if( _pro_list_it!=property_it->TargetPropertyNameList().end() ) 
			{
				if( *_pro_list_it!="(" )
				{
					// add a new property
					property_value_group = property_value_group + cur_pro + "=" + *_val_list_it++;

					if( *_pro_list_it!=")" )
						property_value_group += ", ";
				}
				else
				{
					// add a directory
					property_value_group = property_value_group + cur_pro;
				}
			}
			else
			{
				// the last property
				property_value_group = property_value_group + cur_pro + "=" + *_val_list_it;
			}
		}
	}
	// set a group of target propertys and their values
	_property.set_property_value_group(property_value_group);
	//! retrieve target property location in the Modelica lib
	if(property_it->TargetLocation().present())
	{
		_property.set_target_location( *property_it->TargetLocation().get().begin() );
	}
	// retrieve record instance name
	if(property_it->RecordInstance().present())
	{
		_property.set_record_instance( property_it->RecordInstance().get() );
	}
	// retrieve record structure location in the Modelica lib
	if(property_it->RecordLocation().present())
	{
		_property.set_record_location( property_it->RecordLocation().get() );
	}
}

// component mapping template: one to one mapping
void map_rule_filter::filter_component_map_one2one(SimMap::Component_Map_One2one_iterator component_it, sim_base* component_ptr, component_data& _component)
{
	// retrieve the target component name
	_component.set_target_component_name( component_it->TargetComponentName() + QString::number(next_id).toStdString() );
	// increase the id number
	map_rule_filter::next_component_id();

	//! retrieve target component location in the Modelica lib
	if( component_it->TargetLocation().present() )
	{
		_component.set_target_location( *component_it->TargetLocation().get().begin() );
	}
	
	// save the unmapped simmodel component reference
	_component.save_unmapped_component(component_ptr);

	// retrieve properties belong to current component
	// property one2one mapping
	com_map_one2one::Property_Map_One2one_Name_sequence& _property_one2one_list = component_it->Property_Map_One2one_Name();
	for(com_map_one2one::Property_Map_One2one_Name_iterator _property_one2one_it=_property_one2one_list.begin(); _property_one2one_it!=_property_one2one_list.end(); ++_property_one2one_it)
	{
		// retrieve property by checking its id
		map<string, SimMap::Property_Map_One2one_iterator>::iterator _property_it = property_one2one_index.find( (string)*_property_one2one_it );
		if( _property_it!=property_one2one_index.end() )
		{
			// filtering one2one property mapping data
			property_data _property;
			filter_property_map_one2one(_property_it->second, component_ptr, _property);
			// save the filtered property data
			_component.save_target_property(_property);
		}
	}
	// gap mapping
	com_map_one2one::Property_Map_Gap_Name_sequence& _property_gap_list = component_it->Property_Map_Gap_Name();
	for(com_map_one2one::Property_Map_Gap_Name_iterator _property_gap_it=_property_gap_list.begin(); _property_gap_it!=_property_gap_list.end(); ++_property_gap_it)
	{
		// retrieve property by checking its id
		map<string, SimMap::Property_Map_Gap_iterator>::iterator _property_it = property_gap_index.find( (string)*_property_gap_it );
		if( _property_it!=property_gap_index.end() )
		{
			// filtering gap property mapping data
			property_data _property;
			filter_property_map_gap(_property_it->second, _property);
			// save the filtered property data
			_component.save_target_property(_property);
		}
	}
	// combination mapping
	com_map_one2one::Property_Map_Combination_Name_sequence& _property_com_list = component_it->Property_Map_Combination_Name();
	for(com_map_one2one::Property_Map_Combination_Name_iterator _property_com_it=_property_com_list.begin(); _property_com_it!=_property_com_list.end(); ++_property_com_it)
	{
		// retrieve property by checking its id
		map<string, SimMap::Property_Map_Combination_iterator>::iterator _property_it = property_combination_index.find( (string)*_property_com_it );
		if( _property_it!=property_combination_index.end() )
		{
			// filtering combination property mapping data
			property_data _property;
			filter_property_map_combination(_property_it->second, _property);
			// save the filtered property data
			_component.save_target_property(_property);
		}
	}
	
	// ...

}

// component mapping template: many to one mapping
void map_rule_filter::filter_component_map_many2one(SimMap::Component_Map_Many2One_iterator component_it, vector<sim_base*>& component_list, component_data& _component)
{
	// make the index
	map<int, sim_base*> component_ptr_index;
	// one2one, gap, many2one, ...
}

// component mapping template: one to many mapping
void map_rule_filter::filter_component_map_one2many(SimMap::Component_Map_One2Many_iterator component_it, sim_base* component_ptr, vector<component_data>& _component_list)
{
	// retrieve the target component name
	com_map_one2many::ComponentMappingGroupName_sequence& _com_map_group_list = component_it->ComponentMappingGroupName();
	for(com_map_one2many::ComponentMappingGroupName_iterator _com_map_group_it=_com_map_group_list.begin(); _com_map_group_it!=_com_map_group_list.end(); ++_com_map_group_it)
	{
		map<string, SimMap::ComponentMappingGroup_iterator>::iterator _com_map_it = component_map_group_index.find( (string)*_com_map_group_it );
		if( _com_map_it!=component_map_group_index.end() )
		{
			component_data _component;
			// retrieve the target component name
			_component.set_target_component_name( _com_map_it->second->TargetComponentName() + QString::number(next_id).toStdString() );
			// increase the id number
			map_rule_filter::next_component_id();
			// save the unmapped simmodel component reference
			_component.save_unmapped_component(component_ptr);

			//! retrieve target component location in the Modelica lib
			if( _com_map_it->second->TargetLocation().present() )
			{
				_component.set_target_location( *_com_map_it->second->TargetLocation().get().begin() );
			}
			// retrieve properties belong to current component
			// property one2one mappings
			com_map_group::Property_Map_One2one_Name_sequence& _property_one2one_list = _com_map_it->second->Property_Map_One2one_Name();
			for(com_map_group::Property_Map_One2one_Name_iterator _property_one2one_it=_property_one2one_list.begin(); _property_one2one_it!=_property_one2one_list.end(); ++_property_one2one_it)
			{
				// retrieve property by checking its id
				map<string, SimMap::Property_Map_One2one_iterator>::iterator _property_it = property_one2one_index.find( (string)*_property_one2one_it );
				if( _property_it!=property_one2one_index.end() )
				{
					// filtering one2one property mapping data
					property_data _property;
					filter_property_map_one2one(_property_it->second, component_ptr, _property);
					// save the filtered property data
					_component.save_target_property(_property);
				}
			}
			// gap mapping
			com_map_group::Property_Map_Gap_Name_sequence& _property_gap_list = _com_map_it->second->Property_Map_Gap_Name();
			for(com_map_group::Property_Map_Gap_Name_iterator _property_gap_it=_property_gap_list.begin(); _property_gap_it!=_property_gap_list.end(); ++_property_gap_it)
			{
				// retrieve property by checking its id
				map<string, SimMap::Property_Map_Gap_iterator>::iterator _property_it = property_gap_index.find( (string)*_property_gap_it );
				if( _property_it!=property_gap_index.end() )
				{
					// filtering gap property mapping data
					property_data _property;
					filter_property_map_gap(_property_it->second, _property);
					// save the filtered property data
					_component.save_target_property(_property);
				}
			}
			// combination mapping
			com_map_group::Property_Map_Combination_Name_sequence& _property_com_list = _com_map_it->second->Property_Map_Combination_Name();
			for(com_map_group::Property_Map_Combination_Name_iterator _property_com_it=_property_com_list.begin(); _property_com_it!=_property_com_list.end(); ++_property_com_it)
			{
				// retrieve property by checking its id
				map<string, SimMap::Property_Map_Combination_iterator>::iterator _property_it = property_combination_index.find( (string)*_property_com_it );
				if( _property_it!=property_combination_index.end() )
				{
					// filtering combination property mapping data
					property_data _property;
					filter_property_map_combination(_property_it->second, _property);
					// save the filtered property data
					_component.save_target_property(_property);
				}
			}
			// ...

			// save target component data
			_component_list.push_back(_component);
		}
	}
}

// component mapping template: Gap
void map_rule_filter::filter_component_map_gap(SimMap::Component_Map_Gap_iterator component_it, component_data& _component)
{
	// retrieve the target component name
	_component.set_target_component_name( component_it->TargetComponentName() + QString::number(next_id).toStdString() );
	// increase the id number
	map_rule_filter::next_component_id();
	//! retrieve target component location in the Modelica lib
	if( component_it->TargetLocation().present() )
	{
		_component.set_target_location( *component_it->TargetLocation().get().begin() );
	}
	// retrieve properties belong to current component
	// gap mapping
	com_map_gap::Property_Map_Gap_Name_sequence& _property_gap_list = component_it->Property_Map_Gap_Name();
	for(com_map_gap::Property_Map_Gap_Name_iterator _property_gap_it=_property_gap_list.begin(); _property_gap_it!=_property_gap_list.end(); ++_property_gap_it)
	{
		// retrieve property by checking its id
		map<string, SimMap::Property_Map_Gap_iterator>::iterator _property_it = property_gap_index.find( (string)*_property_gap_it );
		if( _property_it!=property_gap_index.end() )
		{
			// filtering gap property mapping data
			property_data _property;
			filter_property_map_gap(_property_it->second, _property);
			// save the filtered property data
			_component.save_target_property(_property);
		}
	}
	//! combination mapping
	com_map_gap::Property_Map_Combination_Name_sequence& _property_com_list = component_it->Property_Map_Combination_Name();
	for(com_map_gap::Property_Map_Combination_Name_iterator _property_com_it=_property_com_list.begin(); _property_com_it!=_property_com_list.end(); ++_property_com_it)
	{
		// retrieve property by checking its id
		map<string, SimMap::Property_Map_Combination_iterator>::iterator _property_it = property_combination_index.find( (string)*_property_com_it );
		if( _property_it!=property_combination_index.end() )
		{
			// filtering combination property mapping data
			property_data _property;
			filter_property_map_combination(_property_it->second, _property);
			// save the filtered property data
			_component.save_target_property(_property);
		}
	}
}