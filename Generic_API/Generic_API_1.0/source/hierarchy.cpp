// Copyright (C) 2012-2015 Institute of Energy Efficient Building E3D,
// RWTH Aachen University, Germany.
//
// This program was developed for the EnEff-BIM project. In EnEff-BIM, 
// a project participating in IEA Annex 60, translators between Building 
// Information Models (BIM) and Modelica are developed to support building
// and community energy performance simulation. This is accomplished through 
// extending existing standards for exchanging energy calculation data, and 
// through data representation formats such as the Industry Foundation Classes (IFC).
//
// This program is free software; you can redistribute it and/or modify it 
// under the terms of the GNU General Public License version 2 as published 
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, simmodel2c++ gives permission to 
// link this program with the XML data binding framework generated by the 
// Code Synthesis Tools CC, and distribute linked combinations including 
// the two. You must obey the GNU General Public License version 2 in all 
// respects for all of the code used. If you modify this copy of the program, 
// you may extend this exception to your version of the program, but you are 
// not obligated to do so. If you do not wish to do so, delete this exception 
// statement from your version.
//

// include the head file
#include "hierarchy.h"

			// convert to hot water system
			sim_hotwater_system* sim_base::to_hotwater_system()
			{
				return dynamic_cast<sim_hotwater_system*>(this);
			}
			// convert to the pump of variable speed return
			sim_flwMov_pump_varSpedRet* sim_base::to_pump_varSpedRet()
			{
				return dynamic_cast<sim_flwMov_pump_varSpedRet*>(this);
			}
			// convert to hot water boiler
			sim_flwPlt_hotwater_boiler* sim_base::to_boiler_hotwater()
			{
				return dynamic_cast<sim_flwPlt_hotwater_boiler*>(this);
			}

			//1. simulation project
			//
			// constructor
			//sim_project::sim_project() {}
			// set project description
			void sim_project::set_description(string& _des)
			{
				_description = _des;
			}
			// get project description
			string sim_project::get_description()
			{
				return _description;
			}
			// set object owner history: IDREF
			void sim_project::set_object_owner_history(string& _ob_ow_his) 
			{
				_object_owner_history = _ob_ow_his;
			}

			// set child class: sim site
			void sim_project::set_sim_site(sim_site& _sim_site_mo)
			{
				sim_site_ptr = &_sim_site_mo;
			}
			// get child class: sim site
			sim_site* sim_project::get_sim_site()
			{
				return sim_site_ptr;
			}
			// set child class: sim configuration
			void sim_project::set_sim_configuration(sim_configuration& _sim_config_mo)
			{
				sim_config_ptr = &_sim_config_mo;
			}
			// get child class: sim configuration
			sim_configuration* sim_project::get_sim_configuration()
			{
				return sim_config_ptr;
			}
			// retrieve property values
			list<pair<string, string> >& sim_project::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					// insert item: description
					prop_val_maps.push_back( pair<string, string>("Description", (string)sim_project_it->Description().get()) );
					prop_val_maps.push_back( pair<string, string>("IfcName", (string)sim_project_it->IfcName().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_project_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_project_it->SimModelSubtype().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelName", (string)sim_project_it->SimModelName().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelSchema", (string)sim_project_it->SourceModelSchema().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelObjectType", (string)sim_project_it->SourceModelObjectType().get()) );
					prop_val_maps.push_back( pair<string, string>("ObjectType", (string)sim_project_it->ObjectType().get()) );					
				}

				return prop_val_maps;
			}
			// retrieve the number of gaps
			int sim_project::get_gap()
			{
				return gap_param_nr;
			}

			// generic API
			const char* sim_project::get_weather_location_city()
			{
				return sim_project_it->WeatherLocationCity().get().c_str();
			}
			// save sim site object into the children list
			void sim_project::save_sim_site(sim_site* _sim_site_obj)
			{
				sim_site_list.push_back(_sim_site_obj);
			}
			// retrieve total number of sim site objects
			int sim_project::get_sim_site_total_number()
			{
				return sim_site_list.size();
			}
			// retrieve the sim site object at position id
			sim_site* sim_project::get_sim_site(int id)
			{
				return sim_site_list.at(id);
			}

			//2.1 simulation site
			//
			// set child class: sim building
			void sim_site::set_sim_building(sim_building& _sim_building_mo)
			{
				sim_building_ptr = &_sim_building_mo;
			}
			// get child class: sim building
			sim_building* sim_site::get_sim_building()
			{
				return sim_building_ptr;
			}
			// set child class: sim group
			void sim_site::set_sim_group(sim_group& _sim_group_mo)
			{
				sim_group_ptr = &_sim_group_mo;
			}
			// get child class: sim group
			sim_group* sim_site::get_sim_group()
			{
				return sim_group_ptr;
			}
			// save building location template
			void sim_site::set_sim_loc(SimModel::SimTemplateLocation_Location_Default_iterator& _loc_it)
			{
				sim_loc_it = _loc_it;
			}
			// save weather summer day template
			void sim_site::set_sim_weather_sum(SimModel::SimLocationAndWeather_DesignDay_Default_iterator& _weather_sum_it)
			{
				sim_weather_sum_it = _weather_sum_it;
			}
			// get weather summer day template
			SimModel::SimLocationAndWeather_DesignDay_Default_iterator& sim_site::get_sim_weather_sum()
			{
				return sim_weather_sum_it;
			}
			// save the component id and its class instance pointer
			void sim_site::save_id(map<string, sim_base*>& _id_map)
			{
				// save the component id and instance pointer
				_id_map.insert(pair<string, sim_base*>((string)sim_site_it->RefId(), this));
			}
			// retrieve property values
			list<pair<string, string> >& sim_site::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					// insert item: description
					prop_val_maps.push_back( pair<string, string>("IfcName", (string)sim_site_it->IfcName().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_site_it->SimModelType().get()) );							
					prop_val_maps.push_back( pair<string, string>("SimModelName", (string)sim_site_it->SimModelName().get()) );
					// barometric pressure
					stringstream ss(stringstream::in | stringstream::out);
					ss << sim_weather_sum_it->SimLocationAndWeather_BaromPres().get();
					prop_val_maps.push_back( pair<string, string>("Default ambient pressure [bar]", ss.str()) );
					// quantity of the parameters
					gap_param_nr = prop_val_maps.size();
					// add Gap parameters: not defined in current SimModel schema
					prop_val_maps.push_back( pair<string, string>("Default ambient temp [degC]", "19.9999938965") );
					prop_val_maps.push_back( pair<string, string>("Gravity [m/s2]", "9.81000041962") );
					prop_val_maps.push_back( pair<string, string>("Dynamic viscosity [Pa.s]", "0.0010000000475") );
					prop_val_maps.push_back( pair<string, string>("Density of the fluid [kg/m3]", "995.585998535") );
					prop_val_maps.push_back( pair<string, string>("Specific heat capacity of fluid [J/(kg.K)]", "4184") );
					prop_val_maps.push_back( pair<string, string>("Thermal conductivity of fluid [W/(m.K)]", "0.600000023842") );
					prop_val_maps.push_back( pair<string, string>("Reference temp by zero enthalpy [degC]", "-0.00000610351560226") );
					prop_val_maps.push_back( pair<string, string>("Initial temp [degC]", "29.9999938965") );
					prop_val_maps.push_back( pair<string, string>("Calculate m_flow from p", "true") );
					// quantity of the Gap params
					gap_param_nr = prop_val_maps.size() - gap_param_nr;
				}

				return prop_val_maps;
			}
			// save the modified propety values
			void sim_site::save_prop_val(list<pair<string, string> >::iterator& _prop_it)
			{
				if(_prop_it->first=="Default ambient temp [degC]")
					_T_ambient = QString::fromStdString(_prop_it->second).toDouble() + _zero_deg; // convert the value to kelvin
				else if(_prop_it->first=="Gravity [m/s2]")
					_g = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Dynamic viscosity [Pa.s]")
					_mu_Water = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Density of the fluid [kg/m3]")
					_rho_Water = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Specific heat capacity of fluid [J/(kg.K)]")
					_cp_Water = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Thermal conductivity of fluid [W/(m.K)]")
					_lambda_Water = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Reference temp by zero enthalpy [degC]")
					_T_ref = QString::fromStdString(_prop_it->second).toDouble() + _zero_deg;
				else if(_prop_it->first=="Initial temp [degC]")
					_T0 = QString::fromStdString(_prop_it->second).toDouble() + _zero_deg;
				else if(_prop_it->first=="Calculate m_flow from p")
					_calcMFlow = (_prop_it->second=="true") ? true : false;
			}
			// retrieve the number of gaps
			int sim_site::get_gap()
			{
				return gap_param_nr;
			}

			// generic API
			const char* sim_site::get_sim_site_name()
			{
				return sim_site_it->Name().get().c_str();
			}
			// save the child class sim_building into the childeren list
			void sim_site::save_sim_building(sim_building* _sim_building)
			{
				sim_building_list.push_back(_sim_building);
			}
			// retrieve the total number of sim_building objects
			int sim_site::get_sim_building_total_number()
			{
				return sim_building_list.size();
			}
			// retrieve the sim_building object with given id position in the children list
			sim_building* sim_site::get_sim_building(int id)
			{
				return sim_building_list.at(id);
			}

			// 2.1.1 simulation buidling
			//
			// set storey number
			void sim_building::set_storey_nb(int _nb)
			{
				storey_nb = _nb;

				// allocate storage
				sim_building_storey_vec.resize(storey_nb);
			}
			// get storey number
			int sim_building::get_storey_nb()
			{
				return storey_nb;
			}
			// generic API
			// save child class sim_thermal_zone
			void sim_building::save_sim_thermal_zone(sim_thermal_zone* _sim_thermal_zone)
			{
				sim_thermal_zone_list.push_back(_sim_thermal_zone);
			}
			// retrieve the total number of sim_thermal_zone objects
			int sim_building::get_sim_thermal_zone_total_number()
			{
				return sim_thermal_zone_list.size();
			}
			// retrieve the sim_thermal_zone object with a given id
			sim_thermal_zone* sim_building::get_sim_thermal_zone(int id)
			{
				return sim_thermal_zone_list.at(id);
			}
			// save child: sim system class
			void sim_building::save_sim_system(sim_base* _sim_base)
			{
				sim_system_list.push_back(_sim_base);
			}
			// retrieve the total number of sim systems
			int sim_building::get_sim_system_total_number()
			{
				return sim_system_list.size();
			}
			// retrieve the hot water system object
			sim_base* sim_building::get_sim_system(int id)
			{
				return sim_system_list.at(id);
			}

			//  2.1.1.1 buidling stories: n+1
			//
			// set child class: space occupied
			void sim_building_storey::set_space_occupied(sim_space_occupied& _sim_space_occupied_mo)
			{
				sim_space_occupied_ptr = &_sim_space_occupied_mo;
			}
			// get child class: space occupied
			sim_space_occupied* sim_building_storey::get_space_occupied()
			{
				return sim_space_occupied_ptr;
			}
			// retrieve property values
			list<pair<string, string> >& sim_building_storey::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					prop_val_maps.push_back( pair<string, string>("Description", (string)sim_building_storey_it->Description().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_building_storey_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_building_storey_it->SimModelSubtype().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelSchema", (string)sim_building_storey_it->SourceModelSchema().get()) );

					stringstream ss(stringstream::in | stringstream::out);
					ss << sim_building_storey_it->BuildingStoryElevation().get();
					prop_val_maps.push_back( pair<string, string>("Story Elevation", ss.str()) );
					// reset string
					ss.str(std::string());
					
					ss << sim_building_storey_it->BuildingStoryGrossFloorAreaPlanned().get();
					prop_val_maps.push_back( pair<string, string>("Gross Floor Area Planned", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_building_storey_it->BuildingStoryHeight().get();
					prop_val_maps.push_back( pair<string, string>("Story Height", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_building_storey_it->BuildingStoryPerimeter().get();
					prop_val_maps.push_back( pair<string, string>("Story Perimeter", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_building_storey_it->BuildingStoryGrossFloorArea().get();
					prop_val_maps.push_back( pair<string, string>("Story Gross Floor Area", ss.str()) );
					// reset string
					ss.str(std::string());
				}

				return prop_val_maps;
			}
			// retrieve the number of gaps
			int sim_building_storey::get_gap()
			{
				return gap_param_nr;
			}
		
			//   2.1.1.1.1 space occupied
			//
			// set child class: thermal zone
			void sim_space_occupied::set_thermal_zone(sim_thermal_zone& _sim_thermal_zone_mo)
			{
				sim_thermal_zone_ptr = &_sim_thermal_zone_mo;
			}
			// get child class: thermal zone
			sim_thermal_zone* sim_space_occupied::get_thermal_zone()
			{
				return sim_thermal_zone_ptr;
			}
			// retrieve property values
			list<pair<string, string> >& sim_space_occupied::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					prop_val_maps.push_back( pair<string, string>("Description", (string)sim_space_occupied_it->Description().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_space_occupied_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelName", (string)sim_space_occupied_it->SimModelName().get()) );

					stringstream ss(stringstream::in | stringstream::out);
					ss << sim_space_occupied_it->SpaceDatumElevation().get();
					prop_val_maps.push_back( pair<string, string>("SpaceDatumElevation", ss.str()) );
					// reset string
					ss.str(std::string());

					prop_val_maps.push_back( pair<string, string>("Interior/Exterior", (string)sim_space_occupied_it->SpaceInteriorOrExterior().get()) );

					ss << sim_space_occupied_it->SpaceOccupantDensity().get();
					prop_val_maps.push_back( pair<string, string>("Space Occupant Density", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceOccupantHeatRateLatent().get();
					prop_val_maps.push_back( pair<string, string>("Space Occupant Heat Rate (Latent)", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceOccupantHeatRateSensible().get();
					prop_val_maps.push_back( pair<string, string>("Space Occupant Heat Rate (Sensible)", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceOccupantLoad().get();
					prop_val_maps.push_back( pair<string, string>("Space Occupant Load", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceEquipmentLoad().get();
					prop_val_maps.push_back( pair<string, string>("Space Equipment Load", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceLightingLoad().get();
					prop_val_maps.push_back( pair<string, string>("Space Lighting Load", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->InsideDryBulbTempHeating().get();
					prop_val_maps.push_back( pair<string, string>("Inside Dry Bulb Temp-Heating", ss.str()) );
					// reset string
					ss.str(std::string());


					ss << sim_space_occupied_it->InsideRelHumidityHeating().get();
					prop_val_maps.push_back( pair<string, string>("Inside Relative Humidity-Heating", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->InsideDryBulbTempCooling().get();
					prop_val_maps.push_back( pair<string, string>("Inside Dry Bulb Temp-Cooling", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->InsideRelHumidityCooling().get();
					prop_val_maps.push_back( pair<string, string>("Inside Relative Humidity-Cooling", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->OutsideAirPerPerson().get();
					prop_val_maps.push_back( pair<string, string>("Outside Air Per Person", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceHeight().get();
					prop_val_maps.push_back( pair<string, string>("Space Height", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceGrossPerimeter().get();
					prop_val_maps.push_back( pair<string, string>("Space Gross Perimeter", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceGrossFloorArea().get();
					prop_val_maps.push_back( pair<string, string>("Space Gross Floor Area", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceNetFloorArea().get();
					prop_val_maps.push_back( pair<string, string>("Space Net Floor Area", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceGrossVolume().get();
					prop_val_maps.push_back( pair<string, string>("Space Gross Volume", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceNetFloorAreaBOMA().get();
					prop_val_maps.push_back( pair<string, string>("Space Net Floor Area (BOMA)", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_space_occupied_it->SpaceUsableFloorAreaBOMA().get();
					prop_val_maps.push_back( pair<string, string>("Space Usable Floor Area (BOMA)", ss.str()) );
					// reset string
					ss.str(std::string());
				}

				return prop_val_maps;
			}
			// retrieve the number of gaps
			int sim_space_occupied::get_gap()
			{
				return gap_param_nr;
			}
			// 2.1.2 simulation zone & HVAC group
			//
			// retrieve property values
			list<pair<string, string> >& sim_thermal_zone::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					prop_val_maps.push_back( pair<string, string>("Description", (string)sim_thermal_zone_it->Description().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_thermal_zone_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_thermal_zone_it->SimModelSubtype().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelSchema", (string)sim_thermal_zone_it->SourceModelSchema().get()) );

					stringstream ss(stringstream::in | stringstream::out);
					ss << sim_thermal_zone_it->ZoneColorIndex().get();
					prop_val_maps.push_back( pair<string, string>("ZoneColorIndex", ss.str()) );
					// reset string
					ss.str(std::string());

					prop_val_maps.push_back( pair<string, string>("ZoneConditioningRequirement", (string)sim_thermal_zone_it->ZoneConditioningRequirement().get()) );
					prop_val_maps.push_back( pair<string, string>("PartTotalFlrArea", (string)sim_thermal_zone_it->SimSpatialZone_PartTotalFlrArea().get()) );
				}

				return prop_val_maps;
			}
			// retrieve the number of gaps
			int sim_thermal_zone::get_gap()
			{
				return gap_param_nr;
			}
			// set child class: sim thermal zone
			void sim_group::set_thermal_zone(sim_thermal_zone& _sim_thermal_zone_mo)
			{
				sim_thermal_zone_ptr = &_sim_thermal_zone_mo;
			}
			// get child class: sim thermal zone
			sim_thermal_zone* sim_group::get_thermal_zone()
			{
				return sim_thermal_zone_ptr;
			}

			//  2.1.2.1 simulation thermal zone


			// 2.1.3 simulation hot water system
			// set child class: sim thermal zone
			void sim_hotwater_system::set_hotwater_control(sim_hotwater_control& _sim_hotwater_control_mo)
			{
				sim_hw_ctl_ptr = &_sim_hotwater_control_mo;
			}
			// get child class: sim thermal zone
			sim_hotwater_control* sim_hotwater_system::get_hotwater_control()
			{
				return sim_hw_ctl_ptr;
			}
			// set child class: sim hot water demand
			void sim_hotwater_system::set_hotwater_demand(sim_hotwater_demand& _sim_hw_dmd_mo)
			{
				sim_hw_dmd_ptr = &_sim_hw_dmd_mo;
			}
			// get child class: sim hot water demand
			sim_hotwater_demand* sim_hotwater_system::get_hotwater_demand()
			{
				return sim_hw_dmd_ptr;
			}
			//  set child class: sim hot water supply
			void sim_hotwater_system::set_hotwater_supply(sim_hotwater_supply& _sim_hw_supy_mo)
			{
				sim_hw_supy_ptr = &_sim_hw_supy_mo;
			}
			// get child class: sim hot water supply
			sim_hotwater_supply* sim_hotwater_system::get_hotwater_supply()
			{
				return sim_hw_supy_ptr;
			}
			// retrieve property values
			list<pair<string, string> >& sim_hotwater_system::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_hotwater_system_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_hotwater_system_it->SimModelSubtype().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelName", (string)sim_hotwater_system_it->SimModelName().get()) );

					stringstream ss(stringstream::in | stringstream::out);
					ss << sim_hotwater_system_it->SimSys_MaxLoopTemp().get();
					prop_val_maps.push_back( pair<string, string>("Max Loop Temp", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_hotwater_system_it->SimSys_MinLoopTemp().get();
					prop_val_maps.push_back( pair<string, string>("Min Loop Temp", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_hotwater_system_it->SimSys_MaxLoopFlowRate().get();
					prop_val_maps.push_back( pair<string, string>("Max Loop Flow Rate", ss.str()) );
					// reset string
					ss.str(std::string());
				}

				return prop_val_maps;
			}
			// retrieve the number of gaps
			int sim_hotwater_system::get_gap()
			{
				return gap_param_nr;
			}
			// generic API
			// internal properites
			double sim_hotwater_system::get_max_loop_temp()
			{
				return sim_hotwater_system_it->SimSys_MaxLoopTemp().get();
			}

			//  2.1.3.1 sim hot water loop controler
			// set child class: sim supply water temperature control
			void sim_hotwater_control::set_supplywater_temp_control(sim_supplywater_temp_control& _sim_sw_temp_ctl_mo)
			{
				sim_sw_temp_ctl_ptr = &_sim_sw_temp_ctl_mo;
			}
			// get child class
			sim_supplywater_temp_control* sim_hotwater_control::get_supplywater_temp_control()
			{
				return sim_sw_temp_ctl_ptr;
			}

			// set child class: sim dry bulb temperature sensor
			void sim_hotwater_control::set_temp_drybulb_sensor(sim_temp_drybulb_sensor& _sim_temp_dbb_ssr_mo)
			{
				sim_temp_dbb_ssr_ptr = &_sim_temp_dbb_ssr_mo;
			}
			// get child class
			sim_temp_drybulb_sensor* sim_hotwater_control::get_temp_drybulb_sensor()
			{
				return sim_temp_dbb_ssr_ptr;
			}
			// retrieve property values
			list<pair<string, string> >& sim_hotwater_control::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					prop_val_maps.push_back( pair<string, string>("SimUniqueID", (string)sim_hw_ctl_it->SimUniqueID().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_hw_ctl_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_hw_ctl_it->SimModelSubtype().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelName", (string)sim_hw_ctl_it->SimModelName().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelSchema", (string)sim_hw_ctl_it->SourceModelSchema().get()) );
				}

				return prop_val_maps;
			}
			// retrieve the number of gaps
			int sim_hotwater_control::get_gap()
			{
				return gap_param_nr;
			}

			// 2.1.3.1.1 sim supply water temperature control
			// retrieve property values
			list<pair<string, string> >& sim_supplywater_temp_control::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_sw_temp_ctl_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_sw_temp_ctl_it->SimModelSubtype().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelObjectType", (string)sim_sw_temp_ctl_it->SourceModelObjectType().get()) );
					// parent id
					//idrefs& ids = sim_temp_dbb_ssr_it->AssignedToGroups().get();
					//*ids.begin();
					//sim_hotwater_system::sim_hotwater_system_it->SimSys_MaxLoopTemp();
					prop_val_maps.push_back( pair<string, string>("Max Loop Temp", "100") );
					prop_val_maps.push_back( pair<string, string>("Min Loop Temp", "100") );
					prop_val_maps.push_back( pair<string, string>("Max Loop Flow Temp", "Autosize") );
					prop_val_maps.push_back( pair<string, string>("Min Loop Flow Temp", "0-Default") );
				}

				return prop_val_maps;
			}
			// retrieve the number of gaps
			int sim_supplywater_temp_control::get_gap()
			{
				return gap_param_nr;
			}
			// 2.1.3.1.2 sim dry bulb temperature sensor
			//
			// retrieve property values
			list<pair<string, string> >& sim_temp_drybulb_sensor::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_temp_dbb_ssr_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_temp_dbb_ssr_it->SimModelSubtype().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelObjectType", (string)sim_temp_dbb_ssr_it->SourceModelObjectType().get()) );
					// parent id
					//idrefs& ids = sim_temp_dbb_ssr_it->AssignedToGroups().get();
					//*ids.begin();
					//sim_hotwater_system::sim_hotwater_system_it->SimSys_MaxLoopTemp();
					prop_val_maps.push_back( pair<string, string>("Max Loop Temp", "100") );
					prop_val_maps.push_back( pair<string, string>("Min Loop Temp", "100") );
					prop_val_maps.push_back( pair<string, string>("Max Loop Flow Temp", "Autosize") );
					prop_val_maps.push_back( pair<string, string>("Min Loop Flow Temp", "0-Default") );
				}

				return prop_val_maps;
			}
			// retrieve the number of gaps
			int sim_temp_drybulb_sensor::get_gap()
			{
				return gap_param_nr;
			}

			//  2.1.3.2 sim hot water demand
			// set child class: sim flow energy transfer by convective heater water
			void sim_hotwater_demand::set_flwEngyTran_convectheater_water(sim_flwEngyTran_convectheater_water& _sim_flwEngyTran_convectheater_w_mo)
			{
				sim_flwEngyTran_convectheater_w_ptr = &_sim_flwEngyTran_convectheater_w_mo;
			}

			// get child class: sim flow energy transfer by convective heater water
			sim_flwEngyTran_convectheater_water* sim_hotwater_demand::get_flwEngyTran_convectheater_water()
			{
				return sim_flwEngyTran_convectheater_w_ptr;
			}
			// retrieve property values
			list<pair<string, string> >& sim_hotwater_demand::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					// insert item: description
					prop_val_maps.push_back( pair<string, string>("SimUniqueID", (string)sim_hw_dmd_it->SimUniqueID().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_hw_dmd_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_hw_dmd_it->SimModelSubtype().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelName", (string)sim_hw_dmd_it->SimModelName().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelSchema", (string)sim_hw_dmd_it->SourceModelSchema().get()) );
				}

				return prop_val_maps;
			}
			// retrieve the number of gaps
			int sim_hotwater_demand::get_gap()
			{
				return gap_param_nr;
			}

			//   2.1.3.2.1 sim flow energy transferred by the convective heater water radiator
			//
			// save component id
			void sim_flwEngyTran_convectheater_water::save_id(set<string>& _id_set)
			{
				// save the component id
				_id_set.insert((string)sim_flwEngyTran_convectheater_w_it->RefId());
			}
			// save the component id and its class instance pointer
			void sim_flwEngyTran_convectheater_water::save_id(map<string, sim_base*>& _id_map)
			{
				// save the component id and instance pointer
				_id_map.insert(pair<string, sim_base*>((string)sim_flwEngyTran_convectheater_w_it->RefId(), this));
			}
			// retrieve property values
			list<pair<string, string> >& sim_flwEngyTran_convectheater_water::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_flwEngyTran_convectheater_w_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_flwEngyTran_convectheater_w_it->SimModelSubtype().get()) );
					
					stringstream ss(stringstream::in | stringstream::out);
					ss << std::setprecision(20) << sim_flwEngyTran_convectheater_w_it->SimFlowEnergyTrans_ConvergTol().get();
					prop_val_maps.push_back( pair<string, string>("Convergence Tolerance", ss.str()) );
					// reset string
					ss.str(std::string());
					// default
					prop_val_maps.push_back( pair<string, string>("Nominal power at nominal temp [W]", "644") ); // NominalPower
					prop_val_maps.push_back( pair<string, string>("Nominal temp T_flow [degC]", "-218.15") ); // T_flow_nom
					// quantity of the parameters
					gap_param_nr = prop_val_maps.size();
					// add Gap parameters
					prop_val_maps.push_back( pair<string, string>("Nominal temp T_return [degC]", "-228.15") ); // T_return_nom
					prop_val_maps.push_back( pair<string, string>("Nominal temp T_room [degC]", "-253.15") ); // T_room_nom
					prop_val_maps.push_back( pair<string, string>("RadiatorType.Exponent", "1.27760004997") ); // Exponent
					prop_val_maps.push_back( pair<string, string>("Water volume [l]", "4.67999982834") ); // VolumeWater
					prop_val_maps.push_back( pair<string, string>("Material mass [kg]", "22.1100006104") ); // MassSteel
					prop_val_maps.push_back( pair<string, string>("Percent of radiative heat [1]", "0.300000011921") ); // RadPercent
					prop_val_maps.push_back( pair<string, string>("Length [m]", "1.29999995232") ); // length
					prop_val_maps.push_back( pair<string, string>("Height [m]", "0.300000011921") ); // height
					prop_val_maps.push_back( pair<string, string>("Volume [m3]", "0.00467999977991") );
					prop_val_maps.push_back( pair<string, string>("Fixed value of pressure [Pa|bar]", "1") );
					// reset string
					ss.str(std::string());
					ss << _p_drop;
					prop_val_maps.push_back( pair<string, string>("Pressure drop between the two ports [Pa]", ss.str()) );
					// reset string
					ss.str(std::string());
					ss << _p_e;
					prop_val_maps.push_back( pair<string, string>("pipe roughness [m]", ss.str()) );
					// reset string
					ss.str(std::string());
					ss << _p_d;
					prop_val_maps.push_back( pair<string, string>("Diameter [m]", ss.str()) );
				   // quantity of the Gap params
				   gap_param_nr = prop_val_maps.size() - gap_param_nr;
				}

				return prop_val_maps;
			}

			// save the modified propety values
			void sim_flwEngyTran_convectheater_water::save_prop_val(list<pair<string, string> >::iterator& _prop_it)
			{
				if(_prop_it->first=="Nominal power at nominal temp [W]")
					nom_power = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Nominal temp T_flow [degC]")
					T_flow_nom = QString::fromStdString(_prop_it->second).toDouble() + _zero_deg;
				else if(_prop_it->first=="Nominal temp T_return [degC]")
					T_return_nom = QString::fromStdString(_prop_it->second).toDouble() + _zero_deg;
				else if(_prop_it->first=="Nominal temp T_room [degC]")
					T_room_nom = QString::fromStdString(_prop_it->second).toDouble() + _zero_deg;
				else if(_prop_it->first=="RadiatorType.Exponent")
					_exponent = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Water volume [l]")
					vol_water = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Material mass [kg]")
					mass_steel = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Percent of radiative heat [1]")
					rad_perct = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Length [m]")
					_length = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Height [m]")
					_height = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Fixed value of pressure [Pa|bar]")
					_boundary_p = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Pressure drop between the two ports [Pa]")
					_p_drop = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="pipe roughness [m]")
					_p_e = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Diameter [m]")
					_p_d = QString::fromStdString(_prop_it->second).toDouble();
			}

			// retrieve the number of gaps
			int sim_flwEngyTran_convectheater_water::get_gap()
			{
				return gap_param_nr;
			}

			//  2.1.3.3 sim hot water supply
			// set child class: sim flow mover for variable speed pump
			void sim_hotwater_supply::set_flwMov_pump_varSpedRet(sim_flwMov_pump_varSpedRet& _sim_flwMov_pump_varSpedRet_mo)
			{
				sim_flwMov_pump_varSpedRet_ptr = &_sim_flwMov_pump_varSpedRet_mo;
			}
			// get child class:
			sim_flwMov_pump_varSpedRet* sim_hotwater_supply::get_flwMov_pump_varSpedRet()
			{
				return sim_flwMov_pump_varSpedRet_ptr;
			}

			// set child class: sim flow plant for hot wate boiler
			void sim_hotwater_supply::set_flwPlt_hotwater_boiler(sim_flwPlt_hotwater_boiler& _sim_flwPlt_hw_boiler_mo)
			{
				sim_flwPlt_hw_boiler_ptr = &_sim_flwPlt_hw_boiler_mo;
			}
			// get child class:
			sim_flwPlt_hotwater_boiler* sim_hotwater_supply::get_flwPlt_hotwater_boiler()
			{
				return sim_flwPlt_hw_boiler_ptr;
			}
			// retrieve property values
			list<pair<string, string> >& sim_hotwater_supply::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					// insert item: description
					prop_val_maps.push_back( pair<string, string>("SimUniqueID", (string)sim_hw_supy_it->SimUniqueID().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_hw_supy_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_hw_supy_it->SimModelSubtype().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelName", (string)sim_hw_supy_it->SimModelName().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelSchema", (string)sim_hw_supy_it->SourceModelSchema().get()) );
				}

				return prop_val_maps;
			}
			// retrieve the number of gaps
			int sim_hotwater_supply::get_gap()
			{
				return gap_param_nr;
			}
			// generic API
			// save child component for the supply side
			void sim_hotwater_supply::save_water_supply_component(sim_base* _sim_base)
			{
				water_supply_component_list.push_back(_sim_base);
			}
			// retrieve the total number of water supply components
			int sim_hotwater_supply::get_water_supply_component_total_number()
			{
				return water_supply_component_list.size();
			}
			// retrieve the water supply component
			sim_base* sim_hotwater_supply::get_water_supply_component(int id)
			{
				return water_supply_component_list.at(id);
			}

			//   2.1.3.3.1 sim flow mover for variable speed pump
			//
			// save component id
			void sim_flwMov_pump_varSpedRet::save_id(set<string>& _id_set)
			{
				// save the component id
				_id_set.insert((string)sim_flwMov_pump_varSpedRet_it->RefId());
			}
			// save the component id and its class instance pointer
			void sim_flwMov_pump_varSpedRet::save_id(map<string, sim_base*>& _id_map)
			{
				// save the component id and instance pointer
				_id_map.insert(pair<string, sim_base*>((string)sim_flwMov_pump_varSpedRet_it->RefId(), this));
			}
			// retrieve property values
			list<pair<string, string> >& sim_flwMov_pump_varSpedRet::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					// insert item: description
					prop_val_maps.push_back( pair<string, string>("SimUniqueID", (string)sim_flwMov_pump_varSpedRet_it->SimUniqueID().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_flwMov_pump_varSpedRet_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_flwMov_pump_varSpedRet_it->SimModelSubtype().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelName", (string)sim_flwMov_pump_varSpedRet_it->SimModelName().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelSchema", (string)sim_flwMov_pump_varSpedRet_it->SourceModelSchema().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelObjectType", (string)sim_flwMov_pump_varSpedRet_it->SourceModelObjectType().get()) );
					prop_val_maps.push_back( pair<string, string>("Tag", (string)sim_flwMov_pump_varSpedRet_it->Tag().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceLibraryID", (string)sim_flwMov_pump_varSpedRet_it->SourceLibraryID().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceLibraryEntryName", (string)sim_flwMov_pump_varSpedRet_it->SourceLibraryEntryName().get()) );

					for(namespaces::Sim::ResourcesGeneral::SelectedPropertyGroups::stringItem_iterator sim_str_it = sim_flwMov_pump_varSpedRet_it->SelectedPropertyGroups().get().stringItem().begin(); sim_str_it != sim_flwMov_pump_varSpedRet_it->SelectedPropertyGroups().get().stringItem().end(); ++sim_str_it)
					{
						prop_val_maps.push_back( pair<string, string>("stringItem", (string)*sim_str_it) );
					}

					prop_val_maps.push_back( pair<string, string>("Name", (string)sim_flwMov_pump_varSpedRet_it->SimFlowMover_Name().get()) );

					stringstream ss(stringstream::in | stringstream::out);
					ss << sim_flwMov_pump_varSpedRet_it->SimFlowMover_MotorEff().get();
					prop_val_maps.push_back( pair<string, string>("Motor Eff", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_flwMov_pump_varSpedRet_it->SimFlowMover_MinFlowRate().get();
					prop_val_maps.push_back( pair<string, string>("Min Flow Rate", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_flwMov_pump_varSpedRet_it->SimFlowMover_RatedPumpHead().get();
					prop_val_maps.push_back( pair<string, string>("Rated Pump Head", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_flwMov_pump_varSpedRet_it->SimFlowMover_RatedFlowRate().get();
					prop_val_maps.push_back( pair<string, string>("Rated Flow Rate", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_flwMov_pump_varSpedRet_it->SimFlowMover_RatedPowerConsump().get();
					prop_val_maps.push_back( pair<string, string>("Rated Power Consump", ss.str()) );
					// flush string
					ss.str(std::string());

					ss << sim_flwMov_pump_varSpedRet_it->SimFlowMover_Coef1OfThePartLoadPerfCurve().get();
					prop_val_maps.push_back( pair<string, string>("PLR Coef1", ss.str()) );
					// flush string
					ss.str(std::string());

					ss << sim_flwMov_pump_varSpedRet_it->SimFlowMover_Coef2OfThePartLoadPerfCurve().get();
					prop_val_maps.push_back( pair<string, string>("PLR Coef2", ss.str()) );
					// flush string
					ss.str(std::string());

					ss << sim_flwMov_pump_varSpedRet_it->SimFlowMover_Coef3OfThePartLoadPerfCurve().get();
					prop_val_maps.push_back( pair<string, string>("PLR Coef3", ss.str()) );
					// flush string
					ss.str(std::string());

					ss << sim_flwMov_pump_varSpedRet_it->SimFlowMover_Coef4OfThePartLoadPerfCurve().get();
					prop_val_maps.push_back( pair<string, string>("PLR Coef4O", ss.str()) );
					// flush string
					ss.str(std::string());

					prop_val_maps.push_back( pair<string, string>("SimFlowMover_PumpContType", (string)sim_flwMov_pump_varSpedRet_it->SimFlowMover_PumpContType().get()) );
				   // quantity of the parameters
				   gap_param_nr = prop_val_maps.size();
				   // add Gap parameters
				   prop_val_maps.push_back( pair<string, string>("Volume_Flow_Rate [m3/s]", "0.0000112961579362") );
				   prop_val_maps.push_back( pair<string, string>("Pumping_Head [m]", "1") );
				   prop_val_maps.push_back( pair<string, string>("Time for one period [s]", "86400") );
				   // quantity of the Gap params
				   gap_param_nr = prop_val_maps.size() - gap_param_nr;
				}

				return prop_val_maps;
			}

			// save the modified propety values
			void sim_flwMov_pump_varSpedRet::save_prop_val(list<pair<string, string> >::iterator& _prop_it)
			{
				if(_prop_it->first=="PLR Coef1")
					c1 = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="PLR Coef2")
					c2 = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="PLR Coef3")
					c3 = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="PLR Coef4")
					c4 = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Volume_Flow_Rate [m3/s]")
					v_flow = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Pumping_Head [m]")
					p_head = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Time for one period [s]")
					_period = QString::fromStdString(_prop_it->second).toInt();
			}

			// retrieve the number of gaps
			int sim_flwMov_pump_varSpedRet::get_gap()
			{
				return gap_param_nr;
			}

			// save the time series of the pump
			void sim_flwMov_pump_varSpedRet::save_time_series(SimModel::SimTimeSeriesSchedule_Day_Hourly_iterator& _tmsrs_dayhour_it)
			{
				sim_tmsrs_dayhour_it = _tmsrs_dayhour_it;
			}

			// retrieve the time series
			SimModel::SimTimeSeriesSchedule_Day_Hourly_iterator& sim_flwMov_pump_varSpedRet::get_time_series()
			{
				return sim_tmsrs_dayhour_it;
			}

			//   2.1.3.3.2 sim flow plant for hot wate boiler
			//
			// save performance curve iterator
			void sim_flwPlt_hotwater_boiler::set_percur(SimModel::SimPerformanceCurve_Mathematical_Quadratic_iterator& _it)
			{
				sim_percur_mathQuad_it = _it;
			}

			// get performance curve iterator
			SimModel::SimPerformanceCurve_Mathematical_Quadratic_iterator& sim_flwPlt_hotwater_boiler::get_percur()
			{
				return sim_percur_mathQuad_it;
			}
			// save component id
			void sim_flwPlt_hotwater_boiler::save_id(set<string>& _id_set)
			{
				// save the component id
				_id_set.insert((string)sim_flwPlt_hw_boiler_it->RefId());
			}
			// save the component id and its class instance pointer
			void sim_flwPlt_hotwater_boiler::save_id(map<string, sim_base*>& _id_map)
			{
				// save the component id and instance pointer
				_id_map.insert(pair<string, sim_base*>((string)sim_flwPlt_hw_boiler_it->RefId(), this));
			}
			// retrieve property values
			list<pair<string, string> >& sim_flwPlt_hotwater_boiler::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_flwPlt_hw_boiler_it->SimModelType().get()) );

					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_flwPlt_hw_boiler_it->SimModelSubtype().get()) );

					prop_val_maps.push_back( pair<string, string>("SimModelName", (string)sim_flwPlt_hw_boiler_it->SimModelName().get()) );

					prop_val_maps.push_back( pair<string, string>("FuelType", (string)sim_flwPlt_hw_boiler_it->SimFlowPlant_FuelType().get()) );

					stringstream ss(stringstream::in | stringstream::out);
					
					ss << sim_flwPlt_hw_boiler_it->SimFlowPlant_NomCap().get();
					prop_val_maps.push_back( pair<string, string>("NomCap", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_flwPlt_hw_boiler_it->SimFlowPlant_NomThermalEff().get();
					prop_val_maps.push_back( pair<string, string>("NomThermalEff", ss.str()) );
					// reset string
					ss.str(std::string());
					
					ss << sim_flwPlt_hw_boiler_it->SimFlowPlant_DesignWaterOutletTemp().get();
					prop_val_maps.push_back( pair<string, string>("DesignWaterOutletTemp", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_flwPlt_hw_boiler_it->SimFlowPlant_MinPartLoadRatio().get();
					prop_val_maps.push_back( pair<string, string>("Min Part Load Ratio", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_flwPlt_hw_boiler_it->SimFlowPlant_MaxPartLoadRatio().get();
					prop_val_maps.push_back( pair<string, string>("Max Part Load Ratio", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_flwPlt_hw_boiler_it->SimFlowPlant_OptimumPartLoadRatio().get();
					prop_val_maps.push_back( pair<string, string>("Optimum Part Load Ratio", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_flwPlt_hw_boiler_it->SimFlowPlant_WaterOutletUpTempLimit().get();
					prop_val_maps.push_back( pair<string, string>("WaterOutletUpTempLimit", ss.str()) );
					// reset string
					ss.str(std::string());

					prop_val_maps.push_back( pair<string, string>("FlowMode", (string)sim_flwPlt_hw_boiler_it->SimFlowPlant_BoilerFlowMode().get()) );

					ss << sim_flwPlt_hw_boiler_it->SimFlowPlant_SizingFactor().get();
					prop_val_maps.push_back( pair<string, string>("SizingFactor", ss.str()) );
					// reset string
					ss.str(std::string());

					// default
					ss << sim_percur_mathQuad_it->SimPerfCurve_Coef1Constant().get();
					prop_val_maps.push_back( pair<string, string>("SimPerfCurve Coef1", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_percur_mathQuad_it->SimPerfCurve_Coef_2_X().get();
					prop_val_maps.push_back( pair<string, string>("SimPerfCurve Coef2", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_percur_mathQuad_it->SimPerfCurve_Coef_3_X_2().get();
					prop_val_maps.push_back( pair<string, string>("SimPerfCurve Coef3", ss.str()) );
					// reset string
					ss.str(std::string());
					
					ss << sim_flwPlt_hw_boiler_it->SimFlowPlant_NomCap().get();
					prop_val_maps.push_back( pair<string, string>("Maximum heat output at full load", ss.str()) );
					// reset string
					ss.str(std::string());

					ss << sim_flwPlt_hw_boiler_it->SimFlowPlant_DesignWaterOutletTemp().get();
					prop_val_maps.push_back( pair<string, string>("Water Outlet Temp [K]", ss.str()) );
					// reset string
					ss.str(std::string());

					// quantity of the parameters
				   gap_param_nr = prop_val_maps.size();
				   // add Gap parameters
				   prop_val_maps.push_back( pair<string, string>("Fluid volume inside the heat generation unit [m3]", "0.00999999977648") );
				   prop_val_maps.push_back( pair<string, string>("Temp inside the CV [K]", "54.9999938965") );
				   // quantity of the Gap params
				   gap_param_nr = prop_val_maps.size() - gap_param_nr;
				}

				return prop_val_maps;
			}

			// save the modified propety values
			void sim_flwPlt_hotwater_boiler::save_prop_val(list<pair<string, string> >::iterator& _prop_it)
			{
				if(_prop_it->first=="Fluid volume inside the heat generation unit [m3]")
					_vol = QString::fromStdString(_prop_it->second).toDouble();
				else if(_prop_it->first=="Temp inside the CV [K]")
					_vol_t = QString::fromStdString(_prop_it->second).toDouble();
			}

			// retrieve the number of gaps
			int sim_flwPlt_hotwater_boiler::get_gap()
			{
				return gap_param_nr;
			}

			//2.2 simulation configuration
			//
			// retrieve property values
			list<pair<string, string> >& sim_configuration::get_prop_val()
			{
				// load data into mapping container
				if(prop_val_maps.empty())
				{
					prop_val_maps.push_back( pair<string, string>("SimModelType", (string)sim_config_it->SimModelType().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelSubtype", (string)sim_config_it->SimModelSubtype().get()) );
					prop_val_maps.push_back( pair<string, string>("SimModelName", (string)sim_config_it->SimModelName().get()) );
					prop_val_maps.push_back( pair<string, string>("SourceModelSchema", (string)sim_config_it->SourceModelSchema().get()) );
					prop_val_maps.push_back( pair<string, string>("DesignAlternative", (string)sim_config_it->DesignAlternative().get()) );

					stringstream ss(stringstream::in | stringstream::out);
					ss << sim_config_it->CreationDate().get();
					prop_val_maps.push_back( pair<string, string>("CreationDate", ss.str()) );
					// reset string
					ss.str(std::string());
				}

				return prop_val_maps;
			}
			// retrieve the number of gaps
			int sim_configuration::get_gap()
			{
				return gap_param_nr;
			}