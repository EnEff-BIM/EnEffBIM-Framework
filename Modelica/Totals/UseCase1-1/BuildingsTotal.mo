within ;
package ModelicaServices
  "(version = 3.2.1, target = \"Dymola\") Models and functions used in the Modelica Standard Library requiring a tool specific implementation"

package ExternalReferences

  function loadResource
      "Return the absolute path name of a URI or local file name (in this default implementation URIs are not supported, but only local file names)"
    input String uri;
    output String fileReference;
  external "builtin" fileReference =
                                   Dymola_ResolveURI(uri);
  annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
fileReference = <b>loadResource</b>(uri);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<b>loadResource</b>(uri)</code>\" returns the
<b>absolute path name</b> of the file that is either defined by an URI or by a local
(e.g. relative) path name. With the returned file name it is possible to
access the file with function calls of the C standard library.
If the data or file is stored in a data-base,
this might require copying the resource to a temporary folder and referencing that.
</p>

<p>
The implementation of this function is tool specific, and this implementation is for Dymola.
However, at least Modelica URIs
(see \"chapter 13.2.3 External Resources\" of the Modelica Specification),
as well as absolute and relative local file path names are supported.
</p>

<h4>Example</h4>
<blockquote><pre>
  file1 = loadResource(\"modelica://Modelica/Resources/Data/Utilities/Examples_readRealParameters.txt\")
          // file1 is the absolute path name of the file
  file2 = loadResource(\"C:\\data\\readParameters.txt\")
          file2 = \"C:/data/readParameters.txt\"
</pre></blockquote>
</html>"));
  end loadResource;
end ExternalReferences;

package Machine

  final constant Real eps=1.e-15 "Biggest number such that 1.0 + eps = 1.0";

  final constant Real small=1.e-60
      "Smallest number such that small and -small are representable on the machine";

  final constant Real inf=1.e+60
      "Biggest Real number such that inf and -inf are representable on the machine";
  annotation (Documentation(info="<html>
<p>
Package in which processor specific constants are defined that are needed
by numerical algorithms. Typically these constants are not directly used,
but indirectly via the alias definition in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.
</p>
</html>"));
end Machine;
annotation (
  Protection(access=Access.hide),
  preferredView="info",
  version="3.2.1",
  versionDate="2013-01-17",
  versionBuild=1,
  uses(Modelica(version="3.2.1")),
  conversion(
    noneFromVersion="1.0",
    noneFromVersion="1.1",
    noneFromVersion="1.2"),
  Documentation(info="<html>
<p>
This package contains a set of functions and models to be used in the
Modelica Standard Library that requires a tool specific implementation.
These are:
</p>

<ul>
<li> <a href=\"modelica://ModelicaServices.Animation.Shape\">Shape</a>
     provides a 3-dim. visualization of elementary
     mechanical objects. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Animation.Surface\">Surface</a>
     provides a 3-dim. visualization of
     moveable parameterized surface. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.ExternalReferences.loadResource\">loadResource</a>
     provides a function to return the absolute path name of an URI or a local file name. It is used in
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">Modelica.Utilities.Files.loadResource</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Machine\">ModelicaServices.Machine</a>
     provides a package of machine constants. It is used in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.</li>

<li> <a href=\"modelica://ModelicaServices.Types.SolverMethod\">Types.SolverMethod</a>
     provides a string defining the integration method to solve differential equations in
     a clocked discretized continuous-time partition (see Modelica 3.3 language specification).
     It is not yet used in the Modelica Standard Library, but in the Modelica_Synchronous library
     that provides convenience blocks for the clock operators of Modelica version &ge; 3.3.</li>
</ul>

<p>
This implementation is targeted for Dymola.
</p>

<p>
<b>Licensed by DLR and Dassault Syst&egrave;mes AB under the Modelica License 2</b><br>
Copyright &copy; 2009-2013, DLR and Dassault Syst&egrave;mes AB.
</p>

<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"http://www.modelica.org/licenses/ModelicaLicense2\"> http://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>

</html>"));
end ModelicaServices;



package Buildings "Library with models for building energy and control systems"
  extends Modelica.Icons.Package;

  package BoundaryConditions "Package with models for boundary conditions"
    extends Modelica.Icons.Package;

    package SkyTemperature "Package with models to compute the sky temperature"
      extends Modelica.Icons.VariantsPackage;

      block BlackBody "Calculate black body sky temperature"
        extends Modelica.Blocks.Icons.Block;
        import Buildings.BoundaryConditions.Types.SkyTemperatureCalculation;
        parameter Buildings.BoundaryConditions.Types.SkyTemperatureCalculation calTSky=
          SkyTemperatureCalculation.TemperaturesAndSkyCover
          "Computation of black-body sky temperature"
          annotation(choicesAllMatching=true,
                     Evaluate=true);
        Modelica.Blocks.Interfaces.RealInput TDryBul(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dry bulb temperature at ground level"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput TDewPoi(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dew point temperature"
          annotation (Placement(transformation(extent={{-140,10},{-100,50}})));
        Modelica.Blocks.Interfaces.RealInput nOpa "Opaque sky cover"
          annotation (Placement(transformation(extent={{-140,-50},{-100,-10}})));
        Modelica.Blocks.Interfaces.RealOutput TBlaSky(
          final quantity="ThermodynamicTemperature",
          displayUnit="degC",
          final unit="K") "Black-body sky temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealInput radHorIR(
          unit="W/m2",
          min=0,
          nominal=100) "Horizontal infrared irradiation"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
      protected
        Modelica.SIunits.Temperature TDewPoiK "Dewpoint temperature";
        Modelica.SIunits.Emissivity epsSky "Black-body absorptivity of sky";
        Real nOpa10(min=0, max=10) "Opaque sky cover";
      algorithm
        if calTSky == Buildings.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover then
          TDewPoiK := Buildings.Utilities.Math.Functions.smoothMin(TDryBul, TDewPoi, 0.1);
          nOpa10 := 10*nOpa "Input nOpa is scaled to [0,1] instead of [0,10]";
          epsSky := (0.787 + 0.764*Modelica.Math.log(-TDewPoiK/Modelica.Constants.T_zero))*(1 + 0.0224*nOpa10 -
            0.0035*(nOpa10^2) + 0.00028*(nOpa10^3));
          TBlaSky := TDryBul*(epsSky^0.25);
        else
          TDewPoiK := 273.15;
          nOpa10   := 0.0;
          epsSky   := 0.0;
          TBlaSky  := (radHorIR/Modelica.Constants.sigma)^0.25;
        end if;
        annotation (
          defaultComponentName="TBlaSky",
          Documentation(info="<html>
<p>
This component computes the black-body sky temperature.
</p>
<p>
For <code>calTSky = 0</code>, the model uses horizontal infrared irradiation.
Otherwise, it uses dry buld temperature, dew point temperature and opaque sky cover.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code>.
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Used enumeration to set the sky temperature computation.
Fixed error in <code>if-then</code> statement that led to
a selection of the wrong branch to compute the sky temperature.
</li>
<li>
March 16, 2011, by Michael Wetter:<br/>
Added types for parameters and attributes for variables.
Removed default parameter value.
</li>
<li>
March 15, 2011, by Wangda Zuo:<br/>
Use <code>smoothMin()</code> instead of <code>min()</code>.
</li>
<li>
June 1, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{-50,44},{56,-40}},
                lineColor={0,0,255},
                textString="T"),
              Text(
                extent={{-96,84},{-66,74}},
                lineColor={0,0,127},
                textString="TDry"),
              Text(
                extent={{-90,36},{-66,24}},
                lineColor={0,0,127},
                textString="TDewPoi"),
              Text(
                extent={{-92,-74},{-62,-88}},
                lineColor={0,0,127},
                textString="radHorIR"),
              Text(
                extent={{16,-6},{54,-28}},
                lineColor={0,0,255},
                textString="bs"),
              Text(
                extent={{-88,-24},{-64,-36}},
                lineColor={0,0,127},
                textString="nOpa")}));
      end BlackBody;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to compute the black body sky temperature.
</html>"));
    end SkyTemperature;

    package SolarGeometry "Package with models to compute solar geometry"
      extends Modelica.Icons.VariantsPackage;

      block IncidenceAngle "Solar incidence angle on a tilted surface"
        extends Modelica.Blocks.Icons.Block;
      public
        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle azi "Surface azimuth";
        parameter Modelica.SIunits.Angle til "Surface tilt";

        Modelica.Blocks.Interfaces.RealOutput y(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Incidence angle" annotation (Placement(transformation(
                extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},{
                  120,10}})));
      protected
        Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Declination decAng
          "Declination angle"
          annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
        Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle
          solHouAng "Solar hour angle"
          annotation (Placement(transformation(extent={{-40,-50},{-20,-30}})));
        Buildings.BoundaryConditions.SolarGeometry.BaseClasses.IncidenceAngle incAng(
          final lat=lat,
          final azi=azi,
          final til=til) "Incidence angle"
          annotation (Placement(transformation(extent={{40,-10},{60,10}})));
      public
        WeatherData.Bus weaBus
          annotation (Placement(transformation(extent={{-110,-6},{-90,14}})));
      equation
        connect(incAng.incAng, y) annotation (Line(
            points={{61,0},{88.25,0},{88.25,1.16573e-015},{95.5,1.16573e-015},{95.5,0},
                {110,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(decAng.decAng, incAng.decAng) annotation (Line(
            points={{-19,40},{20,40},{20,5.4},{37.8,5.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solHouAng.solHouAng, incAng.solHouAng) annotation (Line(
            points={{-19,-40},{20,-40},{20,-4.8},{38,-4.8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.cloTim, decAng.nDay) annotation (Line(
            points={{-100,4},{-80,4},{-80,40},{-42,40}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.solTim, solHouAng.solTim) annotation (Line(
            points={{-100,4},{-80,4},{-80,-40},{-42,-40}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        annotation (
          defaultComponentName="incAng",
          Documentation(info="<html>
<p>
This component computes the solar incidence angle on a tilted surface.
For a definition of the parameters, see the User's Guide
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">Buildings.BoundaryConditions.UsersGuide</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 30, 2011, by Michael Wetter:<br/>
Removed <code>connect(y, y)</code> statement.
</li>
<li>
February 28, 2011, by Wangda Zuo:<br/>
Use local civil time instead of clock time.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255}), Bitmap(extent={{-90,90},{90,-92}}, fileName=
                    "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/IncidenceAngle.png")}));
      end IncidenceAngle;

      package BaseClasses
        "Package with base classes for Buildings.BoundaryConditions.SolarGeometry"
        extends Modelica.Icons.BasesPackage;

        block Declination "Declination angle"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput nDay(quantity="Time", unit="s")
            "One-based day number in seconds"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput decAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Declination angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          decAng = Modelica.Math.asin(-sin(23.45*2*Modelica.Constants.pi/360)*
            Modelica.Math.cos((nDay/86400 + 10)*2*Modelica.Constants.pi/365.25))
            "(A4.5)";
          annotation (
            defaultComponentName="decAng",
            Documentation(info="<html>
<p>
This component computes the angle between the equatorial plane and the solar beam.
</p>
</html>",         revisions="<html>
<ul>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}), Bitmap(extent={{-92,92},{92,-92}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/Declination.png")}));
        end Declination;

        block IncidenceAngle "The solar incidence angle on a tilted surface"
          extends Modelica.Blocks.Icons.Block;
        public
          parameter Modelica.SIunits.Angle lat "Latitude";
          parameter Modelica.SIunits.Angle azi(displayUnit="degree")
            "Surface azimuth. azi=-90 degree if surface outward unit normal points toward east; azi=0 if it points toward south";
          parameter Modelica.SIunits.Angle til(displayUnit="degree")
            "Surface tilt. til=90 degree for walls; til=0 for ceilings; til=180 for roof";
          Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
            "Solar hour angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Declination"
            annotation (Placement(transformation(extent={{-142,34},{-102,74}})));
          Modelica.Blocks.Interfaces.RealOutput incAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Incidence angle on a tilted surfce"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        protected
          Real dec_c=Modelica.Math.cos(decAng);
          Real dec_s=Modelica.Math.sin(decAng);
          Real sol_c=Modelica.Math.cos(solHouAng);
          Real sol_s=Modelica.Math.sin(solHouAng);
          Real lat_c=Modelica.Math.cos(lat);
          Real lat_s=Modelica.Math.sin(lat);
        equation
          incAng = Modelica.Math.acos(Modelica.Math.cos(til)*(dec_c*sol_c*lat_c + dec_s
            *lat_s) + Modelica.Math.sin(til)*(Modelica.Math.sin(azi)*dec_c*sol_s +
            Modelica.Math.cos(azi)*(dec_c*sol_c*lat_s - dec_s*lat_c)))
            "(A.4.13)";
          annotation (
            defaultComponentName="incAng",
            Documentation(info="<html>
<p>
This component computes the solar incidence angle on a tilted surface using the solar hour angle and the declination angle as input.
</p>
</html>",         revisions="<html>
<ul>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-98,60},{-56,50}},
                  lineColor={0,0,127},
                  textString="decAng"),
                Text(
                  extent={{-98,-42},{-42,-54}},
                  lineColor={0,0,127},
                  textString="solHouAng"),
                Bitmap(extent={{-90,92},{90,-94}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/IncidenceAngle.png")}));
        end IncidenceAngle;

        block SolarAzimuth "Solar azimuth"
          extends Modelica.Blocks.Icons.Block;
        public
          parameter Modelica.SIunits.Angle lat "Latitude";
          Modelica.Blocks.Interfaces.RealInput zen(quantity="Angle", unit="rad")
            "Zenith angle"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
            "Solar time" annotation (Placement(transformation(extent={{-140,-80},{-100,
                    -40}}), iconTransformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealOutput solAzi(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar Azimuth"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Decline angle"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        protected
          Real arg "cos(solAzi) after data validity check";
          Real tmp "cos(solAzi) before data validity check";
          constant Modelica.SIunits.Time day=86400 "Number of seconds in a day";
          constant Modelica.SIunits.Angle polarCircle = 1.1617
            "Latitude of polar circle (66 degree 33 min 44 sec)";
          final parameter Boolean outsidePolarCircle = lat < polarCircle and lat > -polarCircle
            "Flag, true if latitude is outside polar region";
        algorithm
          tmp :=(Modelica.Math.sin(lat)*Modelica.Math.cos(zen) - Modelica.Math.sin(
            decAng))/(Modelica.Math.cos(lat)*Modelica.Math.sin(zen));

          arg :=min(1.0, max(-1.0, tmp));

          solAzi := Modelica.Math.acos(arg); // Solar azimuth (A4.9a and b) as a positive number

          if outsidePolarCircle then
            // Outside the polar circle, the only non-differentiability is at night when the sun is set.
            // Hence, we use noEvent.
            if noEvent(solTim - integer(solTim/day)*day < 43200) then
              solAzi :=-solAzi;
            end if;
          else
            // Inside the polar circle, there is a jump at (solar-)midnight when the sun can
            // be above the horizon. Hence, we do not use noEvent(...)
            if solTim - integer(solTim/day)*day < 43200 then
              solAzi :=-solAzi;
            end if;
          end if;

          annotation (
            defaultComponentName="solAzi",
            Documentation(info="<html>
<p>
This component computes the solar azimuth angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed model to avoid an event at solar noon.
</li>
<li>
Feburary 28, 2012, by Wangda Zuo:<br/>
Add solar time convertion since it is removed from <code>solTim</code>.
</li>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-100,68},{-58,58}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{-102,-54},{-60,-64}},
                  lineColor={0,0,127},
                  textString="solTim"),
                Text(
                  extent={{-102,6},{-60,-4}},
                  lineColor={0,0,127},
                  textString="decAng"),
                Bitmap(extent={{-90,90},{90,-92}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/SolarAzimuth.png")}));
        end SolarAzimuth;

        block SolarHourAngle "Solar hour angle"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
            "Solar time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput solHouAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar hour angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          solHouAng = (solTim/3600 - 12)*2*Modelica.Constants.pi/24
            "Our unit is s instead of h in (A4.6)";
          annotation (
            defaultComponentName="solHouAng",
            Documentation(info="<html>
<p>
This component computes the solar hour angle, which is defined as the angle between the circle that passes through an observer, the north pole and the south pole,
and the circle that passes through the sun, the north and the south pole.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}), Bitmap(extent={{-92,90},{90,-90}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/SolarHourAngle.png")}));
        end SolarHourAngle;

        block ZenithAngle "Zenith angle"
          extends Modelica.Blocks.Icons.Block;
        public
          parameter Modelica.SIunits.Angle lat "Latitude";
          Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
            "Solar hour angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Declination"
            annotation (Placement(transformation(extent={{-142,34},{-102,74}}),
                iconTransformation(extent={{-140,34},{-100,74}})));
          Modelica.Blocks.Interfaces.RealOutput zen(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Zenith angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          zen =  Modelica.Math.acos(Modelica.Math.cos(lat)*Modelica.Math.cos(decAng)*
            Modelica.Math.cos(solHouAng) + Modelica.Math.sin(lat)*Modelica.Math.sin(
            decAng)) "(A4.8)";
          annotation (
            defaultComponentName="zen",
            Documentation(info="<html>
<p>
This component computes the zenith angle, which is the angle between the earth surface normal and the sun's beam.
Input are the solar hour angle and the declination angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-98,62},{-46,46}},
                  lineColor={0,0,127},
                  textString="decAng"),
                Text(
                  extent={{-98,-40},{-22,-58}},
                  lineColor={0,0,127},
                  textString="solHouAng"),
                Bitmap(extent={{-90,90},{90,-94}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/ZenithAngle.png")}));
        end ZenithAngle;

        block AltitudeAngle "Solar altitude angle"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput zen(quantity="Angle", unit="rad")
            "Zenith angle"
        annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput alt(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Altitude angle"
        annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          alt = (Modelica.Constants.pi/2) - zen;
          annotation (Icon(graphics={Bitmap(extent={{-92,92},{92,-92}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/AltitudeAngle.png")}),
            defaultComponentName="altAng", Documentation(info="<html>
<p>
This block computes the altitude angle of the sun with respect to a horizontal surface.
The altitude angle is the angle between the sun ray and the projection of the ray
on a horizontal surface.
It is the complementory angle to the zenith angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
Feb 01, 2012, by Kaustubh Phalak<br/>
First implementation.
</li>
</ul>
</html>"));
        end AltitudeAngle;

        block WallSolarAzimuth
          "Angle measured in a horizontal plane between the projection of the sun's rays and the normal to a vertical surface"
          extends Modelica.Blocks.Icons.Block;

          Modelica.Blocks.Interfaces.RealInput incAng(quantity="Angle",
                                                      unit="rad",
                                                      displayUnit="rad")
            "Solar incidence angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
        Modelica.Blocks.Interfaces.RealInput alt(quantity="Angle",
                                                 unit="rad",
                                                 displayUnit="rad")
            "Solar altitude angle (angle between sun ray and horizontal surface)"
            annotation (Placement(transformation(extent={{-140,28},{-100,68}})));
        Modelica.Blocks.Interfaces.RealOutput verAzi(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg")
            "Angle between projection of sun's rays and normal to vertical surface"
        annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        protected
          constant Modelica.SIunits.Angle delta = 1*Modelica.Constants.pi/180
            "Small angle";
          constant Modelica.SIunits.Angle ninety= Modelica.Constants.pi/2-delta
            "+89 degree";
          constant Real deltaX = 1E-4 "Small number used for smoothing";
          Real alt_c "Cosine of altitude, bounded away from zero";
          Real rat "Ratio of cosines";
        equation
          alt_c=Modelica.Math.cos(Buildings.Utilities.Math.Functions.smoothLimit(
                x=alt, l=-ninety, u=ninety, deltaX=delta));
          rat = Modelica.Math.cos(incAng)/alt_c;
          // Due to the smoothLimit, rat can be about 1E-3 greater than 1 or smaller than -1.
          // Hence, below we use another call to smoothLimit to ensure that the argument of
          // acos(.) is inside the interval [-1, 1].
          verAzi=Modelica.Math.acos(
               Buildings.Utilities.Math.Functions.smoothLimit(x=rat, l=-1+deltaX, u=1-deltaX, deltaX=deltaX/10));

          annotation (Icon(graphics={Bitmap(extent={{-92,92},{92,-92}}, fileName=
                      "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/WallSolarAzimuth.png")}),
        defaultComponentName="wallSolAzi",
        Documentation(info="<html>
<p>
This block computes the wall solar azimuth angle.
It is the angle between the projection of the sun ray on a horizontal surface
and the line perpendicular to the wall. The value of this angle varies from <i>0</i> to <i>180</i> degrees.
In the northern hemisphere at solar noon, the value of the wall solar azimuth angle is zero if the wall is facing south.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 5, 2012, by Michael Wetter:<br/>
Decreased <code>deltaX</code> from <i>1e-3</i> to <i>1e-4</i>, as
the looser tolerance gives sharp changes in
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.Examples.Overhang\">
Buildings.HeatTransfer.Windows.BaseClasses.Examples.Overhang</a>.
</li>
<li>
February 23, 2012, by Michael Wetter:<br/>
Guarded against division by zero because the altitude angle can be <i>90</i> degree
in the tropics, and hence its cosine can take on zero.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak<br/>
First implementation.
</li>
</ul>
</html>"));
        end WallSolarAzimuth;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry\">Buildings.BoundaryConditions.SolarGeometry</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to compute the solar geometry and incidence
angles on tilted surfaces.
</html>"));
    end SolarGeometry;

    package SolarIrradiation "Package with models to compute solar irradition"
      extends Modelica.Icons.VariantsPackage;

      block DiffusePerez
        "Hemispherical diffuse irradiation on a tilted surface using Perez's anisotropic sky model"
        extends
          Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.PartialSolarIrradiation;

        parameter Real rho=0.2 "Ground reflectance";
        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle azi "Surface azimuth";
        parameter Boolean outSkyCon=false
          "Output contribution of diffuse irradiation from sky";
        parameter Boolean outGroCon=false
          "Output contribution of diffuse irradiation from ground";

        Modelica.Blocks.Math.Add add
          annotation (Placement(transformation(extent={{60,-10},{80,10}})));
        Modelica.Blocks.Interfaces.RealOutput HSkyDifTil if (outSkyCon)
          "Hemispherical diffuse solar irradiation on a tilted surfce from the sky"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));
        Modelica.Blocks.Interfaces.RealOutput HGroDifTil if (outGroCon)
          "Hemispherical diffuse solar irradiation on a tilted surfce from the ground"
          annotation (Placement(transformation(extent={{100,-70},{120,-50}})));

      protected
        BaseClasses.DiffusePerez HDifTil(final til=til, final rho=rho)
          annotation (Placement(transformation(extent={{0,-21},{42,21}})));
        BaseClasses.SkyClearness skyCle
          annotation (Placement(transformation(extent={{-62,16},{-54,24}})));
        BaseClasses.BrighteningCoefficient briCoe
          annotation (Placement(transformation(extent={{-40,-34},{-32,-26}})));
        BaseClasses.RelativeAirMass relAirMas
          annotation (Placement(transformation(extent={{-80,-44},{-72,-36}})));
        BaseClasses.SkyBrightness skyBri
          annotation (Placement(transformation(extent={{-60,-54},{-52,-46}})));
        SolarGeometry.IncidenceAngle incAng(
          lat=lat,
          azi=azi,
          til=til)
          annotation (Placement(transformation(extent={{-86,-96},{-76,-86}})));

      equation
        connect(relAirMas.relAirMas, skyBri.relAirMas) annotation (Line(
            points={{-71.6,-40},{-66,-40},{-66,-48.4},{-60.8,-48.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyBri.skyBri, briCoe.skyBri) annotation (Line(
            points={{-51.6,-50},{-46,-50},{-46,-30},{-40.8,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyCle.skyCle, briCoe.skyCle) annotation (Line(
            points={{-53.6,20},{-46,20},{-46,-27.6},{-40.8,-27.6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(incAng.y, HDifTil.incAng) annotation (Line(
            points={{-75.5,-91},{-16,-91},{-16,-16},{-4.2,-16},{-4.2,-14.7}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.solZen, skyCle.zen) annotation (Line(
            points={{-100,5.55112e-16},{-86,5.55112e-16},{-86,17.6},{-62.8,17.6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.solZen, relAirMas.zen) annotation (Line(
            points={{-100,5.55112e-16},{-86,5.55112e-16},{-86,-40},{-80.8,-40}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.solZen, briCoe.zen) annotation (Line(
            points={{-100,5.55112e-16},{-86,5.55112e-16},{-86,-20},{-66,-20},{-66,-32},
                {-40.8,-32},{-40.8,-32.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.HGloHor, skyCle.HGloHor) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,22.4},{-62.8,22.4}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HDifHor, skyCle.HDifHor) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,20},{-62.8,20}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HDifHor, skyBri.HDifHor) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,-51.6},{-60.8,-51.6}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HGloHor, HDifTil.HGloHor) annotation (Line(
            points={{-100,5.55112e-16},{-70,0},{-38,0},{-38,16.8},{-4.2,16.8}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HDifHor, HDifTil.HDifHor) annotation (Line(
            points={{-100,5.55112e-16},{-38,5.55112e-16},{-38,10},{-4.2,10},{-4.2,
                10.5}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));

        connect(briCoe.F2, HDifTil.briCof2) annotation (Line(
            points={{-31.6,-31.6},{-24,-31.6},{-24,-2.1},{-4.2,-2.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(briCoe.F1, HDifTil.briCof1) annotation (Line(
            points={{-31.6,-28.4},{-28,-28.4},{-28,4.2},{-4.2,4.2}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus, incAng.weaBus) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,-90.8},{-86,-90.8}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.solZen, HDifTil.zen) annotation (Line(
            points={{-100,5.55112e-16},{-86,5.55112e-16},{-86,-58},{-20,-58},{-20,
                -8.4},{-4.2,-8.4}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(HDifTil.HSkyDifTil, add.u1) annotation (Line(
            points={{44.1,8.4},{52,8.4},{52,6},{58,6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HDifTil.HGroDifTil, add.u2) annotation (Line(
            points={{44.1,-8.4},{52,-8.4},{52,-6},{58,-6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(add.y, H) annotation (Line(
            points={{81,6.10623e-16},{90.5,6.10623e-16},{90.5,5.55112e-16},{110,
                5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(HDifTil.HSkyDifTil, HSkyDifTil) annotation (Line(
            points={{44.1,8.4},{52,8.4},{52,60},{110,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HDifTil.HGroDifTil, HGroDifTil) annotation (Line(
            points={{44.1,-8.4},{52,-8.4},{52,-60},{110,-60}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
          defaultComponentName="HDifTil",
          Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation on a tilted surface using an anisotropic
sky model proposed by Perez.
For a definition of the parameters, see the
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">User's Guide</a>.
</p>
<h4>References</h4>
<ul>
<li>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</li>
<li>
R. Perez, R. Seals, P. Ineichen, R. Stewart and D. Menicucci (1987).
<i>A New Simplified Version of the Perez Diffuse Irradiance Model for Tilted Surface</i>,
Solar Energy, 39(3): 221-231.
</li>
<li>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
June 6, 2012, by Wangda Zuo:<br/>
Added contributions from sky and ground that were separated in base class.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Changed component to get zenith angle from weather bus.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255})}));
      end DiffusePerez;

      block DirectTiltedSurface "Direct solar irradiation on a tilted surface"
        extends
          Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.PartialSolarIrradiation;

        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle azi "Surface azimuth";

        Buildings.BoundaryConditions.WeatherData.Bus weaBus
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

        Modelica.Blocks.Interfaces.RealOutput inc(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Incidence angle"
          annotation (Placement(transformation(extent={{100,-50},{120,-30}})));

      protected
        SolarGeometry.IncidenceAngle incAng(
          final azi=azi,
          final til=til,
          final lat=lat)
          annotation (Placement(transformation(extent={{-50,-30},{-30,-10}})));
        Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.DirectTiltedSurface
          HDirTil annotation (Placement(transformation(extent={{0,-20},{40,20}})));

      equation
        connect(incAng.y, HDirTil.incAng) annotation (Line(
            points={{-29,-20},{-12,-20},{-12,-12},{-4,-12}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(weaBus.HDirNor, HDirTil.HDirNor) annotation (Line(
            points={{-100,5.55112e-16},{-80,5.55112e-16},{-80,12},{-4,12}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(incAng.y, inc) annotation (Line(
            points={{-29,-20},{-20,-20},{-20,-40},{110,-40}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HDirTil.HDirTil, H) annotation (Line(
            points={{42,1.22125e-15},{72,1.22125e-15},{72,5.55112e-16},{110,
                5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(weaBus, incAng.weaBus) annotation (Line(
            points={{-100,5.55112e-16},{-80,5.55112e-16},{-80,-19.6},{-50,-19.6}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        annotation (
          defaultComponentName="HDirTil",
          Documentation(info="<html>
<p>
This component computes the direct solar irradiation on a tilted surface.
For a definition of the parameters, see the
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">User's Guide</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
December 12, 2010, by Michael Wetter:<br/>
Added incidence angle as output as this is needed for the room model.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255})}));
      end DirectTiltedSurface;

      package BaseClasses
        "Package with base classes for Buildings.BoundaryConditions.SolarIrradiation"
        extends Modelica.Icons.BasesPackage;

        block BrighteningCoefficient
          "Circumsolar and horizon brightening coefficients"
          extends Modelica.Blocks.Icons.Block;
          import H = Buildings.Utilities.Math.Functions.spliceFunction;
        public
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="degree") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput skyCle
            "Sky clearness. skyCle=1: overcast sky; skyCle=8 clear sky"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput skyBri "Sky brightness [0,1]"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput F1
            "Circumsolar brightening coefficient"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));
          Modelica.Blocks.Interfaces.RealOutput F2
            "Horizon brightening coefficient"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
        protected
          Real F11;
          Real F12;
          Real F13;
          Real F21;
          Real F22;
          Real F23;
          Real d=0.01;
          Real a1;
          Real a2;
          Real a3;
          Real a4;
          Real a5;
          Real a6;
          Real a7;
          Real a8;
          Real b1;
          Real b2;
          Real b3;
          Real b4;
          Real b5;
          Real b6;
          Real b7;
          Real b8;
        equation
          b1 = H(
            1,
            0,
            1.065 - skyCle,
            d);
          b2 = H(
            1,
            0,
            1.23 - skyCle,
            d);
          b3 = H(
            1,
            0,
            1.50 - skyCle,
            d);
          b4 = H(
            1,
            0,
            1.95 - skyCle,
            d);
          b5 = H(
            1,
            0,
            2.80 - skyCle,
            d);

          b6 = H(
            1,
            0,
            4.50 - skyCle,
            d);
          b7 = H(
            1,
            0,
            6.20 - skyCle,
            d);
          b8 = H(
            1,
            0,
            skyCle - 6.20,
            d);

          a1 = b1;
          a2 = b2 - b1;
          a3 = b3 - b2;
          a4 = b4 - b3;
          a5 = b5 - b4;
          a6 = b6 - b5;
          a7 = b7 - b6;
          a8 = b8;

          F11 = -0.0083117*a1 + 0.1299457*a2 + 0.3296958*a3 + 0.5682053*a4 + 0.8730280*
            a5 + 1.1326077*a6 + 1.0601591*a7 + 0.6777470*a8;
          F12 = 0.5877285*a1 + 0.6825954*a2 + 0.4868735*a3 + 0.1874525*a4 - 0.3920403*
            a5 - 1.2367284*a6 - 1.5999137*a7 - 0.3272588*a8;
          F13 = -0.0620636*a1 - 0.1513725*a2 - 0.2210958*a3 - 0.2951290*a4 - 0.3616149*
            a5 - 0.4118494*a6 - 0.3589221*a7 - 0.2504286*a8;
          F21 = -0.0596012*a1 - 0.0189325*a2 + 0.0554140*a3 + 0.1088631*a4 + 0.2255647*
            a5 + 0.2877813*a6 + 0.2642124*a7 + 0.1561313*a8;
          F22 = 0.0721249*a1 + 0.0659650*a2 - 0.0639588*a3 - 0.1519229*a4 - 0.4620442*
            a5 - 0.8230357*a6 - 1.1272340*a7 - 1.3765031*a8;
          F23 = -0.0220216*a1 - 0.0288748*a2 - 0.0260542*a3 - 0.0139754*a4 + 0.0012448*
            a5 + 0.0558651*a6 + 0.1310694*a7 + 0.2506212*a8;
          F1 = Buildings.Utilities.Math.Functions.smoothMax(
            0,
            F11 + F12*skyBri + F13*zen,
            0.01);
          F2 = F21 + F22*skyBri + F23*zen;
          annotation (
            defaultComponentName="briCoe",
            Documentation(info="<html>
<p>
This component computes the circumsolar and horizon brightening coefficients.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-96,72},{-52,50}},
                  lineColor={0,0,127},
                  textString="skyCle"),
                Text(
                  extent={{-96,14},{-52,-8}},
                  lineColor={0,0,127},
                  textString="skyBri"),
                Text(
                  extent={{-96,-46},{-52,-68}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{62,50},{106,28}},
                  lineColor={0,0,127},
                  textString="F1"),
                Text(
                  extent={{60,-30},{104,-52}},
                  lineColor={0,0,127},
                  textString="F2")}));
        end BrighteningCoefficient;

        block DiffusePerez
          "Hemispherical diffuse irradiation on a tilted surface with Perez's anisotropic model"
          extends Modelica.Blocks.Icons.Block;
        public
          parameter Real rho=0.2 "Ground reflectance";
          parameter Modelica.SIunits.Angle til(displayUnit="deg")
            "Surface tilt angle";
          Modelica.Blocks.Interfaces.RealInput briCof1
            "Brightening Coeffcient F1"
            annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
          Modelica.Blocks.Interfaces.RealInput briCof2
            "Brightening Coeffcient F2"
            annotation (Placement(transformation(extent={{-140,-30},{-100,10}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Diffuse horizontal solar radiation"
            annotation (Placement(transformation(extent={{-140,30},{-100,70}})));
          Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Global horizontal radiation"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="degree") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput incAng(
            quantity="Angle",
            unit="rad",
            displayUnit="degree") "Solar incidence angle on the surface"
            annotation (Placement(transformation(extent={{-140,-90},{-100,-50}})));

          Modelica.Blocks.Interfaces.RealOutput HGroDifTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Hemispherical diffuse solar irradiation on a tilted surfce from the ground"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
          Modelica.Blocks.Interfaces.RealOutput HSkyDifTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Hemispherical diffuse solar irradiation on a tilted surfce from the sky"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));
        protected
          Real a;
          Real b;
          constant Real bMin=Modelica.Math.cos(Modelica.Constants.pi*85/180)
            "Lower bound for b";
        equation
          a = Buildings.Utilities.Math.Functions.smoothMax(
            0,
            Modelica.Math.cos(incAng),
            0.01);
          b = Buildings.Utilities.Math.Functions.smoothMax(
            bMin,
            Modelica.Math.cos(zen),
            0.01);
          HSkyDifTil = HDifHor*(0.5*(1 - briCof1)*(1 + Modelica.Math.cos(til)) +
            briCof1*a/b + briCof2*Modelica.Math.sin(til));
          HGroDifTil = HGloHor*0.5*rho*(1 - Modelica.Math.cos(til));

          annotation (
            defaultComponentName="HDifTil",
            Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation on a tilted surface by using an anisotropic model proposed by Perez.
</p>
<h4>References</h4>
<ul>
<li>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</li>
<li>
R. Perez, R. Seals, P. Ineichen, R. Stewart and D. Menicucci (1987).
<i>A New Simplified Version of the Perez Diffuse Irradiance Model for Tilted Surface</i>,
Solar Energy, 39(3): 221-231.
</li>
<li>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
June 6, 2012, by Wangda Zuo:<br/>
Separated the contribution from the sky and the ground.
</li>
</ul>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-48,74},{-100,86}},
                  lineColor={0,0,127},
                  textString="HGloHor"),
                Text(
                  extent={{-50,44},{-102,56}},
                  lineColor={0,0,127},
                  textString="HDifHor"),
                Text(
                  extent={{-50,14},{-102,26}},
                  lineColor={0,0,127},
                  textString="briCof1"),
                Text(
                  extent={{-50,-16},{-102,-4}},
                  lineColor={0,0,127},
                  textString="briCof2"),
                Text(
                  extent={{-50,-46},{-102,-34}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{-52,-76},{-104,-64}},
                  lineColor={0,0,127},
                  textString="incAng")}));
        end DiffusePerez;

        block DirectTiltedSurface
          "Direct solar irradiation on a tilted surface"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput incAng(
            quantity="Angle",
            unit="rad",
            displayUnit="degree")
            "Incidence angle of the sun beam on a tilted surface"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput HDirNor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Direct normal radiation"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput HDirTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Direct solar irradiation on a tilted surfce"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        algorithm
          HDirTil := max(0, Modelica.Math.cos(incAng)*HDirNor);
          annotation (
            defaultComponentName="HDirTil",
            Documentation(info="<html>
<p>
This component computes the direct solar irradiation on a tilted surface.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-50,56},{-102,68}},
                  lineColor={0,0,127},
                  textString="HDirNor"),
                Text(
                  extent={{-54,-66},{-106,-54}},
                  lineColor={0,0,127},
                  textString="incAng")}));
        end DirectTiltedSurface;

        block RelativeAirMass "Relative air mass"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="degree") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relAirMas "Relative air mass"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        protected
          Real zenLim;
          Real zenDeg;
        equation
          zenLim = Buildings.Utilities.Math.Functions.smoothMin(
            zen,
            Modelica.Constants.pi/2,
            0.01);
          zenDeg = zenLim*180/Modelica.Constants.pi;
          relAirMas = 1/(Modelica.Math.cos(zenLim) + 0.15*(93.9 - zenDeg)^(-1.253));
          annotation (
            defaultComponentName="relAirMas",
            Documentation(info="<html>
<p>
This component computes the relative air mass for sky brightness.
</p>
<h4>References</h4>
R. Perez (1999).
<i>Fortran Function irrpz.f</i>,
Emailed by R. Perez to F.C. Winkelmann on May 21, 1999.<br/>
</html>",         revisions="<html>
<ul>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end RelativeAirMass;

        block SkyBrightness "Sky brightness"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput relAirMas "Relative Air Mass"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal diffuse solar radiation"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealOutput skyBri "Sky Brightness"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          skyBri = Buildings.Utilities.Math.Functions.smoothMin(
            HDifHor*relAirMas/1367,
            1,
            0.025);
          annotation (
            defaultComponentName="skyBri",
            Documentation(info="<html>
<p>
This component computes the sky brightness.
</p>
<h4>References</h4>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</html>",         revisions="<html>
<ul>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-44,36},{-96,48}},
                  lineColor={0,0,127},
                  textString="relAirMas"),
                Text(
                  extent={{-44,-46},{-96,-34}},
                  lineColor={0,0,127},
                  textString="HDifHor")}));
        end SkyBrightness;

        block SkyClearness "Sky clearness"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="degreeC") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal diffuse solar radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal global solar radiation"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput skyCle
            "Sky clearness. skyCle=1: overast sky; skyCle=8: clear sky"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        protected
          Real tmp1;
        algorithm
          tmp1 := 5.534e-6*(zen*180/Modelica.Constants.pi)^3;

          skyCle := smooth(1, if (HGloHor < Modelica.Constants.small) then 1 else
            Buildings.Utilities.Math.Functions.smoothLimit(
            (HGloHor/Buildings.Utilities.Math.Functions.smoothMax(
              HDifHor,
              1e-4,
              1e-5) + tmp1)/(1 + tmp1),
            1,
            8,
            0.1));
          annotation (
            defaultComponentName="skyCle",
            Documentation(info="<html>
<p>
This component computes the sky clearness.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-48,-6},{-100,6}},
                  lineColor={0,0,127},
                  textString="HDifHor"),
                Text(
                  extent={{-48,54},{-100,66}},
                  lineColor={0,0,127},
                  textString="HGloHor"),
                Text(
                  extent={{-48,-66},{-100,-54}},
                  lineColor={0,0,127},
                  textString="zen")}));
        end SkyClearness;

        partial block PartialSolarIrradiation
          "Partial model that is used to compute the direct and diffuse solar irradiation"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle til(displayUnit="deg")
            "Surface tilt";
          Modelica.Blocks.Interfaces.RealOutput H(
             final quantity="RadiantEnergyFluenceRate",
             final unit="W/m2") "Radiation per unit area"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          WeatherData.Bus weaBus "Bus with weather data"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

          annotation (
            Documentation(info="<html>
<p>
This is a partial model that is used to implement the direct and diffuse irradiation.
</p>
</html>",         revisions="<html>
<ul>
<li>
Dec. 12, 2010, by Michael Wetter:<br/>
Changed output signal to avoid ambiguity in blocks that output also other
quantities such as the incidence angle.
</li>
<li>
Sep. 4, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end PartialSolarIrradiation;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation\">Buildings.BoundaryConditions.SolarIrradiation</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to compute the solar irradiation
for different sky models.
</html>"));
    end SolarIrradiation;

    package WeatherData "Weather data reader"
      extends Modelica.Icons.VariantsPackage;

      block ReaderTMY3 "Reader for TMY3 weather data"

        parameter Boolean computeWetBulbTemperature = true
          "If true, then this model computes the wet bulb temperature"
          annotation(Evaluate=true);
        //--------------------------------------------------------------
        // Atmospheric pressure
        parameter Buildings.BoundaryConditions.Types.DataSource pAtmSou=Buildings.BoundaryConditions.Types.DataSource.Parameter
          "Atmospheric pressure"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Pressure pAtm=101325
          "Atmospheric pressure (used if pAtmSou=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput pAtm_in(
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="Pa") if (pAtmSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input pressure"
          annotation (Placement(transformation(extent={{-240,254},{-200,294}}),
              iconTransformation(extent={{-240,254},{-200,294}})));
        //--------------------------------------------------------------
        // Ceiling height
        parameter Buildings.BoundaryConditions.Types.DataSource ceiHeiSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Ceiling height" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real ceiHei(
          final quantity="Height",
          final unit="m",
          displayUnit="m") = 20000 "Ceiling height (used if ceiHei=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput ceiHei_in(
          final quantity="Height",
          final unit="m",
          displayUnit="m") if (ceiHeiSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input ceiling height"
          annotation (Placement(transformation(extent={{-242,24},{-202,64}}),
              iconTransformation(extent={{-242,24},{-202,64}})));
        //--------------------------------------------------------------
        // Total sky cover
        parameter Buildings.BoundaryConditions.Types.DataSource totSkyCovSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Total sky cover" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real totSkyCov(
          min=0,
          max=1,
          unit="1") = 0.5
          "Total sky cover (used if totSkyCov=Parameter). Use 0 <= totSkyCov <= 1"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput totSkyCov_in(
          min=0,
          max=1,
          unit="1") if (totSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input total sky cover"
          annotation (Placement(transformation(extent={{-240,-20},{-200,20}}),
              iconTransformation(extent={{-240,-20},{-200,20}})));
        // Opaque sky cover
        parameter Buildings.BoundaryConditions.Types.DataSource opaSkyCovSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Opaque sky cover" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real opaSkyCov(
          min=0,
          max=1,
          unit="1") = 0.5
          "Opaque sky cover (used if opaSkyCov=Parameter). Use 0 <= opaSkyCov <= 1"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput opaSkyCov_in(
          min=0,
          max=1,
          unit="1") if (opaSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input opaque sky cover"
          annotation (Placement(transformation(extent={{-240,70},{-200,110}}),
              iconTransformation(extent={{-240,70},{-200,110}})));
        //--------------------------------------------------------------
        // Dry bulb temperature
        parameter Buildings.BoundaryConditions.Types.DataSource TDryBulSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Dry bulb temperature"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Temperature TDryBul(displayUnit="degC") = 293.15
          "Dry bulb temperature (used if TDryBul=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput TDryBul_in(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") if (TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input dry bulb temperature"
          annotation (Placement(transformation(extent={{-240,160},{-200,200}})));
        //--------------------------------------------------------------
        // Dew point temperature
        parameter Buildings.BoundaryConditions.Types.DataSource TDewPoiSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Dew point temperature"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Temperature TDewPoi(displayUnit="degC") = 283.15
          "Dew point temperature (used if TDewPoi=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput TDewPoi_in(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") if (TDewPoiSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input dew point temperature"
          annotation (Placement(transformation(extent={{-240,204},{-200,244}})));
        //--------------------------------------------------------------
        // Relative humidity
        parameter Buildings.BoundaryConditions.Types.DataSource relHumSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Relative humidity" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real relHum(
          min=0,
          max=1,
          unit="1") = 0.5 "Relative humidity (used if relHum=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput relHum_in(
          min=0,
          max=1,
          unit="1") if (relHumSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input relative humidity"
          annotation (Placement(transformation(extent={{-240,118},{-200,158}}),
              iconTransformation(extent={{-240,118},{-200,158}})));
        //--------------------------------------------------------------
        // Wind speed
        parameter Buildings.BoundaryConditions.Types.DataSource winSpeSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Wind speed" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Velocity winSpe(min=0) = 1
          "Wind speed (used if winSpe=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput winSpe_in(
          final quantity="Velocity",
          final unit="m/s",
          min=0) if (winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input wind speed"
          annotation (Placement(transformation(extent={{-240,-60},{-200,-20}}),
              iconTransformation(extent={{-240,-60},{-200,-20}})));
        //--------------------------------------------------------------
        // Wind direction
        parameter Buildings.BoundaryConditions.Types.DataSource winDirSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Wind direction" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Angle winDir=1.0
          "Wind direction (used if winDir=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput winDir_in(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") if (winDirSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input wind direction"
          annotation (Placement(transformation(extent={{-240,-102},{-200,-62}}),
              iconTransformation(extent={{-240,-102},{-200,-62}})));
        //--------------------------------------------------------------
        // Infrared horizontal radiation
        parameter Buildings.BoundaryConditions.Types.DataSource HInfHorSou=Buildings.BoundaryConditions.Types.DataSource.File
          "Infrared horizontal radiation" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.HeatFlux HInfHor=0.0
          "Infrared horizontal radiation (used if HInfHorSou=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput HInfHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HInfHorSou == Buildings.BoundaryConditions.Types.DataSource.Input)
          "Input infrared horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-146},{-200,-106}}),
              iconTransformation(extent={{-240,-146},{-200,-106}})));

         parameter Buildings.BoundaryConditions.Types.RadiationDataSource HSou=Buildings.BoundaryConditions.Types.RadiationDataSource.File
          "Global, diffuse, and direct normal radiation"
           annotation (Evaluate=true, Dialog(group="Data source"));
        //--------------------------------------------------------------
        // Global horizontal radiation
        Modelica.Blocks.Interfaces.RealInput HGloHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
          "Input global horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-192},{-200,-152}}),
              iconTransformation(extent={{-240,-192},{-200,-152}})));
        //--------------------------------------------------------------
        // Diffuse horizontal radiation
        Modelica.Blocks.Interfaces.RealInput HDifHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor)
          "Input diffuse horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-238},{-200,-198}}),
              iconTransformation(extent={{-240,-172},{-200,-132}})));
        //--------------------------------------------------------------
        // Direct normal radiation
        Modelica.Blocks.Interfaces.RealInput HDirNor_in(final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") if
                                (HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
          "Input direct normal radiation"
          annotation (Placement(transformation(extent={{-240,-282},{-200,-242}}),
              iconTransformation(extent={{-240,-220},{-200,-180}})));

        parameter String filNam="" "Name of weather data file" annotation (Dialog(
              __Dymola_loadSelector(filter="Weather files (*.mos)", caption=
                  "Select weather file")));
        final parameter Modelica.SIunits.Angle lon(displayUnit="deg")=
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getLongitudeTMY3(
          filNam) "Longitude";
        final parameter Modelica.SIunits.Angle lat(displayUnit="deg")=
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getLatitudeTMY3(
          filNam) "Latitude";
        final parameter Modelica.SIunits.Time timZon(displayUnit="h")=
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getTimeZoneTMY3(filNam)
          "Time zone";
        Bus weaBus "Weather Data Bus" annotation (Placement(transformation(extent={{
                  294,-10},{314,10}}), iconTransformation(extent={{190,-10},{210,10}})));

        parameter Buildings.BoundaryConditions.Types.SkyTemperatureCalculation
          calTSky=Buildings.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover
          "Computation of black-body sky temperature" annotation (
          choicesAllMatching=true,
          Evaluate=true,
          Dialog(group="Sky temperature"));

        constant Real epsCos = 1e-6 "Small value to avoid division by 0";

      protected
        Modelica.Blocks.Tables.CombiTable1Ds datRea(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath(filNam),
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns={2,3,4,5,6,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
              28,29,30}) "Data reader"
          annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature
          cheTemDryBul "Check dry bulb temperature "
          annotation (Placement(transformation(extent={{160,-200},{180,-180}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature
          cheTemDewPoi "Check dew point temperature"
          annotation (Placement(transformation(extent={{160,-240},{180,-220}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.ConvertRelativeHumidity
          conRelHum "Convert the relative humidity from percentage to [0, 1] "
          annotation (Placement(transformation(extent={{120,20},{140,40}})));
        BaseClasses.CheckPressure chePre "Check the air pressure"
          annotation (Placement(transformation(extent={{160,60},{180,80}})));
        BaseClasses.CheckSkyCover cheTotSkyCov "Check the total sky cover"
          annotation (Placement(transformation(extent={{160,-40},{180,-20}})));
        BaseClasses.CheckSkyCover cheOpaSkyCov "Check the opaque sky cover"
          annotation (Placement(transformation(extent={{162,-160},{182,-140}})));
        BaseClasses.CheckRadiation cheGloHorRad
          "Check the global horizontal radiation"
          annotation (Placement(transformation(extent={{160,160},{180,180}})));
        BaseClasses.CheckRadiation cheDifHorRad
          "Check the diffuse horizontal radiation"
          annotation (Placement(transformation(extent={{160,120},{180,140}})));
        BaseClasses.CheckRadiation cheDirNorRad
          "Check the direct normal radiation"
          annotation (Placement(transformation(extent={{160,200},{180,220}})));
        BaseClasses.CheckCeilingHeight cheCeiHei "Check the ceiling height"
          annotation (Placement(transformation(extent={{160,-120},{180,-100}})));
        BaseClasses.CheckWindSpeed cheWinSpe "Check the wind speed"
          annotation (Placement(transformation(extent={{160,-80},{180,-60}})));
        BaseClasses.CheckRadiation cheHorRad "Check the horizontal radiation"
          annotation (Placement(transformation(extent={{160,240},{180,260}})));
        BaseClasses.CheckWindDirection cheWinDir "Check the wind direction"
          annotation (Placement(transformation(extent={{160,-280},{180,-260}})));
        SkyTemperature.BlackBody TBlaSky(final calTSky=calTSky)
          "Check the sky black-body temperature"
          annotation (Placement(transformation(extent={{240,-220},{260,-200}})));
        Utilities.SimulationTime simTim "Simulation time"
          annotation (Placement(transformation(extent={{-180,-10},{-160,10}})));
        Modelica.Blocks.Math.Add add
          "Add 30 minutes to time to shift weather data reader"
          annotation (Placement(transformation(extent={{-140,160},{-120,180}})));
        Modelica.Blocks.Sources.Constant con30mins(final k=1800)
          "Constant used to shift weather data reader"
          annotation (Placement(transformation(extent={{-180,192},{-160,212}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LocalCivilTime locTim(
            final lon=lon, final timZon=timZon) "Local civil time"
          annotation (Placement(transformation(extent={{-120,-160},{-100,-140}})));
        Modelica.Blocks.Tables.CombiTable1Ds datRea1(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath(filNam),
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns=8:11) "Data reader"
          annotation (Placement(transformation(extent={{-80,160},{-60,180}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim1
          "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-110,160},{-90,180}})));
        BaseClasses.ConvertTime conTim
          "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-120,-40},{-100,-20}})));
        BaseClasses.EquationOfTime eqnTim "Equation of time"
          annotation (Placement(transformation(extent={{-120,-120},{-100,-100}})));
        BaseClasses.SolarTime solTim "Solar time"
          annotation (Placement(transformation(extent={{-80,-140},{-60,-120}})));
        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput pAtm_in_internal(
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="bar") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput ceiHei_in_internal(
          final quantity="Height",
          final unit="m",
          displayUnit="m") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput totSkyCov_in_internal(
          final quantity="1",
          min=0,
          max=1) "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput opaSkyCov_in_internal(
          final quantity="1",
          min=0,
          max=1) "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput TDryBul_in_internal(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput TDewPoi_in_internal(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput relHum_in_internal(
          final quantity="1",
          min=0,
          max=1) "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput winSpe_in_internal(
          final quantity="Velocity",
          final unit="m/s") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput winDir_in_internal(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HGloHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HDifHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HDirNor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HInfHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";

        Modelica.Blocks.Math.UnitConversions.From_deg conWinDir
          "Convert the wind direction unit from [deg] to [rad]"
          annotation (Placement(transformation(extent={{120,-280},{140,-260}})));
        Modelica.Blocks.Math.UnitConversions.From_degC conTDryBul
          annotation (Placement(transformation(extent={{120,-200},{140,-180}})));
        BaseClasses.ConvertRadiation conHorRad
          annotation (Placement(transformation(extent={{120,240},{140,260}})));
        Modelica.Blocks.Math.UnitConversions.From_degC conTDewPoi
          "Convert the dew point temperature form [degC] to [K]"
          annotation (Placement(transformation(extent={{120,-240},{140,-220}})));
        BaseClasses.ConvertRadiation conDirNorRad
          annotation (Placement(transformation(extent={{120,200},{140,220}})));
        BaseClasses.ConvertRadiation conGloHorRad
          annotation (Placement(transformation(extent={{120,160},{140,180}})));
        BaseClasses.ConvertRadiation conDifHorRad
          annotation (Placement(transformation(extent={{120,120},{140,140}})));
        BaseClasses.CheckRelativeHumidity cheRelHum
          annotation (Placement(transformation(extent={{160,20},{180,40}})));
        SolarGeometry.BaseClasses.AltitudeAngle altAng "Solar altitude angle"
          annotation (Placement(transformation(extent={{-30,-280},{-10,-260}})));
         SolarGeometry.BaseClasses.ZenithAngle zenAng(
           final lat = lat) "Zenith angle"
          annotation (Placement(transformation(extent={{-80,-226},{-60,-206}})));
         SolarGeometry.BaseClasses.Declination decAng "Declination angle"
          annotation (Placement(transformation(extent={{-140,-220},{-120,-200}})));
         SolarGeometry.BaseClasses.SolarHourAngle
          solHouAng
          annotation (Placement(transformation(extent={{-140,-250},{-120,-230}})));
        Modelica.Blocks.Sources.Constant latitude(final k=lat) "Latitude"
          annotation (Placement(transformation(extent={{-180,-280},{-160,-260}})));
        Modelica.Blocks.Sources.Constant longitude(final k=lon) "Longitude"
          annotation (Placement(transformation(extent={{-140,-280},{-120,-260}})));

        //---------------------------------------------------------------------------
        // Optional instanciation of a block that computes the wet bulb temperature.
        // This block may be needed for evaporative cooling towers.
        // By default, it is enabled. This introduces a nonlinear equation, but
        // we have not observed an increase in computing time because of this equation.
        Buildings.Utilities.Psychrometrics.TWetBul_TDryBulPhi tWetBul_TDryBulXi(
            redeclare package Medium = Buildings.Media.PerfectGases.MoistAir,
            TDryBul(displayUnit="degC")) if computeWetBulbTemperature
          annotation (Placement(transformation(extent={{244,-66},{264,-46}})));

        //---------------------------------------------------------------------------
        // Conversion blocks for sky cover
        Modelica.Blocks.Math.Gain conTotSkyCov(final k=0.1) if
             totSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.File
          "Convert sky cover from [0...10] to [0...1]"
          annotation (Placement(transformation(extent={{120,-40},{140,-20}})));
        Modelica.Blocks.Math.Gain conOpaSkyCov(final k=0.1) if
             opaSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.File
          "Convert sky cover from [0...10] to [0...1]"
          annotation (Placement(transformation(extent={{120,-158},{140,-138}})));
      equation
        //---------------------------------------------------------------------------
        // Select atmospheric pressure connector
        if pAtmSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          pAtm_in_internal = pAtm;
        elseif pAtmSou == Buildings.BoundaryConditions.Types.DataSource.File then
          connect(datRea.y[4], pAtm_in_internal);
        else
          connect(pAtm_in, pAtm_in_internal);
        end if;
        connect(pAtm_in_internal, chePre.PIn);
        //---------------------------------------------------------------------------
        // Select ceiling height connector
        if ceiHeiSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          ceiHei_in_internal = ceiHei;
        elseif ceiHeiSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(ceiHei_in, ceiHei_in_internal);
        else
          connect(datRea.y[16], ceiHei_in_internal);
        end if;
         connect(ceiHei_in_internal, cheCeiHei.ceiHeiIn);

        //---------------------------------------------------------------------------
        // Select total sky cover connector
        if totSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          totSkyCov_in_internal = totSkyCov;
        elseif totSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(totSkyCov_in, totSkyCov_in_internal);
        else
          connect(conTotSkyCov.u, datRea.y[13]) annotation (Line(
            points={{118,-30},{-59,-30}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(conTotSkyCov.y, totSkyCov_in_internal);
        end if;
        connect(totSkyCov_in_internal, cheTotSkyCov.nIn);
        //---------------------------------------------------------------------------
        // Select opaque sky cover connector
        if opaSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          opaSkyCov_in_internal = opaSkyCov;
        elseif opaSkyCovSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(opaSkyCov_in, opaSkyCov_in_internal);
        else
          connect(conOpaSkyCov.u, datRea.y[14]) annotation (Line(
            points={{118,-148},{30,-148},{30,-29.92},{-59,-29.92}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(conOpaSkyCov.y, opaSkyCov_in_internal);
        end if;
        connect(opaSkyCov_in_internal, cheOpaSkyCov.nIn);

        //---------------------------------------------------------------------------
        // Select dew point temperature connector
        if TDewPoiSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          TDewPoi_in_internal = TDewPoi;
        elseif TDewPoiSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(TDewPoi_in, TDewPoi_in_internal);
        else
          connect(conTDewPoi.y, TDewPoi_in_internal);
        end if;
        connect(TDewPoi_in_internal, cheTemDewPoi.TIn);
        //---------------------------------------------------------------------------
        // Select dry bulb temperature connector
        if TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          TDryBul_in_internal = TDryBul;
        elseif TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(TDryBul_in, TDryBul_in_internal);
        else
          connect(conTDryBul.y, TDryBul_in_internal);
        end if;
        connect(TDryBul_in_internal, cheTemDryBul.TIn);
        //---------------------------------------------------------------------------
        // Select relative humidity connector
        if relHumSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          relHum_in_internal = relHum;
        elseif relHumSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(relHum_in, relHum_in_internal);
        else
          connect(conRelHum.relHumOut, relHum_in_internal);
        end if;
        connect(relHum_in_internal, cheRelHum.relHumIn);
        //---------------------------------------------------------------------------
        // Select wind speed connector
        if winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          winSpe_in_internal = winSpe;
        elseif winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(winSpe_in, winSpe_in_internal);
        else
          connect(datRea.y[12], winSpe_in_internal);
        end if;
        connect(winSpe_in_internal, cheWinSpe.winSpeIn);
        //---------------------------------------------------------------------------
        // Select wind direction connector
        if winDirSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          winDir_in_internal = winDir;
        elseif winDirSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(winDir_in, winDir_in_internal);
        else
          connect(conWinDir.y, winDir_in_internal);
        end if;
        connect(winDir_in_internal, cheWinDir.nIn);
        //---------------------------------------------------------------------------
        // Select global horizontal radiation connector
        if HSou ==  Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor then
          connect(HGloHor_in, HGloHor_in_internal)
            "Get HGloHor using user input file";
        elseif HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
           HDirNor_in_internal*cos(zenAng.zen)+HDifHor_in_internal = HGloHor_in_internal
            "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
        else
          connect(conGloHorRad.HOut, HGloHor_in_internal)
            "Get HGloHor using weather data file";
        end if;
        connect(HGloHor_in_internal, cheGloHorRad.HIn);
        //---------------------------------------------------------------------------
        // Select diffuse horizontal radiation connector
        if HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
           connect(HDifHor_in, HDifHor_in_internal)
            "Get HDifHor using user input file";
        elseif  HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor then
            HGloHor_in_internal - HDirNor_in_internal*cos(zenAng.zen) = HDifHor_in_internal
            "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
        else
          connect(conDifHorRad.HOut, HDifHor_in_internal)
            "Get HDifHor using weather data file";
        end if;
        connect(HDifHor_in_internal, cheDifHorRad.HIn);
        //---------------------------------------------------------------------------
        // Select direct normal radiation connector
        if HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
           connect(HDirNor_in, HDirNor_in_internal)
            "Get HDirNor using user input file";
        elseif  HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor then
            (HGloHor_in_internal -HDifHor_in_internal)/Buildings.Utilities.Math.Functions.smoothMax(x1=cos(zenAng.zen), x2=epsCos, deltaX=0.1*epsCos)
             = HDirNor_in_internal
            "Calculate the HDirNor using HGloHor and HDifHor according to (A.4.14) and (A.4.15)";
        else
          connect(conDirNorRad.HOut, HDirNor_in_internal)
            "Get HDirNor using weather data file";
        end if;
        connect(HDirNor_in_internal, cheDirNorRad.HIn);

        //---------------------------------------------------------------------------
        // Select infrared radiation connector
        if HInfHorSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          HInfHor_in_internal = HInfHor;
        elseif HInfHorSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(HInfHor_in, HInfHor_in_internal);
        else
          connect(conHorRad.HOut, HInfHor_in_internal);
        end if;
        connect(HInfHor_in_internal, cheHorRad.HIn);

        connect(chePre.POut, weaBus.pAtm) annotation (Line(
            points={{181,70},{220,70},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheTotSkyCov.nOut, weaBus.nTot) annotation (Line(
            points={{181,-30},{220,-30},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheOpaSkyCov.nOut, weaBus.nOpa) annotation (Line(
            points={{183,-150},{220,-150},{220,5.55112e-016},{304,5.55112e-016}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheGloHorRad.HOut, weaBus.HGloHor) annotation (Line(
            points={{181,170},{220,170},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheDifHorRad.HOut, weaBus.HDifHor) annotation (Line(
            points={{181,130},{220,130},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheDirNorRad.HOut, weaBus.HDirNor) annotation (Line(
            points={{181,210},{220,210},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheCeiHei.ceiHeiOut, weaBus.celHei) annotation (Line(
            points={{181,-110},{220,-110},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheWinSpe.winSpeOut, weaBus.winSpe) annotation (Line(
            points={{181,-70},{220,-70},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheHorRad.HOut, weaBus.radHorIR) annotation (Line(
            points={{181,250},{220,250},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheWinDir.nOut, weaBus.winDir) annotation (Line(
            points={{181,-270},{280,-270},{280,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheOpaSkyCov.nOut, TBlaSky.nOpa) annotation (Line(
            points={{183,-150},{220,-150},{220,-213},{238,-213}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cheHorRad.HOut, TBlaSky.radHorIR) annotation (Line(
            points={{181,250},{220,250},{220,-218},{238,-218}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TBlaSky.TBlaSky, weaBus.TBlaSky) annotation (Line(
            points={{261,-210},{280,-210},{280,0},{292,0},{292,5.55112e-16},{304,
                5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(simTim.y, weaBus.cloTim) annotation (Line(
            points={{-159,6.10623e-16},{34.75,6.10623e-16},{34.75,0},{124.5,0},{124.5,
                5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(simTim.y, add.u2) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,164},{-142,164}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(con30mins.y, add.u1) annotation (Line(
            points={{-159,202},{-150,202},{-150,176},{-142,176}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(add.y, conTim1.simTim) annotation (Line(
            points={{-119,170},{-112,170}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conTim1.calTim, datRea1.u) annotation (Line(
            points={{-89,170},{-82,170}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(simTim.y, locTim.cloTim) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-150},{-122,-150}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(simTim.y, conTim.simTim) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-30},{-122,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conTim.calTim, datRea.u) annotation (Line(
            points={{-99,-30},{-82,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(simTim.y, eqnTim.nDay) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-110},{-122,-110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(eqnTim.eqnTim, solTim.equTim) annotation (Line(
            points={{-99,-110},{-88,-110},{-88,-124},{-82,-124}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(locTim.locTim, solTim.locTim) annotation (Line(
            points={{-99,-150},{-88,-150},{-88,-135.4},{-82,-135.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solTim.solTim, weaBus.solTim) annotation (Line(
            points={{-59,-130},{-20,-130},{-20,0},{284,0},{284,5.55112e-16},{304,
                5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(datRea.y[11], conWinDir.u) annotation (Line(
            points={{-59,-30.16},{20,-30.16},{20,-270},{118,-270}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea1.y[1], conHorRad.HIn) annotation (Line(
            points={{-59,169.25},{20,169.25},{20,250},{118,250}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cheTemDryBul.TOut, TBlaSky.TDryBul) annotation (Line(
            points={{181,-190},{220,-190},{220,-202},{238,-202}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea.y[1], conTDryBul.u) annotation (Line(
            points={{-59,-30.96},{20,-30.96},{20,-190},{118,-190}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea.y[2], conTDewPoi.u) annotation (Line(
            points={{-59,-30.88},{20,-30.88},{20,-230},{118,-230}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cheTemDewPoi.TOut, weaBus.TDewPoi) annotation (Line(
            points={{181,-230},{280,-230},{280,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(TBlaSky.TDewPoi, cheTemDewPoi.TOut) annotation (Line(
            points={{238,-207},{220,-207},{220,-230},{181,-230}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea1.y[3], conDirNorRad.HIn) annotation (Line(
            points={{-59,170.25},{20,170.25},{20,210},{118,210}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea1.y[2], conGloHorRad.HIn) annotation (Line(
            points={{-59,169.75},{30,169.75},{30,170},{118,170}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea1.y[4], conDifHorRad.HIn) annotation (Line(
            points={{-59,170.75},{20,170.75},{20,130},{118,130}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conRelHum.relHumIn, datRea.y[3]) annotation (Line(
            points={{118,30},{20,30},{20,-30.8},{-59,-30.8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cheRelHum.relHumOut, weaBus.relHum) annotation (Line(
            points={{181,30},{280,30},{280,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheTemDryBul.TOut, weaBus.TDryBul) annotation (Line(
            points={{181,-190},{280,-190},{280,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(decAng.decAng, zenAng.decAng)
                                        annotation (Line(
            points={{-119,-210},{-82,-210},{-82,-210.6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solHouAng.solHouAng, zenAng.solHouAng)                                              annotation (Line(
            points={{-119,-240},{-100,-240},{-100,-220.8},{-82,-220.8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solHouAng.solTim, solTim.solTim) annotation (Line(
            points={{-142,-240},{-154,-240},{-154,-172},{-20,-172},{-20,-130},{-59,-130}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(decAng.nDay, simTim.y) annotation (Line(
            points={{-142,-210},{-150,-210},{-150,-180},{0,-180},{0,6.10623e-16},{
                -159,6.10623e-16}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(zenAng.zen, altAng.zen) annotation (Line(
            points={{-59,-216},{-40,-216},{-40,-270},{-32,-270}},
            color={0,0,127},
            smooth=Smooth.None));

        // Connectors for wet bulb temperature.
        // These are removed if computeWetBulbTemperature = false
        connect(chePre.POut, tWetBul_TDryBulXi.p) annotation (Line(
            points={{181,70},{220,70},{220,-64},{243,-64}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(tWetBul_TDryBulXi.TWetBul, weaBus.TWetBul) annotation (Line(
            points={{265,-56},{280,-56},{280,0},{292,0},{292,5.55112e-16},{304,
                5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheTemDryBul.TOut, tWetBul_TDryBulXi.TDryBul) annotation (Line(
            points={{181,-190},{220,-190},{220,-48},{243,-48}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cheRelHum.relHumOut, tWetBul_TDryBulXi.phi) annotation (Line(
            points={{181,30},{208,30},{208,-56},{243,-56}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(altAng.alt, weaBus.solAlt) annotation (Line(
            points={{-9,-270},{8,-270},{8,-290},{290,-290},{290,0},{304,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(zenAng.zen, weaBus.solZen) annotation (Line(
            points={{-59,-216},{-40,-216},{-40,-290},{290,-290},{290,0},{304,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(decAng.decAng, weaBus.solDec) annotation (Line(
            points={{-119,-210},{-110,-210},{-110,-208},{-100,-208},{-100,-290},{290,
                -290},{290,0},{304,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solHouAng.solHouAng, weaBus.solHouAng) annotation (Line(
            points={{-119,-240},{-108,-240},{-108,-238},{-100,-238},{-100,-290},{290,
                -290},{290,0},{304,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(longitude.y, weaBus.lon) annotation (Line(
            points={{-119,-270},{-100,-270},{-100,-290},{290,-290},{290,0},{304,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(latitude.y, weaBus.lat) annotation (Line(
            points={{-159,-270},{-150,-270},{-150,-290},{290,-290},{290,0},{304,0}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
          defaultComponentName="weaDat",
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-200,-200},{200,200}},
              initialScale=0.05), graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={124,142,255},
                fillColor={124,142,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-162,270},{138,230}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                visible=(pAtmSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,216},{-164,184}},
                lineColor={0,0,127},
                textString="p"),
              Text(
                visible=(TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-194,162},{-118,118}},
                lineColor={0,0,127},
                textString="TDryBul"),
              Text(
                visible=(relHumSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,92},{-104,66}},
                lineColor={0,0,127},
                textString="relHum"),
              Text(
              visible=(winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-196,44},{-110,2}},
                lineColor={0,0,127},
                textString="winSpe"),
              Text(
                visible=(winDirSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-192,-18},{-106,-60}},
                lineColor={0,0,127},
                textString="winDir"),
              Text(
              visible=(HSou ==  Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor),
              extent={{-202,-88},{-112,-108}},
                lineColor={0,0,127},
                textString="HGloHor"),
              Text(visible=(HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
              extent={{-202,-142},{-116,-164}},
                lineColor={0,0,127},
                textString="HDifHor"),
              Text(
              visible=(HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
              extent={{-200,-186},{-126,-214}},
                lineColor={0,0,127},
                textString="HDirNor"),
              Ellipse(
                extent={{-146,154},{28,-20}},
                lineColor={255,220,220},
                lineThickness=1,
                fillPattern=FillPattern.Sphere,
                fillColor={255,255,0}),
              Polygon(
                points={{104,76},{87.9727,12.9844},{88,12},{120,22},{148,20},{174,8},
                    {192,-58},{148,-132},{20,-140},{-130,-136},{-156,-60},{-140,-6},{
                    -92,-4},{-68.2109,-21.8418},{-68,-22},{-82,40},{-48,90},{44,110},
                    {104,76}},
                lineColor={220,220,220},
                lineThickness=0.1,
                fillPattern=FillPattern.Sphere,
                smooth=Smooth.Bezier,
                fillColor={230,230,230})}),
          Documentation(info="<html>
<p>
This component reads TMY3 weather data (Wilcox and Marion, 2008) or user specified weather data.
The weather data format is the Typical Meteorological Year (TMY3)
as obtained from the EnergyPlus web site at
<a href=\"http://apps1.eere.energy.gov/buildings/energyplus/cfm/weather_data.cfm\">
http://apps1.eere.energy.gov/buildings/energyplus/cfm/weather_data.cfm</a>. These
data, which are in the EnergyPlus format, need to be converted as described
in the next paragraph.
</p>
<!-- ============================================== -->
<h4>Adding new weather data</h4>
<p>
To add new weather data, proceed as follows:
</p>
<ol>
<li>
Download the weather data file with the <code>epw</code> extension from
<a href=\"http://apps1.eere.energy.gov/buildings/energyplus/cfm/weather_data.cfm\">
http://apps1.eere.energy.gov/buildings/energyplus/cfm/weather_data.cfm</a>.
</li>
<li>
Add the file to <code>Buildings/Resources/weatherdata</code> (or to any directory
for which you have write permission).
</li>
<li>
On a console window, type<pre>
  cd Buildings/Resources/weatherdata
  java -jar ../bin/ConvertWeatherData.jar inputFile.epw
</pre>
This will generate the weather data file <code>inputFile.mos</code>, which can be read
by the model
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.ReaderTMY3\">
Buildings.BoundaryConditions.WeatherData.ReaderTMY3</a>.
</li>
</ol>
<!-- ============================================== -->
<h4>Location data that are read automatically from the weather data file</h4>
<p>
The following location data are automatically read from the weather file:
</p>
<ul>
<li>
The latitude of the weather station, <code>lat</code>,
</li>
<li>
the longitude of the weather station, <code>lon</code>, and
</li>
<li>
the time zone relative to Greenwich Mean Time, <code>timZone</code>.
</li>
</ul>
<!-- ============================================== -->
<h4>Wet bulb temperature</h4>
<p>
By default, the data bus contains the wet bulb temperature.
This introduces a nonlinear equation.
However, we have not observed an increase in computing time because
of this equation.
To disable the computation of the wet bulb temperature, set
<code>computeWetBulbTemperature=false</code>.
</p>
<!-- ============================================== -->
<h4>Using constant or user-defined input signals for weather data</h4>
<p>
This model has the option of using a constant value, using the data from the weather file,
or using data from an input connector for the following variables:
</p>
<ul>
<li>
The atmospheric pressure,
</li>
<li>
the ceiling height,
</li>
<li>
the total sky cover pressure,
</li>
<li>
the opaque sky cover pressure,
</li>
<li>
the dry bulb temperature,
</li>
<li>
the dew point temperature,
</li>
<li>
the relative humidity,
</li>
<li>
the wind direction,
</li>
<li>
the wind speed,
</li>
<li>
the global horizontal radiation, direct normal and diffuse horizontal radiation,
and
</li>
<li>
the infrared horizontal radiation.
</li>
</ul>
<p>
By default, all data are obtained from the weather data file,
except for the atmospheric pressure, which is set to the
parameter <code>pAtm=101325</code> Pascals.
</p>
<p>
The parameter <code>*Sou</code> configures the source of the data.
For the atmospheric pressure, dry bulb temperature, relative humidity, wind speed and wind direction,
the enumeration
<a href=\"modelica://Buildings.BoundaryConditions.Types.DataSource\">
Buildings.BoundaryConditions.Types.DataSource</a>
is used as follows:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>*Sou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Parameter
  </td>
  <td>
    Use value specified by the parameter.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input
  </td>
  <td>
    Use value from the input connector.
  </td>
</tr>
</table>
<p>
Because global, diffuse and direct radiation are related to each other, the parameter
<code>HSou</code> is treated differently.
It is set to a value of the enumeration
<a href=\"modelica://Buildings.BoundaryConditions.Types.RadiationDataSource\">
Buildings.BoundaryConditions.Types.RadiationDataSource</a>,
and allows the following configurations:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>HSou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input_HGloHor_HDifHor
  </td>
  <td>
    Use global horizontal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HDifHor
  </td>
  <td>
    Use direct normal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HGloHor
  </td>
  <td>
    Use direct normal and global horizontal radiation from input connector.
  </td>
</tr>
</table>
<p>
<b>Notes</b>
</p>
<ol>
<li>
<p>
In HVAC systems, when the fan is off, changes in atmospheric pressure can cause small air flow rates
in the duct system due to change in pressure and hence in the mass of air that is stored
in air volumes (such as in fluid junctions or in the room model).
This may increase computing time. Therefore, the default value for the atmospheric pressure is set to a constant.
Furthermore, if the initial pressure of air volumes are different
from the atmospheric pressure, then fast pressure transients can happen in the first few seconds of the simulation.
This can cause numerical problems for the solver. To avoid this problem, set the atmospheric pressure to the
same value as the medium default pressure, which is typically set to the parameter <code>Medium.p_default</code>.
For medium models for moist air and dry air, the default is
<code>Medium.p_default=101325</code> Pascals.
</p>
</li>
<li>
<p>
Different units apply depending on whether data are obtained from a file, or
from a parameter or an input connector:
</p>
<ul>
<li>
When using TMY3 data from a file (e.g. <code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos</code>), the units must be the same as the original TMY3 file used by EnergyPlus (e.g.
<code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.epw</code>).
The TMY3 data used by EnergyPlus are in both SI units and non-SI units.
If <code>Resources/bin/ConvertWeatherData.jar</code> is used to convert the <code>.epw</code> file to an <code>.mos</code> file, the units of the TMY3 data are preserved and the file can be directly
used by this data reader.
The data reader will automatically convert units to the SI units used by Modelica.
For example, the dry bulb temperature <code>TDryBul</code> in TMY3 is in degree Celsius.
The data reader will automatically convert the data to Kelvin.
The wind direction <code>winDir</code> in TMY3 is degrees and will be automatically converted to radians.
</li>
<li>
When using data from a parameter or from an input connector,
the data must be in the SI units used by Modelica.
For instance, the unit must be
<code>Pa</code> for pressure,
<code>K</code> for temperature,
<code>W/m2</code> for solar radiations and
<code>rad</code> for wind direction.
</li>
</ul>
</li>
<li>
The ReaderTMY3 should only be used with TMY3 data. It contains a time shift for solar radiation data
that is explained below. This time shift needs to be removed if the user may want to
use the ReaderTMY3 for other weather data types.
</li>
</ol>
<h4>Implementation</h4>
<h5>Start and end data for annual weather data files</h5>
<p>
The TMY3 weather data, as well as the EnergyPlus weather data, start at 1:00 AM
on January 1, and provide hourly data until midnight on December 31.
Thus, the first entry for temperatures, humidity, wind speed etc. are values
at 1:00 AM and not at midnight. Furthermore, the TMY3 weather data files can have
values at midnight of December 31 that may be significantly different from the values
at 1:00 AM on January 1.
Since annual simulations require weather data that start at 0:00 on January 1,
data need to be provided for this hour. Due to the possibly large change in
weatherdata between 1:00 AM on January 1 and midnight at December 31,
the weather data files in the Buildings library do not use the data entry from
midnight at December 31 as the value for <i>t=0</i>. Rather, the
value from 1:00 AM on January 1 is duplicated and used for 0:00 on January 1.
To maintain a data record with <i>8760</i> hours, the weather data record from
midnight at December 31 is deleted.
These changes in the weather data file are done in the Java program that converts
EnergyPlus weather data file to Modelica weather data files, and which is described
below.
</p>
<h5>Time shift for solar radiation data</h5>
<p>
To read weather data from the TMY3 weather data file, there are
two data readers in this model. One data reader obtains all data
except solar radiation, and the other data reader reads only the
solar radiation data, shifted by <i>30</i> minutes.
The reason for this time shift is as follows:
The TMY3 weather data file contains for solar radiation the
\"...radiation received
on a horizontal surface during
the 60-minute period ending at
the timestamp.\"

Thus, as the figure below shows, a more accurate interpolation is obtained if
time is shifted by <i>30</i> minutes prior to reading the weather data.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/BoundaryConditions/WeatherData/RadiationTimeShift.png\"
border=\"1\" />
</p>
<h4>References</h4>
<ul>
<li>
Wilcox S. and W. Marion. <i>Users Manual for TMY3 Data Sets</i>.
Technical Report, NREL/TP-581-43156, revised May 2008.
</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter<br/>
Corrected error that led the total and opaque sky cover to be ten times
too low if its value was obtained from the parameter or the input connector.
For the standard configuration in which the sky cover is obtained from
the weather data file, the model was correct. This error only affected
the other two possible configurations.
</li>
<li>
September 12, 2014, by Michael Wetter:<br/>
Removed redundant connection <code>connect(conHorRad.HOut, cheHorRad.HIn);</code>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
May 5, 2013, by Thierry S. Nouidui:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the ceiling height, the total sky cover, the opaque sky cover, the dew point temperature,
and the infrared horizontal radiation <code>HInfHor</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Improved the algorithm that determines the absolute path of the file.
Now weather files are searched in the path specified, and if not found, the urls
<code>file://</code>, <code>modelica://</code> and <code>modelica://Buildings</code>
are added in this order to search for the weather file.
This allows using the data reader without having to specify an absolute path,
as long as the <code>Buildings</code> library
is on the <code>MODELICAPATH</code>.
This change was implemented in
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
and improves this weather data reader.
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
October 16, 2012, by Michael Wetter:<br/>
Added computation of the wet bulb temperature.
Computing the wet bulb temperature introduces a nonlinear
equation. As we have not observed an increase in computing time
because of computing the wet bulb temperature, it is computed
by default. By setting the parameter
<code>computeWetBulbTemperature=false</code>, the computation of the
wet bulb temperature can be removed.
Revised documentation.
</li>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code> and
improved the optional inputs for radiation data.
</li>
<li>
July 24, 2012, by Wangda Zuo:<br/>
Corrected the notes of SI unit requirements for input files.
</li>
<li>
July 13, 2012, by Michael Wetter:<br/>
Removed assignment of <code>HGloHor_in</code> in its declaration,
because this gives an overdetermined system if the input connector
is used.
Removed non-required assignments of attribute <code>displayUnit</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Added subbus for solar position, which is needed by irradition and
shading model.
</li>
<li>
November 29, 2011, by Michael Wetter:<br/>
Fixed wrong display unit for <code>pAtm_in_internal</code> and
made propagation of parameter final.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
1. Added optional connectors for dry bulb temperature, relative humidity, wind speed, wind direction, global horizontal radiation, diffuse horizontal radiation.<br/>
2. Separate the unit convertion for TMY3 data and data validity check.
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Propagated value for sky temperature calculation to make it accessible as a parameter.
</li>
<li>
July 20, 2011, by Michael Wetter:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the atmospheric pressure.
</li><li>
March 15, 2011, by Wangda Zuo:<br/>
Delete the wet bulb temperature since it may cause numerical problem.
</li>
<li>
March 7, 2011, by Wangda Zuo:<br/>
Added wet bulb temperature. Changed reader to read only needed columns.
Added explanation for 30 minutes shift for radiation data.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
Changed implementation to obtain longitude and time zone directly
from weather file.
</li>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=false,
                                                            extent={{-200,-300},{300,
                  300}}),
              graphics));
      end ReaderTMY3;

      expandable connector Bus "Data bus that stores weather data"
        extends Modelica.Icons.SignalBus;

        annotation (
          defaultComponentName="weaBus",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-20,2},{22,-2}},
                lineColor={255,204,51},
                lineThickness=0.5)}),
          Documentation(info="<html>
<p>
This component is an expandable connector that is used to implement a bus that contains the weather data.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Bus;

      package BaseClasses
        "Package with base classes for Buildings.BoundaryConditions.WeatherData"
        extends Modelica.Icons.BasesPackage;

        block CheckCeilingHeight
          "Ensures that the ceiling height is above a lower bound"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput ceiHeiIn(final quantity="Height", final unit=
                   "m") "Input ceiling height"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput ceiHeiOut(final quantity="Height",
              final unit="m") "Ceiling height"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Height ceiHeiMin=0
            "Minimum allowed ceiling height";
        equation

          ceiHeiOut = Buildings.Utilities.Math.Functions.smoothMax(
            ceiHeiIn,
            ceiHeiMin,
            0.1);

          annotation (
            defaultComponentName="cheCeiHei",
            Documentation(info="<html>
<p>
This component ensures that the ceiling height is at least <i>0</i> meters.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="m")}));
        end CheckCeilingHeight;

        block CheckRadiation "Ensure that the radiation is not smaller than 0"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput HIn(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Input radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput HOut(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2") "Radiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          constant Modelica.SIunits.RadiantEnergyFluenceRate HMin=0.0001
            "Minimum value for radiation";
        equation

          HOut = Buildings.Utilities.Math.Functions.smoothMax(
            x1=HIn,
            x2=HMin,
            deltaX=HMin/10);
          annotation (
            defaultComponentName="cheRad",
            Documentation(info="<html>
<p>
This component ensures that the radiation is not smaller than 0.
Modelica Table will interpolate data when it reads the data from a file.
Thus, it is possible to generate negative value due to the interpolation.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-24,44},{30,-32}},
                  lineColor={0,0,255},
                  textString="H")}));
        end CheckRadiation;

        block CheckRelativeHumidity "Check the validity of relative humidity"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput relHumIn(final unit="1")
            "Input relative humidity"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relHumOut(final unit="1")
            "Relative humidity"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Real delta=0.01 "Smoothing parameter";
        protected
          constant Real relHumMin=delta "Lower bound";
          constant Real relHumMax=1 - delta "Upper bound";

        equation
          relHumOut = Buildings.Utilities.Math.Functions.smoothLimit(
            relHumIn,
            relHumMin,
            relHumMax,
            delta/10);
          annotation (
            defaultComponentName="cheRelHum",
            Documentation(info="<html>
<p>
This component constrains the value of relative humidity to a range of <i>[0, 1]</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Bitmap(extent={{-56,52},{62,-42}}, fileName=
                      "modelica://Buildings/Resources/Images/Utilities/IO/WeatherData/BaseClasses/RelativeHumidity.png")}));
        end CheckRelativeHumidity;

        block CheckPressure
          "Ensures that the interpolated pressure is between prescribed bounds"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput PIn(final quantity="Pressure", final unit=
                   "Pa") "Input pressure"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput POut(final quantity="Pressure", final unit=
                   "Pa") "Atmospheric pressure"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Pressure PMin=3100
            "Minimum allowed pressure";
          constant Modelica.SIunits.Pressure PMax=120000
            "Maximum allowed pressure";
        equation
          assert(PIn > PMin, "Pressure out of bounds.\n" + "   PIn = " + String(PIn));
          assert(PIn < PMax, "Pressure out of bounds.\n" + "   PIn = " + String(PIn));
          POut = PIn;

          annotation (
            defaultComponentName="chePre",
            Documentation(info="<html>
<p>
This component ensures that the interpolated pressure is between <i>31,000</i> Pa and <i>120,000</i> Pa.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="P")}));
        end CheckPressure;

        block CheckSkyCover "Constrains the sky cover to [0, 1]"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput nIn(min=0, max=1, unit="1")
            "Input sky cover [0, 10]"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput nOut(min=0, max=1, unit="1")
            "Sky cover [0, 1]"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          constant Real delta=0.01 "Smoothing parameter";
        protected
          constant Real nMin=delta "Lower bound";
          constant Real nMax=10 - delta "Upper bound";
        equation
          nOut = Buildings.Utilities.Math.Functions.smoothLimit(
            nIn,
            nMin,
            nMax,
            delta/10);
          annotation (
            defaultComponentName="cheSkyCov",
            Documentation(info="<html>
<p>
This component constrains the interpolated sky cover between <i>0</i> and <i>1</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed model as
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.ReaderTMY3\">
Buildings.BoundaryConditions.WeatherData.ReaderTMY3</a>
send a signal between <i>0</i> and <i>1</i>.
Added <code>min</code> and <code>max</code>
attributes.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-64,48},{70,-48}},
                  lineColor={0,0,255},
                  textString="Sky")}));
        end CheckSkyCover;

        block CheckTemperature "Check the validity of temperature data"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Input Temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput TOut(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Output temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          parameter Modelica.SIunits.Temperature TMin(displayUnit="degC") = 203.15
            "Minimum allowed temperature";
          parameter Modelica.SIunits.Temperature TMax(displayUnit="degC") = 343.15
            "Maximum allowed temperature";

        equation
          TOut = TIn;
          assert(TOut > TMin, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));
          assert(TOut < TMax, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));

          annotation (
            defaultComponentName="cheTem",
            Documentation(info="<html>
<p>
This component checks the value of temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit convertion part and name it from ConvertTemperature to CheckTemperature.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Set <code>displayUnit</code> argument for temperature output signal.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{42,44},{-38,-36}},
                  lineColor={0,0,0},
                  textString="T")}));
        end CheckTemperature;

        block CheckWindDirection
          "Constrains the wind direction to [0, 2*pi] degree"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput nIn(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Input wind direction"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput nOut(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Wind direction"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          constant Real delta=0.01 "Smoothing parameter";
        protected
          constant Real nMin=0 "Lower bound";
          constant Real nMax=2*Modelica.Constants.pi "Upper bound";
        equation

          nOut = Buildings.Utilities.Math.Functions.smoothLimit(
            nIn,
            nMin,
            nMax,
            delta/10);
          annotation (
            defaultComponentName="cheWinDir",
            Documentation(info="<html>
<p>
This component constrains the interpolated wind direction between <i>0</i> and <i>360</i> degree.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit convertion part since it will be done outside.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end CheckWindDirection;

        block CheckWindSpeed "Ensures that the wind speed is non-negative"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput winSpeIn(final quantity="Velocity",
              final unit="m/s") "Input wind speed"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput winSpeOut(final quantity="Velocity",
              final unit="m/s") "Wind speed"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Velocity winSpeMin=1e-6
            "Minimum allowed wind speed";

        equation
          // Modelica Table will interpolate data when it reads the weather data file.
          // It can generate negative values due to the interpolation.
          winSpeOut = Buildings.Utilities.Math.Functions.smoothMax(
            x1=winSpeIn,
            x2=winSpeMin,
            deltaX=winSpeMin/10);

          annotation (
            defaultComponentName="cheWinSpe",
            Documentation(info="<html>
<p>
This component ensures that the wind speed is non-negative.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="m/s")}));
        end CheckWindSpeed;

        block ConvertRadiation
          "Convert the unit of solar radiation received from the TMY3 data file"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput HIn(final unit="W.h/m2")
            "Input radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput HOut(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2") "Radiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        protected
          constant Modelica.SIunits.Time Hou=3600 "1 hour";

        equation
          HOut = HIn/Modelica.SIunits.Conversions.to_hour(Hou);
          annotation (
            defaultComponentName="conRad",
            Documentation(info="<html>
<p>
The TMY3 data for solar radiation is the radiation accumulated in one hour. Thus, it used a unit of <code>Wh/m2</code>.
This component converts <code>Wh/m2</code> to <code>W/m2</code> that is the standard unit in Modelica.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Add the unit conversion and delete the data validity check.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-24,44},{30,-32}},
                  lineColor={0,0,255},
                  textString="H")}));
        end ConvertRadiation;

        block ConvertRelativeHumidity
          "Convert the relative humidity from percentage to real"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput relHumIn(unit="1")
            "Value of relative humidity in percentage"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relHumOut(unit="1")
            "Relative humidity between 0 and 1"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          relHumOut = relHumIn/100;
          annotation (
            defaultComponentName="conRelHum",
            Documentation(info="<html>
<p>
This component converts the relative humidity from percentage to real.
Input is the relative humidity in percentage, as this is the data
format that is used in the Typical Meteorological Year weather data.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Separate the checking function to CheckRelativeHumidity.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Bitmap(extent={{-56,52},{62,-42}}, fileName=
                      "modelica://Buildings/Resources/Images/Utilities/IO/WeatherData/BaseClasses/RelativeHumidity.png")}));
        end ConvertRelativeHumidity;

        block ConvertTime
          "Converts the simulation time to calendar time in scale of 1 year (365 days)"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput simTim(final quantity="Time", final unit=
               "s") "Simulation time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput calTim(final quantity="Time", final
              unit="s") "Calendar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        protected
          constant Modelica.SIunits.Time year=31536000
            "Number of seconds in a year";
          discrete Modelica.SIunits.Time tStart "Start time of period";
          //Integer count "Period count";

        initial algorithm
          tStart := integer(simTim/year)*year;
        equation
          when simTim - pre(tStart) > year then
            tStart = integer(simTim/year)*year;
          end when;
          calTim = simTim - tStart;
          annotation (
            defaultComponentName="conTim",
            Documentation(info="<html>
<p>
This component converts the simulation time to calendar time in a scale of 1 year (365 days).
</p>
</html>",         revisions="<html>
<ul>
<li>
September 27, 2011, by Wangda Zuo, Michael Wetter:<br/>
Modify it to convert negative value of time.
Use the when-then to allow dymola differentiating this model when conducting index reduction which is not allowed in previous implementation.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br/>
Renamed the component.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-98,6},{-74,-4}},
                  lineColor={0,0,127},
                  textString="simTim"),
                Text(
                  extent={{74,6},{98,-4}},
                  lineColor={0,0,127},
                  textString="calTim"),
                Bitmap(extent={{-50,60},{52,-60}}, fileName=
                      "modelica://Buildings/Resources/Images/Utilities/IO/WeatherData/BaseClasses/calendar.png")}));
        end ConvertTime;

        block EquationOfTime "Equation of time"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput nDay(quantity="Time", unit="s")
            "Zero-based day number in seconds (January 1=0, January 2=86400)"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput eqnTim(
            final quantity="Time",
            final unit="s",
            displayUnit="min") "Equation of time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        protected
          Real Bt;
        equation
          Bt = Modelica.Constants.pi*((nDay + 86400)/86400 - 81)/182
            "Our unit is s instead of day in (A.4.2b)";
          eqnTim = 60*(9.87*Modelica.Math.sin(2*Bt) - 7.53*Modelica.Math.cos(Bt) - 1.5*
            Modelica.Math.sin(Bt)) "Our unit is s instead of min in (A.4.2a)";
          annotation (
            defaultComponentName="eqnTim",
            Documentation(info="<html>
<p>
This component computes the difference between solar noon and noon of local civic time.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-58,38},{38,-24}},
                  lineColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-6,4},{52,-24}},
                  lineColor={0,0,255},
                  textString="equ")}));
        end EquationOfTime;

        block LocalCivilTime "Converts the clock time to local civil time."
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput cloTim(final quantity="Time", final unit=
               "s") "Clock time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          parameter Modelica.SIunits.Time timZon(displayUnit="h") "Time zone";
          parameter Modelica.SIunits.Angle lon(displayUnit="deg") "Longitude";
          Modelica.Blocks.Interfaces.RealOutput locTim(final quantity="Time", final unit=
                   "s") "Local civil time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          locTim = cloTim - timZon + lon*43200/Modelica.Constants.pi;

          annotation (
            defaultComponentName="locTim",
            Documentation(info="<html>
<p>
This component converts the clock time to local civil time.
The parameter <code>timZon</code> represents the time zone of the facility  (relative to Greenwich Mean Time or the 0th meridian). Time zones west of GMT (e.g. North America) are represented as negative;
east of GMT as positive. Fraction of hours are represented in decimals (e.g. for <i>6:30</i>, use <i>6.5</i>).
</p>
<p>
The formula is based on Michael Wetter's thesis (A4.1):
</p>
<pre>
  locTim = greTim + (lon*180/pi)*86400/360 = cloTim - timZon + lon*43200/pi
</pre>
</html>",         revisions="<html>
<ul>
<li>
February 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-98,6},{-60,-6}},
                  lineColor={0,0,127},
                  textString="cloTim"), Text(
                  extent={{74,6},{98,-4}},
                  lineColor={0,0,127},
                  textString="calTim")}));
        end LocalCivilTime;

        block SolarTime "Solar time"
          extends Modelica.Blocks.Icons.Block;
        public
          Modelica.Blocks.Interfaces.RealInput locTim(quantity="Time", unit="s")
            "Local time" annotation (Placement(transformation(extent={{-140,-74},{-100,
                    -34}}), iconTransformation(extent={{-140,-74},{-100,-34}})));
          Modelica.Blocks.Interfaces.RealInput equTim(quantity="Time", unit="s")
            "Equation of time" annotation (Placement(transformation(extent={{-140,40},{
                    -100,80}}), iconTransformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput solTim(
            final quantity="Time",
            final unit="s",
            displayUnit="s") "Solar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        algorithm
          solTim := locTim + equTim "Our unit is s in stead of h in (A.4.3)";

          annotation (
            defaultComponentName="solTim",
            Documentation(info="<html>
<p>
This component computes the local solar time.
</p>
<p>
<b>Note:</b> To avoid events, this block does not convert solar time to a scale of 24 hours.
</p>
</html>",         revisions="<html>
<ul>
<li>
Feb. 16, 2012, by Michael Wetter:<br/>
Removed section that limits solar time to
<code>0 &le; solTim &le; 86400</code> as this triggers
events, and is not needed because solar time is used in
trigonometric functions only.
</li>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-54,38},{42,-24}},
                  lineColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-4,4},{52,-24}},
                  lineColor={0,0,255},
                  textString="sol"),
                Text(
                  extent={{-94,66},{-42,50}},
                  lineColor={0,0,127},
                  textString="equTim"),
                Text(
                  extent={{-96,-44},{-44,-60}},
                  lineColor={0,0,127},
                  textString="locTim")}));
        end SolarTime;

        function getAbsolutePath "Gets the absolute path of a URI"
          input String uri "A uri";
          output String path
            "The absolute path of the file pointed to by the URI";

        protected
          function loadResource
            input String name "Name of the resource";
            output String path
              "Full path of the resource, or a string of length 0 if it does not exist";
          algorithm
            path :=ModelicaServices.ExternalReferences.loadResource(name);
            if Modelica.Utilities.Strings.length(path) > 0 then
              path := Modelica.Utilities.Files.fullPathName(name=path);
            end if;
          end loadResource;

        algorithm
          // If uri does not start with file:// or modelica://, then add file:// to it.
          // This is done because a data reader uses as a parameter the file name without file://
          if (Modelica.Utilities.Strings.find(uri, "file://", startIndex=1, caseSensitive=false) == 0
          and Modelica.Utilities.Strings.find(uri, "modelica://", startIndex=1, caseSensitive=false) == 0) then
          // try file://+uri
            path := loadResource("file://" + uri);
            if not Modelica.Utilities.Files.exist(path) then
              // try modelica://+uri
              path := loadResource("modelica://" + uri);
              if not Modelica.Utilities.Files.exist(path) then
                // try modelica://Buildings/+uri
                path := loadResource("modelica://Buildings/" + uri);

                assert(Modelica.Utilities.Files.exist(path), "File '" + uri + "' does not exist.
  Expected to find either 'file://"         + uri + "
                       or 'modelica://"         + uri + " +
                       or 'modelica://Buildings/"         + uri);
              end if;
            end if;
          else
            path := ModelicaServices.ExternalReferences.loadResource(uri);
            path := Modelica.Utilities.Files.fullPathName(name=path);

            assert(Modelica.Utilities.Files.exist(path), "File '" + uri + "' does not exist.");

          end if;

          annotation (Documentation(info="<html>
<p>
This function returns the absolute path of the uniform resource identifier
by searching for a file with the name
</p>
<pre>
file://uri
modelica://uri
modelica://Buildings/uri
</pre>
<p>
The function returns the absolute path of the first file that is found, using the above search order.
If the file is not found, then this function terminates with an <code>assert</code>.
</p>
<p>
This function has been introduced to allow users to specify the name of weather data
files with a path that is relative to the library path.
This allows users to change the current working directory while still being able to read
the files.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 8, 2013, by Michael Wetter:<br/>
Improved algorithm that determines the absolute path of the file.
Now the function works from any directory as long as the <code>Buildings</code> library
is on the <code>MODELICAPATH</code>.
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getAbsolutePath;

        function getHeaderElementTMY3
          "Gets an element from the header of a TMY3 weather data file"
         input String filNam "Name of weather data file"
         annotation (Dialog(
                __Dymola_loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         input String start "Start of the string that contains the elements";
         input String name "Name of data element, used in error reporting";
         input Integer position(min=1)
            "Position of the element on the line that contains 'start'";
         output String element
            "Element at position 'pos' of the line that starts with 'start'";
        protected
         String lin "Line that is used in parser";
         Integer iLin "Line number";
         Integer index =  0 "Index of string #LOCATION";
         Integer staInd "Start index used when parsing a real number";
         Integer nexInd "Next index used when parsing a real number";
         Boolean found "Flag, true if #LOCATION has been found";
         Boolean EOF "Flag, true if EOF has been reached";
         String fouDel "Found delimiter";
        algorithm
          // Get line that starts with 'start'
          iLin :=0;
          EOF :=false;
          while (not EOF) and (index == 0) loop
            iLin:=iLin + 1;
            (lin, EOF) :=Modelica.Utilities.Streams.readLine(fileName=getAbsolutePath(filNam),
              lineNumber=iLin);
            index :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString=start,
              startIndex=1,
              caseSensitive=false);
          end while;
          assert(not EOF, "Error: Did not find '" + start + "' when scanning the weather file."
                              + "\n   Check for correct weather file syntax.");
          // Loop over the tokens until the position is reached
          nexInd :=1;
          for i in 1:position-1 loop
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString=  ",",
              startIndex=nexInd+1);
           assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                lin + "'.");
          end for;
          staInd := nexInd;
          // Find the next delimiter
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString=  ",",
              startIndex=nexInd+1);
          assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                 lin + "'.");
          // Get the element
          element :=Modelica.Utilities.Strings.substring(lin, startIndex=staInd+1, endIndex=nexInd-1);
          annotation (Inline=false,
          Documentation(info="<html>
This function scans the weather data file for a line that starts with the string <pre>
start
</pre>
where <code>start</code> is a parameter.
When this line is found, the function returns the element at the position number
<code>position</code>, where <code>position</code> is a parameter.
A comma is used as the delimiter of the elements.
</html>",         revisions="<html>
<ul>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Removed default value for parameter <code>name</code>.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getHeaderElementTMY3;

        function getLatitudeTMY3
          "Gets the latitude from a TMY3 weather data file"
         input String filNam "Name of weather data file"
         annotation (Dialog(
                __Dymola_loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Angle lat "Latitude from the weather file";
        protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name=  "longitude",
              position=7);
           (nexInd, lat) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the latitude '" +
                              element + "' from a String to a Real.");
           // Convert from degree to rad
           lat :=lat*Modelica.Constants.pi/180;
           // Check if latitude is valid
           assert(abs(lat) <= Modelica.Constants.pi+Modelica.Constants.eps,
               "Wrong value for latitude. Received lat = " +
               String(lat) + " (= " + String(lat*180/Modelica.Constants.pi) + " degrees).");

          annotation (Documentation(info="<html>
This function returns the latitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
February 25, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getLatitudeTMY3;

        function getLongitudeTMY3
          "Gets the longitude from a TMY3 weather data file"
         input String filNam "Name of weather data file"
         annotation (Dialog(
                __Dymola_loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Angle lon "Longitude from the weather file";
        protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name=  "longitude",
              position=8);
           (nexInd, lon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the longitude '" +
                              element + "' from a String to a Real.");
           // Convert from degree to rad
           lon :=lon*Modelica.Constants.pi/180;
           // Check if longitude is valid
           assert(abs(lon) < 2*Modelica.Constants.pi,
               "Wrong value for longitude. Received lon = " +
               String(lon) + " (= " + String(lon*180/Modelica.Constants.pi) + " degrees).");

          annotation (Documentation(info="<html>
This function returns the longitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getLongitudeTMY3;

        function getTimeZoneTMY3
          "Gets the time zone from a TMY3 weather data file"
         input String filNam "Name of weather data file"
         annotation (Dialog(
                __Dymola_loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Time timZon "Time zone from the weather file";
        protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name=  "longitude",
              position=9);
           (nexInd, timZon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the time zone '" +
                              element + "' from a String to a Real.");
           timZon :=timZon*3600;
           // Check if time zone is valid
           assert(abs(timZon) < 24*3600,
               "Wrong value for time zone. Received timZon = " +
               String(timZon) + " (= " + String(timZon/3600) + " hours).");

          annotation (Documentation(info="<html>
This function returns the time zone of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getTimeZoneTMY3;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">Buildings.BoundaryConditions.WeatherData</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to read weather data. It also contains
an expandable connector called <code>Bus</code> that
is used in the library to provide weather data to the different models.
</html>"));
    end WeatherData;

    package Types "Package with type definitions"

      type DataSource = enumeration(
          File "Use data from file",
          Parameter "Use parameter",
          Input "Use input connector") "Enumeration to define data source"
            annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",     revisions=
              "<html>
<ul>
<li>
July 20, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      type RadiationDataSource = enumeration(
          File "Use data from file",
          Input_HGloHor_HDifHor
            "Global horizontal and diffuse horizontal radiation from connector",

          Input_HDirNor_HDifHor
            "Direct normal and diffuse horizontal radiation from connector",
          Input_HDirNor_HGloHor
            "Direct normal and global horizontal radiation from connector")
        "Enumeration to define solar radiation data source"
            annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",     revisions=
              "<html>
<ul>
<li>
August 13, 2012, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));

      type SkyTemperatureCalculation = enumeration(
          HorizontalRadiation "Use horizontal irradiation",
          TemperaturesAndSkyCover
            "Use dry-bulb and dew-point temperatures and sky cover")
        "Enumeration for computation of sky temperature" annotation (Documentation(
            info =                "<html>
<p>
Enumeration to define the method used to compute the sky temperature.
</p>
</html>",     revisions=
              "<html>
<ul>
<li>
October 3, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    annotation (preferredView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
    end Types;
  annotation (preferredView="info",
  Documentation(info="<html>
This package contains models to compute boundary conditions such as weather data.
For models that set boundary conditions for fluid flow systems,
see
<a href=\"modelica://Buildings.Fluid.Sources\">
Buildings.Fluid.Sources</a>.
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
        graphics={
          Ellipse(
          extent={{-76,80},{6,-2}},
          lineColor={255,255,255},
          lineThickness=1,
          fillPattern=FillPattern.Sphere,
          fillColor={255,255,255}),
        Line(
          points={{32,-24},{76,-82}},
          color={95, 95, 95},
          smooth=Smooth.None),
        Line(
          points={{4,-24},{48,-82}},
          color={95, 95, 95},
          smooth=Smooth.None),
        Line(
          points={{-26,-24},{18,-82}},
          color={95, 95, 95},
          smooth=Smooth.None),
        Line(
          points={{-56,-24},{-12,-82}},
          color={95, 95, 95},
          smooth=Smooth.None),
        Polygon(
          points={{64,6},{50,-2},{40,-18},{70,-24},{78,-52},{26,-52},{-6,-54},{
              -72,-52},{-72,-22},{-52,-10},{-42,10},{-78,34},{-44,52},{40,56},{76,
              40},{64,6}},
          lineColor={150,150,150},
          lineThickness=0.1,
          fillPattern=FillPattern.Sphere,
          smooth=Smooth.Bezier,
          fillColor={150,150,150})}));
  end BoundaryConditions;

  package Controls "Package with models for controls"
    extends Modelica.Icons.Package;

    package Continuous "Package with models for discrete time controls"
      extends Modelica.Icons.Package;

      block LimPID
        "P, PI, PD, and PID controller with limited output, anti-windup compensation and setpoint weighting"
        extends Modelica.Blocks.Continuous.LimPID(
          addP(k1=revAct*wp, k2=-revAct),
          addD(k1=revAct*wd, k2=-revAct),
          addI(k1=revAct, k2=-revAct),
          yMin=0,
          yMax=1);

        parameter Boolean reverseAction = false
          "Set to true for throttling the water flow rate through a cooling coil controller";
      protected
        parameter Real revAct = if reverseAction then -1 else 1;
        annotation (
      defaultComponentName="conPID",
      Documentation(info="<html>
<p>
This model is identical to
<a href=\"modelica://Modelica.Blocks.Continuous.LimPID\">
Modelica.Blocks.Continuous.LimPID</a> except
that it can be configured to have a reverse action.
</p>
<p>
If the parameter <code>reverseAction=false</code> (the default),
then <code>u_m &lt; u_s</code> increases the controller output,
otherwise the controller output is decreased.
Thus,
</p>
<ul>
<li>
for a heating coil with a two-way valve, set <code>reverseAction = false</code>,
</li>
<li>
for a cooling coils with a two-way valve, set <code>reverseAction = true</code>.
</li>
</ul>
</html>",
      revisions="<html>
<ul>
<li>
February 24, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                extent={{-6,-20},{66,-66}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.P),
                extent={{-32,-22},{68,-62}},
                lineColor={0,0,0},
                textString="P",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PI),
                extent={{-28,-22},{72,-62}},
                lineColor={0,0,0},
                textString="PI",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PD),
                extent={{-16,-22},{88,-62}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175},
                textString="P D"),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PID),
                extent={{-14,-22},{86,-62}},
                lineColor={0,0,0},
                textString="PID",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175})}));
      end LimPID;
    annotation (
    preferredView="info", Documentation(info="<html>
This package contains components models for continuous time controls.
For additional models, see also
<a href=\"modelica://Modelica.Blocks.Continuous\">
Modelica.Blocks.Discrete</a>.
</html>"),
    Icon(graphics={Line(
              origin={0.061,4.184},
              points={{81.939,36.056},{65.362,36.056},{14.39,-26.199},{-29.966,
                  113.485},{-65.374,-61.217},{-78.061,-78.184}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Continuous;
  annotation (
  preferredView="info", Documentation(info="<html>
This package contains components models for controls.
For additional models, see also
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={0.0,35.1488},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Rectangle(
          origin={0.0,-34.8512},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Line(
          origin={-51.25,0.0},
          points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}}),
        Polygon(
          origin={-40.0,35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}}),
        Line(
          origin={51.25,0.0},
          points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}}),
        Polygon(
          origin={40.0,-35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}})}));
  end Controls;

  package Fluid "Package with models for fluid flow systems"
    extends Modelica.Icons.Package;

    package Actuators "Package with actuator models such as valves and dampers"
      extends Modelica.Icons.VariantsPackage;

      package Valves "Package with valve models"
        extends Modelica.Icons.VariantsPackage;

        model TwoWayLinear "Two way valve with linear flow characteristics"
          extends BaseClasses.PartialTwoWayValve(phi=l + y_actual*(1 - l));

        initial equation
          // Since the flow model Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow computes
          // 1/k^2, the parameter l must not be zero.
          assert(l > 0, "Valve leakage parameter l must be bigger than zero.");
        annotation (
        defaultComponentName="val",
        Documentation(info="<html>
<p>
Two way valve with linear opening characteristic.
</p><p>
This model is based on the partial valve model
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
Check this model for more information, such
as the regularization near the origin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 4, 2014, by Michael Wetter:<br/>
Moved the assignment of the flow function <code>phi</code>
to the model instantiation because in its base class,
the keyword <code>input</code>
has been added to the variable <code>phi</code>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal=0</code>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TwoWayLinear;
      annotation (preferredView="info", Documentation(info="<html>
This package contains components models for two- and three-way valves.
For motor models, see
<a href=\"modelica://Buildings.Fluid.Actuators.Motors\">Buildings.Fluid.Actuators.Motors</a>.
</html>"));
      end Valves;

      package BaseClasses
        "Package with base classes for Buildings.Fluid.Actuators"
        extends Modelica.Icons.BasesPackage;

        model ActuatorSignal
          "Partial model that implements the filtered opening for valves and dampers"

          parameter Boolean filteredOpening=true
            "= true, if opening is filtered with a 2nd order CriticalDamping filter"
            annotation(Dialog(tab="Dynamics", group="Filtered opening"));
          parameter Modelica.SIunits.Time riseTime=120
            "Rise time of the filter (time to reach 99.6 % of an opening step)"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=filteredOpening));
          parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.InitialOutput
            "Type of initialization (no init/steady state/initial state/initial output)"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=filteredOpening));
          parameter Real y_start=1 "Initial value of output"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=filteredOpening));

          Modelica.Blocks.Interfaces.RealInput y(min=0, max=1)
            "Actuator position (0: closed, 1: open)"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                  rotation=270,
                origin={0,120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,120})));

          Modelica.Blocks.Interfaces.RealOutput y_actual
            "Actual valve position"
            annotation (Placement(transformation(extent={{40,60},{60,80}})));

          // Classes used to implement the filtered opening
        protected
          Modelica.Blocks.Interfaces.RealOutput y_filtered if filteredOpening
            "Filtered valve position in the range 0..1"
            annotation (Placement(transformation(extent={{40,78},{60,98}}),
                iconTransformation(extent={{60,50},{80,70}})));

          Modelica.Blocks.Continuous.Filter filter(
             order=2,
             f_cut=5/(2*Modelica.Constants.pi*riseTime),
             final init=init,
             final y_start=y_start,
             final analogFilter=Modelica.Blocks.Types.AnalogFilter.CriticalDamping,
             final filterType=Modelica.Blocks.Types.FilterType.LowPass,
             x(each stateSelect=StateSelect.always)) if
                filteredOpening
            "Second order filter to approximate valve opening time, and to improve numerics"
            annotation (Placement(transformation(extent={{6,81},{20,95}})));

        equation
         connect(filter.y, y_filtered) annotation (Line(
              points={{20.7,88},{50,88}},
              color={0,0,127},
              smooth=Smooth.None));
          if filteredOpening then
          connect(y, filter.u) annotation (Line(
              points={{1.11022e-15,120},{1.11022e-15,88},{4.6,88}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(filter.y, y_actual) annotation (Line(
              points={{20.7,88},{30,88},{30,70},{50,70}},
              color={0,0,127},
              smooth=Smooth.None));
          else
            connect(y, y_actual) annotation (Line(
              points={{1.11022e-15,120},{0,120},{0,70},{50,70}},
              color={0,0,127},
              smooth=Smooth.None));
          end if;

          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={
                Line(
                  points={{0,40},{0,100}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,70},{40,70}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  visible=filteredOpening,
                  extent={{-32,40},{32,100}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  visible=filteredOpening,
                  extent={{-32,100},{32,40}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  visible=filteredOpening,
                  extent={{-20,92},{20,48}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  textString="M",
                  textStyle={TextStyle.Bold})}),
        Documentation(info="<html>
<p>
This model implements the filter that is used to approximate the travel
time of the actuator.
Models that extend this model use the signal
<code>y_actual</code> to obtain the
current position of the actuator.
</p>
<p>
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>
for a description of the filter.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 14, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ActuatorSignal;

        partial model PartialTwoWayValve "Partial model for a two way valve"

          extends Buildings.Fluid.BaseClasses.PartialResistance(
               final dp_nominal=dpValve_nominal + dpFixed_nominal,
               dp(nominal=6000),
               final m_flow_turbulent = deltaM * abs(m_flow_nominal));

          extends Buildings.Fluid.Actuators.BaseClasses.ValveParameters(
              rhoStd=Medium.density_pTX(101325, 273.15+4, Medium.X_default));

          extends Buildings.Fluid.Actuators.BaseClasses.ActuatorSignal;
          parameter Modelica.SIunits.Pressure dpFixed_nominal(displayUnit="Pa", min=0) = 0
            "Pressure drop of pipe and other resistances that are in series"
             annotation(Dialog(group = "Nominal condition"));

          parameter Real l(min=1e-10, max=1) = 0.0001
            "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          input Real phi
            "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1)";
        protected
         parameter Real kFixed(unit="", min=0) = if dpFixed_nominal > Modelica.Constants.eps
            then m_flow_nominal / sqrt(dpFixed_nominal) else 0
            "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
         Real kVal(unit="", min=Modelica.Constants.small)
            "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
         Real k(unit="", min=Modelica.Constants.small)
            "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
        initial equation
          assert(dpFixed_nominal > -Modelica.Constants.small, "Require dpFixed_nominal >= 0. Received dpFixed_nominal = "
                + String(dpFixed_nominal) + " Pa.");
        equation
         kVal = phi*Kv_SI;
         if (dpFixed_nominal > Modelica.Constants.eps) then
           k = sqrt(1/(1/kFixed^2 + 1/kVal^2));
         else
           k = kVal;
         end if;

         if linearized then
           // This implementation yields m_flow_nominal = phi*kv_SI * sqrt(dp_nominal)
           // if m_flow = m_flow_nominal and dp = dp_nominal
           m_flow*m_flow_nominal_pos = k^2 * dp;
         else
           if homotopyInitialization then
             if from_dp then
                 m_flow=homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                        m_flow_turbulent=m_flow_turbulent),
                                        simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                 dp=homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k,
                                        m_flow_turbulent=m_flow_turbulent),
                                        simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
             end if;
           else // do not use homotopy
             if from_dp then
               m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                        m_flow_turbulent=m_flow_turbulent);
              else
                dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k,
                                        m_flow_turbulent=m_flow_turbulent);
              end if;
            end if; // homotopyInitialization
         end if; // linearized
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}),       graphics={
                Polygon(
                  points={{2,-2},{-76,60},{-76,-60},{2,-2}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-50,40},{0,-2},{54,40},{54,40},{-50,40}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-52,-42},{0,-4},{60,40},{60,-42},{-52,-42}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{0,-2},{82,60},{82,-60},{0,-2}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{0,40},{0,-4}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  visible=not filteredOpening,
                  points={{0,100},{0,40}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
        Documentation(info="<html>
<p>
Partial model for a two way valve. This is the base model for valves
with different opening characteristics, such as linear, equal percentage
or quick opening.
</p>
<p>
To prevent the derivative <code>d/dP (m_flow)</code> to be infinite near
the origin, this model linearizes the pressure drop versus flow relation
ship. The region in which it is linearized is parameterized by
</p>
<pre>
  m_turbulent_flow = deltaM * m_flow_nominal
</pre>
<p>
Because the parameterization contains <code>Kv_SI</code>, the values for
<code>deltaM</code> and <code>dp_nominal</code> need not be changed if the valve size
changes.
</p>
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e.,
it is the ratio between mass flow rate in <code>kg/s</code> and square root
of pressure drop in <code>Pa</code>.
</p>
<h4>Modelling options</h4>
<p>
This model allows different parameterization of the flow resistance.
The different parameterizations are described in
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.ValveParameters\">
Buildings.Fluid.Actuators.BaseClasses.ValveParameters</a>.
</p>
<h4>Implementation</h4>
<p>
The two way valve models are implemented using this partial model, as opposed to using
different functions for the valve opening characteristics, because
each valve opening characteristics has different parameters.
</p>
<h4>Implementation</h4>
<p>
Models that extend this model need to provide a binding equation
for the flow function <code>phi</code>.
An example of such a code can be found in
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.TwoWayLinear\">
Buildings.Fluid.Actuators.Valves.TwoWayLinear</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 8, 2014, by Michael Wetter:<br/>
Reformulated the computation of <code>k</code> to make the model
work in OpenModelica.
</li>
<li>
April 4, 2014, by Michael Wetter:<br/>
Added keyword <code>input</code> to variable <code>phi</code>
to require models that extend this model to provide a binding equation.
This is done to use the same modeling concept as is used for example in
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
March 20, 2013, by Michael Wetter:<br/>
Set <code>dp(nominal=6000)</code> as the previous formulation gives an error during model check
in Dymola 2014. The reason is that the previous formulation used <code>dpValve_nominal</code>, which
is not known at translation time.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters.
Removed default value for <code>dpValve_nominal</code>, as this
parameter has the attribute <code>fixed=false</code> for some values
of <code>CvData</code>. In this case, assigning a value is not allowed.
Changed assignment of nominal attribute of <code>dp</code> to avoid assigning
a non-literal value.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal</code>.
See
<a href=\"modelica://Buildings.Fluid.Actuators.UsersGuide\">
Buildings.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>Buildings.Fluid.BaseClasses.PartialResistance</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>Buildings.Fluid.FixedResistances.FixedResistanceDpM</code>.
</li>
<li>
August 12, 2011 by Michael Wetter:<br/>
Added <code>assert</code> statement to prevent <code>l=0</code> due to the
implementation of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>.
</li>
<li>
April 4, 2011 by Michael Wetter:<br/>
Revised implementation to use new base class for actuators.
</li>
<li>
February 18, 2009 by Michael Wetter:<br/>
Implemented parameterization of flow coefficient as in
<code>Modelica.Fluid</code>.
</li>
<li>
August 15, 2008 by Michael Wetter:<br/>
Set valve leakage to nonzero value.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialTwoWayValve;

        partial model ValveParameters "Model with parameters for valves"

          parameter Buildings.Fluid.Types.CvTypes CvData=Buildings.Fluid.Types.CvTypes.OpPoint
            "Selection of flow coefficient"
           annotation(Dialog(group = "Flow Coefficient"));
          parameter Real Kv(
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.Kv then true else false)
            "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.Kv)));
          parameter Real Cv(
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.Cv then true else false)
            "Cv (US) flow coefficient [USG/min/(psi)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.Cv)));
          parameter Modelica.SIunits.Area Av(
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.Av then true else false)
            "Av (metric) flow coefficient"
           annotation(Dialog(group = "Flow Coefficient",
                             enable = (CvData==Buildings.Fluid.Types.CvTypes.Av)));

          parameter Real deltaM = 0.02
            "Fraction of nominal flow rate where linearization starts, if y=1"
            annotation(Dialog(group="Pressure-flow linearization"));
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal
            "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.Pressure dpValve_nominal(displayUnit="Pa",
                                                              min=0,
                                                              fixed= if CvData==Buildings.Fluid.Types.CvTypes.OpPoint then true else false)
            "Nominal pressure drop of fully open valve, used if CvData=Buildings.Fluid.Types.CvTypes.OpPoint"
            annotation(Dialog(group="Nominal condition",
                       enable = (CvData==Buildings.Fluid.Types.CvTypes.OpPoint)));

          parameter Modelica.SIunits.Density rhoStd
            "Inlet density for which valve coefficients are defined"
          annotation(Dialog(group="Nominal condition", tab="Advanced"));

        protected
          parameter Real Kv_SI(
            min=0,
            fixed= false)
            "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.OpPoint)));
        initial equation
          if  CvData == Buildings.Fluid.Types.CvTypes.OpPoint then
            Kv_SI =           m_flow_nominal/sqrt(dpValve_nominal);
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            Av    =           Kv_SI/sqrt(rhoStd);
          elseif CvData == Buildings.Fluid.Types.CvTypes.Kv then
            Kv_SI =           Kv*rhoStd/3600/sqrt(1E5)
              "Unit conversion m3/(h*sqrt(bar)) to kg/(s*sqrt(Pa))";
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            Av    =           Kv_SI/sqrt(rhoStd);
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          elseif CvData == Buildings.Fluid.Types.CvTypes.Cv then
            Kv_SI =           Cv*rhoStd*0.0631/1000/sqrt(6895)
              "Unit conversion USG/(min*sqrt(psi)) to kg/(s*sqrt(Pa))";
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Av    =           Kv_SI/sqrt(rhoStd);
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          else
            assert(CvData == Buildings.Fluid.Types.CvTypes.Av, "Invalid value for CvData.
Obtained CvData = "         + String(CvData) + ".");
            Kv_SI =           Av*sqrt(rhoStd);
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          end if;

          annotation (Documentation(info="<html>
<p>
Model that computes the flow coefficients of valves. This base class allows the following modeling options,
which have been adapted from the valve implementation
in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
to specify the valve flow coefficient in fully open conditions:
</p>
<ul>
<li><code>CvData = Buildings.Fluid.Types.CvTypes.Av</code>: the flow coefficient is given by the metric <code>Av</code> coefficient (m^2).
<li><code>CvData = Buildings.Fluid.Types.CvTypes.Kv</code>: the flow coefficient is given by the metric <code>Kv</code> coefficient (m^3/h).
<li><code>CvData = Buildings.Fluid.Types.CvTypes.Cv</code>: the flow coefficient is given by the US <code>Cv</code> coefficient (USG/min).
<li><code>CvData = Buildings.Fluid.Types.CvTypes.OpPoint</code>: the flow is computed from the nominal operating point specified by <code>dp_nominal</code> and <code>m_flow_nominal</code>.
</ul>
<p>
The treatment of parameters <code>Kv</code> and <code>Cv</code> is
explained in detail in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">Users Guide</a>.
</p>
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the protected parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e.,
it is the ratio between mass flow rate in <code>kg/s</code> and square root
of pressure drop in <code>Pa</code>.
The value of <code>Kv_SI</code> is computed based on the parameters
<code>Av</code>,
<code>Kv</code>,
<code>Cv</code>, or, if
<code>CvData = Buildings.Fluid.Types.CvTypes.OpPoint</code>, based on
<code>m_flow_nominal</code> and <code>dpValve_nominal</code>.
Conversely, if
<code>CvData &lt;&gt; Buildings.Fluid.Types.CvTypes.OpPoint</code>, then
<code>dpValve_nominal</code> is computed based on
<code>Av</code>,
<code>Kv</code>, or
<code>Cv</code>, and the nominal mass flow rate <code>m_flow_nominal</code>.
Therefore, if
<code>CvData &lt;&gt; Buildings.Fluid.Types.CvTypes.OpPoint</code>,
then specifying a value for <code>dpValve_nominal</code> is a syntax error.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 12, 2014, by Michael Wetter:<br/>
Changed attribute <code>min</code> of <code>dpValve_nominal</code>
to <code>0</code>.
This is needed as for example in
<a href=\"modelica://Buildings.Fluid.Actuators.Valves.Examples.TwoWayValveTable\">
Buildings.Fluid.Actuators.Valves.Examples.TwoWayValveTable</a>,
<code>dpValve_nominal=0</code>.
</li>
<li>
August 8, 2014, by Michael Wetter:<br/>
Changed the <code>initial algorithm</code> to an <code>initial equation</code>
section. Otherwise, OpenModelica attempts to solve for the parameter
values using numerical iteration, and fails in doing so.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 25, 2013, by Michael Wetter:<br/>
Removed stray backslash in write statement.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters, and removed <code>Kv_SI</code> as
a public parameter because it is always computed based on other parameters.
This change avoids a translation error in Dymola 2014 beta1 in
the pedantic mode, and a translation warning otherwise.
</li>
<li>
February 18, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ValveParameters;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Actuators\">Buildings.Fluid.Actuators</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains components models for actuators.
</html>"));
    end Actuators;

    package Boilers "Package with boiler models"
      extends Modelica.Icons.VariantsPackage;

      model BoilerPolynomial
        "Boiler with efficiency curve described by a polynomial of the temperature"
        extends Interfaces.TwoPortHeatMassExchanger(
          redeclare final Buildings.Fluid.MixingVolumes.MixingVolume vol,
          show_T = true,
          final tau=VWat*rho_default/m_flow_nominal);

        parameter Modelica.SIunits.Power Q_flow_nominal "Nominal heating power";
        parameter Modelica.SIunits.Temperature T_nominal = 353.15
          "Temperature used to compute nominal efficiency (only used if efficiency curve depends on temperature)";
        // Assumptions
        parameter Buildings.Fluid.Types.EfficiencyCurves effCur=Buildings.Fluid.Types.EfficiencyCurves.Constant
          "Curve used to compute the efficiency";
        parameter Real a[:] = {0.9} "Coefficients for efficiency curve";

        parameter Buildings.Fluid.Data.Fuels.Generic fue "Fuel type"
         annotation (choicesAllMatching = true);

        parameter Modelica.SIunits.ThermalConductance UA=0.05*Q_flow_nominal/30
          "Overall UA value";
        parameter Modelica.SIunits.Volume VWat = 1.5E-6*Q_flow_nominal
          "Water volume of boiler"
          annotation(Dialog(tab = "Dynamics", enable = not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)));
        parameter Modelica.SIunits.Mass mDry =   1.5E-3*Q_flow_nominal
          "Mass of boiler that will be lumped to water heat capacity"
          annotation(Dialog(tab = "Dynamics", enable = not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)));

        Real eta(min=0) "Boiler efficiency";

        Modelica.SIunits.Power QFue_flow "Heat released by fuel";
        Modelica.SIunits.Power QWat_flow "Heat transfer from gas into water";
        Modelica.SIunits.MassFlowRate mFue_flow "Fuel mass flow rate";
        Modelica.SIunits.VolumeFlowRate VFue_flow "Fuel volume flow rate";

        Modelica.Blocks.Interfaces.RealInput y(min=0, max=1) "Part load ratio"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
      protected
        Real eta_nominal "Boiler efficiency at nominal condition";

        Modelica.Thermal.HeatTransfer.Components.ThermalConductor UAOve(G=UA)
          "Overall thermal conductance (if heatPort is connected)"
          annotation (Placement(transformation(extent={{-48,10},{-28,30}})));
      public
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
          "Heat port, can be used to connect to ambient"
                                   annotation (Placement(transformation(extent={{-10,62},
                  {10,82}})));
        Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heaCapDry(C=500*mDry,
            T(start=T_start)) if not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
          "heat capacity of boiler metal"
          annotation (Placement(transformation(extent={{-80,12},{-60,32}})));
        Modelica.Blocks.Interfaces.RealOutput T(final quantity="ThermodynamicTemperature",
                                                final unit = "K", displayUnit = "degC", min=0)
                                                annotation (Placement(
              transformation(extent={{100,70},{120,90}})));
      protected
        Buildings.HeatTransfer.Sources.PrescribedHeatFlow preHeaFlo
          annotation (Placement(transformation(extent={{-43,-40},{-23,-20}})));
        Modelica.Blocks.Sources.RealExpression Q_flow_in(y=QWat_flow)
          annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temSen
          "Temperature of fluid"
          annotation (Placement(transformation(extent={{0,30},{20,50}})));
      equation
        if effCur ==Buildings.Fluid.Types.EfficiencyCurves.Constant then
          eta  = a[1];
          eta_nominal = a[1];
        elseif effCur ==Buildings.Fluid.Types.EfficiencyCurves.Polynomial then
          eta  = Buildings.Utilities.Math.Functions.polynomial(
                                                         a=a, x=y);
          eta_nominal = Buildings.Utilities.Math.Functions.polynomial(
                                                                a=a, x=1);
        elseif effCur ==Buildings.Fluid.Types.EfficiencyCurves.QuadraticLinear then
          eta  = Buildings.Utilities.Math.Functions.quadraticLinear(
                                                              a=a, x1=y, x2=T);
          eta_nominal = Buildings.Utilities.Math.Functions.quadraticLinear(
                                                                     a=a, x1=1, x2=T_nominal);
        else
          eta  = 0;
          eta_nominal = 999;
        end if;
        assert(eta > 0.001, "Efficiency curve is wrong.");
        // Heat released by fuel
        QFue_flow = y * Q_flow_nominal/eta_nominal;
        // Heat input into water
        QWat_flow = eta * QFue_flow;
        // Fuel mass flow rate and volume flow rate
        mFue_flow = QFue_flow/fue.h;
        VFue_flow = mFue_flow/fue.d;
        connect(UAOve.port_b, vol.heatPort)            annotation (Line(
            points={{-28,20},{-22,20},{-22,-10},{-9,-10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(UAOve.port_a, heatPort) annotation (Line(
            points={{-48,20},{-52,20},{-52,60},{0,60},{0,72}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(heaCapDry.port, vol.heatPort) annotation (Line(
            points={{-70,12},{-70,-10},{-9,-10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(temSen.T, T) annotation (Line(
            points={{20,40},{60,40},{60,80},{110,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(preHeaFlo.port, vol.heatPort) annotation (Line(
            points={{-23,-30},{-15,-30},{-15,-10},{-9,-10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(Q_flow_in.y,preHeaFlo. Q_flow) annotation (Line(
            points={{-59,-30},{-43,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(vol.heatPort, temSen.port) annotation (Line(
            points={{-9,-10},{-16,-10},{-16,40},{0,40}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation ( Icon(graphics={
              Ellipse(
                extent={{-20,22},{20,-20}},
                fillColor={127,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Polygon(
                points={{0,-34},{-12,-52},{14,-52},{0,-34}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Line(
                points={{-100,80},{-80,80},{-80,-44},{-6,-44}},
                pattern=LinePattern.None,
                smooth=Smooth.None),
              Text(
                extent={{-140,138},{-94,100}},
                lineColor={0,0,127},
                textString="y"),
              Text(
                extent={{88,128},{134,90}},
                lineColor={0,0,127},
                textString="T"),
              Line(
                points={{100,80},{80,80},{80,20},{6,20}},
                color={0,0,127},
                smooth=Smooth.None)}),
      defaultComponentName="boi",
      Documentation(info="<html>
<p>
This is a model of a boiler whose efficiency is described
by a polynomial.
The heat input into the medium is</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q&#775; = y Q&#775;<sub>0</sub> &eta; &frasl; &eta;<sub>0</sub>
</p>
<p>
where
<i>y &isin; [0, 1]</i> is the control signal,
<i>Q&#775;<sub>0</sub></i> is the nominal power,
<i>&eta;</i> is the efficiency at the current operating point, and
<i>&eta;<sub>0</sub></i> is the efficiency at <i>y=1</i> and
nominal temperature <i>T=T<sub>0</sub></i> as specified by the parameter
<code>T_nominal</code>.
</p>
<p>
The parameter <code>effCur</code> determines what polynomial is used
to compute the efficiency, which is defined as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &eta; = Q&#775; &frasl; Q&#775;<sub>f</sub>,
</p>
<p>
where
<i>Q&#775;</i> is the heat transfered to the working fluid (typically water or air), and
<i>Q&#775;<sub>f</sub></i> is the heat of combustion released by the fuel.
</p>
<p>
The following polynomials can be selected to compute the efficiency:
</p>
<table summary=\"summary\"  border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
<tr>
<th>Parameter <code>effCur</code></th>
<th>Efficiency curve</th>
</tr>
<tr>
<td>Buildings.Fluid.Types.EfficiencyCurves.Constant</td>
<td><i>&eta; = a<sub>1</sub></i></td>
</tr>
<tr>
<td>Buildings.Fluid.Types.EfficiencyCurves.Polynomial</td>
<td><i>&eta; = a<sub>1</sub> + a<sub>2</sub> y + a<sub>3</sub> y<sup>2</sup> + ...</i></td>
</tr>
<tr>
<td>Buildings.Fluid.Types.EfficiencyCurves.QuadraticLinear</td>
<td><i>&eta; = a<sub>1</sub> + a<sub>2</sub>  y
        + a<sub>3</sub> y<sup>2</sup>
        + (a<sub>4</sub> + a<sub>5</sub>  y
        + a<sub>6</sub> y<sup>2</sup>)  T
</i></td>
</tr>
</table>

<p>
where <i>T</i> is the boiler outlet temperature in Kelvin.
For <code>effCur = Buildings.Fluid.Types.EfficiencyCurves.Polynomial</code>,
an arbitrary number of polynomial coefficients can be specified.
</p>
<p>
The parameter <code>Q_flow_nominal</code> is the power transferred to the fluid
for <code>y=1</code> and, if the efficiency depends on temperature,
for <code>T=T0</code>.
</p>
<p>
The fuel mass flow rate and volume flow rate are computed as </p>
<p align=\"center\" style=\"font-style:italic;\">
  m&#775;<sub>f</sub> = Q&#775;<sub>f</sub> &frasl; h<sub>f</sub>
</p>
<p> and </p>
<p align=\"center\" style=\"font-style:italic;\">
  V&#775;<sub>f</sub> = m&#775;<sub>f</sub> &frasl; &rho;<sub>f</sub>,
</p>
<p>
where the fuel heating value
<i>h<sub>f</sub></i> and the fuel mass density
<i>&rho;<sub>f</sub></i> are obtained from the
parameter <code>fue</code>.
Note that if <i>&eta;</i> is the efficiency relative to the lower heating value,
then the fuel properties also need to be used for the lower heating value.
</p>

<p>
Optionally, the port <code>heatPort</code> can be connected to a heat port
outside of this model to impose a boundary condition in order to
model heat losses to the ambient. When using this <code>heatPort</code>,
make sure that the efficiency curve <code>effCur</code>
does not already account for this heat loss.
</p>

<p>
On the Assumptions tag, the model can be parameterized to compute a transient
or steady-state response.
The transient response of the boiler is computed using a first
order differential equation to compute the boiler's water and metal temperature,
which are lumped into one state. The boiler outlet temperature is equal to this water temperature.
</p>

</html>",       revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
October 9, 2013 by Michael Wetter:<br/>
Removed conditional declaration of <code>mDry</code> as the use of a conditional
parameter in an instance declaration is not correct Modelica syntax.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
December 22, 2011 by Michael Wetter:<br/>
Added computation of fuel usage and improved the documentation.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Removed parameter <code>dT_nominal</code>, and require instead
the parameter <code>m_flow_nominal</code> to be set by the user.
This was needed to avoid a non-literal value for the nominal attribute
of the pressure drop model.
</li>
<li>
Changed assignment of parameters in model instantiation, and updated
model for the new base class that does not have a temperature sensor.
</li>
</ul>
</li>
<li>
January 29, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end BoilerPolynomial;
    annotation (preferredView="info", Documentation(info="<html>
This package contains components models for boilers.
</html>"));
    end Boilers;

    package Delays "Package with delay models"
      extends Modelica.Icons.VariantsPackage;

      model DelayFirstOrder
        "Delay element, approximated by a first order differential equation"
        extends Buildings.Fluid.MixingVolumes.MixingVolume(final V=V_nominal);

        parameter Modelica.SIunits.Time tau = 60
          "Time constant at nominal flow"
          annotation (Dialog(tab="Dynamics", group="Nominal condition"));

      protected
         parameter Modelica.SIunits.Volume V_nominal = m_flow_nominal*tau/rho_default
          "Volume of delay element";
        annotation (    Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={Ellipse(
                extent={{-100,98},{100,-102}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={170,213,255}), Text(
                extent={{-72,22},{68,-18}},
                lineColor={0,0,0},
                textString="tau=%tau")}),
      defaultComponentName="del",
          Documentation(info="<html>
<p>
This model approximates a transport delay using a first order differential equations.
</p>
<p>
The model consists of a mixing volume with two ports. The size of the
mixing volume is such that at the nominal mass flow rate
<code>m_flow_nominal</code>,
the time constant of the volume is equal to the parameter <code>tau</code>.
</p>
<p>
The heat flux connector is optional, it need not be connnected.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 14, 2013, by Michael Wetter:<br/>
Renamed <code>V0</code> to <code>V_nominal</code> to use consistent notation.
</li>
<li>
September 24, 2008, by Michael Wetter:<br/>
Changed base class from <code>Modelica.Fluid</code> to <code>Buildings</code> library.
This was done to track the auxiliary species flow <code>mC_flow</code>.
</li>
<li>
September 4, 2008, by Michael Wetter:<br/>
Fixed bug in assignment of parameter <code>sta0</code>.
The earlier implementation
required temperature to be a state, which is not always the case.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end DelayFirstOrder;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains components models for transport delays in
piping networks.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.Delays.DelayFirstOrder\">
Buildings.Fluid.Delays.DelayFirstOrder</a>
approximates transport delays using a first order differential equation.
</p>
<p>
For a discretized model of a pipe or duct, see
<a href=\"modelica://Buildings.Fluid.FixedResistances.Pipe\">
Buildings.Fluid.FixedResistances.Pipe</a>.
</p>
</html>"));
    end Delays;

    package FixedResistances
      "Package with models for fixed flow resistances (pipes, diffusers etc.)"
      extends Modelica.Icons.VariantsPackage;

      model FixedResistanceDpM
        "Fixed flow resistance with dp and m_flow as parameter"
        extends Buildings.Fluid.BaseClasses.PartialResistance(
          final m_flow_turbulent = if (computeFlowResistance and use_dh) then
                             eta_default*dh/4*Modelica.Constants.pi*ReC
                             elseif (computeFlowResistance) then
                             deltaM * m_flow_nominal_pos
               else 0);
        parameter Boolean use_dh = false
          "Set to true to specify hydraulic diameter"
             annotation(Dialog(enable = not linearized));
        parameter Modelica.SIunits.Length dh=1 "Hydraulic diameter"
             annotation(Dialog(enable = use_dh and not linearized));
        parameter Real ReC(min=0)=4000
          "Reynolds number where transition to turbulent starts"
             annotation(Dialog(enable = use_dh and not linearized));
        parameter Real deltaM(min=0.01) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Dialog(enable = not use_dh and not linearized));

        final parameter Real k(unit="") = if computeFlowResistance then
              m_flow_nominal_pos / sqrt(dp_nominal_pos) else 0
          "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
      protected
        final parameter Boolean computeFlowResistance=(dp_nominal_pos > Modelica.Constants.eps)
          "Flag to enable/disable computation of flow resistance"
         annotation(Evaluate=true);
      initial equation
       if computeFlowResistance then
         assert(m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
       end if;

       assert(m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
       if ( m_flow_turbulent > m_flow_nominal_pos) then
         Modelica.Utilities.Streams.print("Warning: In FixedResistanceDpM, m_flow_nominal is smaller than m_flow_turbulent."
                 + "\n"
                 + "  m_flow_nominal = " + String(m_flow_nominal) + "\n"
                 + "  dh      = " + String(dh) + "\n"
                 + "  To fix, set dh < " +
                      String(     4*m_flow_nominal/eta_default/Modelica.Constants.pi/ReC) + "\n"
                 + "  Suggested value: dh = " +
                      String(1/10*4*m_flow_nominal/eta_default/Modelica.Constants.pi/ReC));
       end if;

      equation
        // Pressure drop calculation
        if computeFlowResistance then
          if linearized then
            m_flow*m_flow_nominal_pos = k^2*dp;
          else
            if homotopyInitialization then
              if from_dp then
                m_flow=homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                         m_flow_turbulent=m_flow_turbulent),
                                         simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                dp=homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k,
                                         m_flow_turbulent=m_flow_turbulent),
                          simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
               end if;  // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                         m_flow_turbulent=m_flow_turbulent);
              else
                dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k,
                                         m_flow_turbulent=m_flow_turbulent);
              end if;  // from_dp
            end if; // homotopyInitialization
          end if; // linearized
        else // do not compute flow resistance
          dp = 0;
        end if;  // computeFlowResistance

        annotation (defaultComponentName="res",
      Documentation(info="<html>
<p>
This is a model of a resistance with a fixed flow coefficient.
The mass flow rate is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
m&#775; = k
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>,
</p>
<p>
where
<i>k</i> is a constant and
<i>&Delta;P</i> is the pressure drop.
The constant <i>k</i> is equal to
<code>k=m_flow_nominal/sqrt(dp_nominal)</code>,
where <code>m_flow_nominal</code> and <code>dp_nominal</code>
are parameters.
In the region
<code>abs(m_flow) &lt; m_flow_turbulent</code>,
the square root is replaced by a differentiable function
with finite slope.
The value of <code>m_flow_turbulent</code> is
computed as follows:
</p>
<ul>
<li>
If the parameter <code>use_dh</code> is <code>false</code>
(the default setting),
the equation
<code>m_flow_turbulent = deltaM * abs(m_flow_nominal)</code>,
where <code>deltaM=0.3</code> and
<code>m_flow_nominal</code> are parameters that can be set by the user.
</li>
<li>
Otherwise, the equation
<code>m_flow_turbulent = eta_nominal*dh/4*&pi;*ReC</code> is used,
where
<code>eta_nominal</code> is the dynamic viscosity, obtained from
the medium model. The parameter
<code>dh</code> is the hydraulic diameter and
<code>ReC=4000</code> is the critical Reynolds number, which both
can be set by the user.
</li>
</ul>
<p>
The figure below shows the pressure drop for the parameters
<code>m_flow_nominal=5</code> kg/s,
<code>dp_nominal=10</code> Pa and
<code>deltaM=0.3</code>.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Fluid/FixedResistances/FixedResistanceDpM.png\"/>
</p>
<p>
If the parameter
<code>show_T</code> is set to <code>true</code>,
then the model will compute the
temperature at its ports. Note that this can lead to state events
when the mass flow rate approaches zero,
which can increase computing time.
</p>
<p>
The parameter <code>from_dp</code> is used to determine
whether the mass flow rate is computed as a function of the
pressure drop (if <code>from_dp=true</code>), or vice versa.
This setting can affect the size of the nonlinear system of equations.
</p>
<p>
If the parameter <code>linearized</code> is set to <code>true</code>,
then the pressure drop is computed as a linear function of the
mass flow rate.
</p>
<p>
Setting <code>allowFlowReversal=false</code> can lead to simpler
equations. However, this should only be set to <code>false</code>
if one can guarantee that the flow never reverses its direction.
This can be difficult to guarantee, as pressure imbalance after
the initialization, or due to medium expansion and contraction,
can lead to reverse flow.
</p>
<h4>Notes</h4>
<p>
For more detailed models that compute the actual flow friction,
models from the package
<a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
can be used and combined with models from the
<code>Buildings</code> library.
</p>
<h4>Implementation</h4>
<p>
The pressure drop is computed by calling a function in the package
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels\">
Buildings.Fluid.BaseClasses.FlowModels</a>,
This package contains regularized implementations of the equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
and its inverse function.
</p>
<p>
To decouple the energy equation from the mass equations,
the pressure drop is a function of the mass flow rate,
and not the volume flow rate.
This leads to simpler equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 5, 2014, by Michael Wetter:<br/>
Corrected error in documentation of computation of <code>k</code>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>Buildings.Fluid.BaseClasses.PartialResistance</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>Buildings.Fluid.FixedResistances.FixedResistanceDpM</code>.
</li>
<li>
May 30, 2008 by Michael Wetter:<br/>
Added parameters <code>use_dh</code> and <code>deltaM</code> for easier parameterization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-102,86},{-4,22}},
                lineColor={0,0,255},
                textString="dp_nominal=%dp_nominal"), Text(
                extent={{-106,106},{6,60}},
                lineColor={0,0,255},
                textString="m0=%m_flow_nominal")}));
      end FixedResistanceDpM;

      model Pipe "Pipe with finite volume discretization along flow path"
        extends Buildings.Fluid.FixedResistances.BaseClasses.Pipe(
         diameter=sqrt(4*m_flow_nominal/rho_default/v_nominal/Modelica.Constants.pi),
         dp_nominal=2*dpStraightPipe_nominal,
         res(dp(nominal=length*10)));
        // Because dp_nominal is a non-literal value, we set
        // dp.nominal=100 instead of the default dp.nominal=dp_nominal,
        // because the latter is ignored by Dymola 2012 FD 01.

        parameter Modelica.SIunits.Velocity v_nominal = 0.15
          "Velocity at m_flow_nominal (used to compute default diameter)";
        parameter Modelica.SIunits.Length roughness(min=0) = 2.5e-5
          "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
        final parameter Modelica.SIunits.Pressure dpStraightPipe_nominal=
            Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.pressureLoss_m_flow(
            m_flow=m_flow_nominal,
            rho_a=rho_default,
            rho_b=rho_default,
            mu_a=mu_default,
            mu_b=mu_default,
            length=length,
            diameter=diameter,
            roughness=roughness,
            m_flow_small=m_flow_small)
          "Pressure loss of a straight pipe at m_flow_nominal";

        parameter Boolean useMultipleHeatPorts=false
          "= true to use one heat port for each segment of the pipe, false to use a single heat port for the entire pipe";

        Modelica.Thermal.HeatTransfer.Components.ThermalConductor conPipWal[nSeg](
            each G=2*Modelica.Constants.pi*lambdaIns*length/nSeg/Modelica.Math.log((
              diameter/2.0 + thicknessIns)/(diameter/2.0)))
          "Thermal conductance through pipe wall"
          annotation (Placement(transformation(extent={{-28,-38},{-8,-18}})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector colAllToOne(m=nSeg) if
             not useMultipleHeatPorts
          "Connector to assign multiple heat ports to one heat port" annotation (
            Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=180,
              origin={-50,10})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort if not
          useMultipleHeatPorts
          "Single heat port that connects to outside of pipe wall (default, enabled when useMultipleHeatPorts=false)"
          annotation (Placement(transformation(extent={{-10,40},{10,20}}),
              iconTransformation(extent={{-10,60},{10,40}})));
        Modelica.Fluid.Interfaces.HeatPorts_a heatPorts[nSeg] if
             useMultipleHeatPorts
          "Multiple heat ports that connect to outside of pipe wall (enabled if useMultipleHeatPorts=true)"
          annotation (Placement(transformation(extent={{-10,-70},{11,-50}}),
              iconTransformation(extent={{-30,-60},{30,-40}})));
      equation

        connect(conPipWal.port_b, vol.heatPort) annotation (Line(
            points={{-8,-28},{-1,-28}},
            color={191,0,0},
            smooth=Smooth.None));
        if useMultipleHeatPorts then
          connect(heatPorts, conPipWal.port_a) annotation (Line(
              points={{0.5,-60},{-50,-60},{-50,-28},{-28,-28}},
              color={191,0,0},
              smooth=Smooth.None));
        else
          connect(colAllToOne.port_a, conPipWal.port_a) annotation (Line(
              points={{-50,4},{-50,-28},{-28,-28}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(colAllToOne.port_b, heatPort) annotation (Line(
              points={{-50,16},{-50,30},{5.55112e-16,30}},
              color={191,0,0},
              smooth=Smooth.None));

        end if;
        annotation (
          defaultComponentName="pip",
          Documentation(info="<html>
<p>
Model of a pipe with flow resistance and optional heat exchange with environment.
</p>
<p>
If <code>useMultipleHeatPorts=false</code> (default option), the pipe uses a single heat port
for the heat exchange with the environment.
If <code>useMultipleHeatPorts=true</code>, then one heat port for each segment of the pipe is
used for the heat exchange with the environment.
If the heat port is unconnected, then the pipe has no heat loss.
</p>
<p>
The default value for the parameter <code>diameter</code> is computed such that the flow velocity
is equal to <code>v_nominal=0.15</code> for a mass flow rate of <code>m_flow_nominal</code>.
Both parameters, <code>diameter</code> and <code>v_nominal</code>, can be overwritten
by the user.
The default value for <code>dp_nominal</code> is two times the pressure drop that the pipe
would have if it were straight with no fittings.
The factor of two that takes into account the pressure loss of fittings can be overwritten.
These fittings could also be explicitely modeled outside of this component using models from
the package
<a href=\"modelica://Modelica.Fluid.Fittings\">
Modelica.Fluid.Fittings</a>.
For mass flow rates other than <code>m_flow_nominal</code>, the model
<a href=\"modelica://Buildings.Fluid.FixedResistances.FixedResistanceDpM\">
Buildings.Fluid.FixedResistances.FixedResistanceDpM</a> is used to
compute the pressure drop.
</p>
<p>
For a steady-state model of a flow resistance, use
<a href=\"modelica://Buildings.Fluid.FixedResistances.FixedResistanceDpM\">
Buildings.Fluid.FixedResistances.FixedResistanceDpM</a> instead of this model.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 13, 2013 by Michael Wetter:<br/>
Replaced <code>nominal</code> with <code>default</code> values
as they are computed using the default Medium values.
</li>
<li>
February 22, 2012 by Michael Wetter:<br/>
Renamed <code>useMultipleHeatPort</code> to <code>useMultipleHeatPorts</code> and
used heat port connector from <code>Modelica.Fluid</code> package for vector of heat ports.
</li>
<li>
February 15, 2012 by Michael Wetter:<br/>
Revised implementation and added default values.
</li>
<li>
February 12, 2012 by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Pipe;

      package BaseClasses
      extends Modelica.Icons.BasesPackage;

        model Pipe
          "Model of a pipe with finite volume discretization along the flow path"
          extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
          extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
          showDesignFlowDirection = false,
          final show_T=true);
          extends Buildings.Fluid.Interfaces.TwoPortFlowResistanceParameters(
            final computeFlowResistance=(abs(dp_nominal) > Modelica.Constants.eps));

          parameter Integer nSeg(min=1) = 10 "Number of volume segments";
          parameter Modelica.SIunits.Length thicknessIns
            "Thickness of insulation";
          parameter Modelica.SIunits.ThermalConductivity lambdaIns
            "Heat conductivity of insulation";
          parameter Modelica.SIunits.Length diameter
            "Pipe diameter (without insulation)";

          parameter Modelica.SIunits.Length length "Length of the pipe";
          parameter Real ReC=4000
            "Reynolds number where transition to turbulent starts"
            annotation (Dialog(tab="Flow resistance"));

          parameter Boolean homotopyInitialization = true
            "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));

          Buildings.Fluid.FixedResistances.FixedResistanceDpM res(
            redeclare final package Medium = Medium,
            final from_dp=from_dp,
            use_dh=true,
            dh=diameter,
            final show_T=show_T,
            final m_flow_nominal=m_flow_nominal,
            final dp_nominal=dp_nominal,
            final allowFlowReversal=allowFlowReversal,
            final linearized=linearizeFlowResistance,
            final ReC=ReC,
            final homotopyInitialization=homotopyInitialization)
            "Flow resistance"            annotation (Placement(transformation(extent={{-30,-10},
                    {-10,10}})));
          Buildings.Fluid.MixingVolumes.MixingVolume[nSeg] vol(
            redeclare each final package Medium = Medium,
            each energyDynamics=energyDynamics,
            each massDynamics=massDynamics,
            each final V=VPipe/nSeg,
            each nPorts=2,
            each final m_flow_nominal=m_flow_nominal,
            each prescribedHeatFlowRate=true,
            each p_start=p_start,
            each T_start=T_start,
            each X_start=X_start,
            each C_start=C_start,
            each C_nominal=C_nominal,
            each final m_flow_small=m_flow_small,
            each final allowFlowReversal=allowFlowReversal)
            "Volume for pipe fluid"                       annotation (Placement(
                transformation(extent={{-1,-18},{19,-38}})));

        protected
          parameter Modelica.SIunits.Volume VPipe=Modelica.Constants.pi*(diameter/2.0)^
              2*length "Pipe volume";
          parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
              T=Medium.T_default,
              p=Medium.p_default,
              X=Medium.X_default[1:Medium.nXi]) "Default state";
          parameter Modelica.SIunits.Density rho_default = Medium.density(state_default);
          parameter Modelica.SIunits.DynamicViscosity mu_default = Medium.dynamicViscosity(state_default)
            "Dynamic viscosity at nominal condition";
        equation
          connect(port_a, res.port_a) annotation (Line(
              points={{-100,5.55112e-16},{-72,5.55112e-16},{-72,1.16573e-15},{-58,
                  1.16573e-15},{-58,6.10623e-16},{-30,6.10623e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(res.port_b, vol[1].ports[1]) annotation (Line(
              points={{-10,6.10623e-16},{7,6.10623e-16},{7,-18}},
              color={0,127,255},
              smooth=Smooth.None));
          if nSeg > 1 then
            for i in 1:(nSeg - 1) loop
              connect(vol[i].ports[2], vol[i + 1].ports[1]);
            end for;
          end if;
          connect(vol[nSeg].ports[2], port_b) annotation (Line(
              points={{11,-18},{12,-18},{12,5.55112e-16},{100,5.55112e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          annotation (
            Icon(graphics={
                Rectangle(
                  extent={{-100,60},{100,-60}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,50},{100,-48}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={217,236,256}),
                Text(
                  extent={{-42,12},{40,-12}},
                  lineColor={0,0,0},
                  textString="%nSeg")}),
            Documentation(info="<html>
<p>
Model of a pipe with flow resistance and optional heat storage.
This model can be used for modeling the heat exchange between the pipe and environment.
The model consists of a flow resistance
<a href=\"modelica://Buildings.Fluid.FixedResistances.FixedResistanceDpM\">
Buildings.Fluid.FixedResistances.FixedResistanceDpM</a>
and <code>nSeg</code> mixing volumes
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 10, 2014, by Michael Wetter:<br/>
Changed minimum attribute for <code>nSeg</code> from 2 to 1.
This is required for the radiant slab model.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
September 13, 2013 by Michael Wetter:<br/>
Replaced <code>nominal</code> with <code>default</code> values
as they are computed using the default Medium values.
</li>
<li>
February 15, 2012 by Michael Wetter:<br/>
Changed base class from which the model extends.
Propagated parameters of volume to the top if this model.
</li>
<li>
February 12, 2012 by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Pipe;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.FixedResistances\">Buildings.Fluid.FixedResistances</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains components models for fixed flow resistances.
By fixed flow resistance, we mean resistances that do not change the
flow coefficient
<p align=\"center\" style=\"font-style:italic;\">
k = m &frasl;
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>.
</p>
<p>
For models of valves and air dampers, see
<a href=\"modelica://Buildings.Fluid.Actuators\">
Buildings.Fluid.Actuators</a>.
For models of flow resistances as part of the building constructions, see
<a href=\"modelica://Buildings.Airflow.Multizone\">
Buildings.Airflow.Multizone</a>.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.FixedResistanceDpM\">
Buildings.Fluid.FixedResistances.FixedResistanceDpM</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and a nominal pressure drop. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.LosslessPipe\">
Buildings.Fluid.FixedResistances.LosslessPipe</a>
is an ideal pipe segment with no pressure drop. It is primarily used
in models in which the above pressure drop model need to be replaced by a model with no pressure drop.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM\">
Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM</a>
can be used to model flow splitters or flow merges.
</p>
</html>"));
    end FixedResistances;

    package HeatExchangers "Package with heat exchanger models"
      extends Modelica.Icons.VariantsPackage;

      package Radiators
        "Package with radiators models for hydronic space heating systems"
        extends Modelica.Icons.VariantsPackage;

        model RadiatorEN442_2 "Dynamic radiator for space heating"
           extends Fluid.Interfaces.PartialTwoPortInterface(
           showDesignFlowDirection = false,
           show_T=true,
           m_flow_nominal=abs(Q_flow_nominal/cp_nominal/(T_a_nominal-T_b_nominal)));
           extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations(
             final X_start = Medium.X_default,
             final C_start = fill(0, Medium.nC),
             final C_nominal = fill(1E-2, Medium.nC),
             final mFactor = 1 + 500*mDry/(VWat*cp_nominal*Medium.density(
                Medium.setState_pTX(Medium.p_default, Medium.T_default, Medium.X_default))));

          parameter Integer nEle(min=1) = 5
            "Number of elements used in the discretization";
          parameter Real fraRad(min=0, max=1) = 0.35
            "Fraction radiant heat transfer";
          // Assumptions

          parameter Modelica.SIunits.Power Q_flow_nominal
            "Nominal heating power (positive for heating)"
            annotation(Dialog(group="Nominal condition"));
          parameter Modelica.SIunits.Temperature T_a_nominal
            "Water inlet temperature at nominal condition"
            annotation(Dialog(group="Nominal condition"));
          parameter Modelica.SIunits.Temperature T_b_nominal
            "Water outlet temperature at nominal condition"
            annotation(Dialog(group="Nominal condition"));
          parameter Modelica.SIunits.Temperature TAir_nominal = 293.15
            "Air temperature at nominal condition"
            annotation(Dialog(group="Nominal condition"));
          parameter Modelica.SIunits.Temperature TRad_nominal = TAir_nominal
            "Radiative temperature at nominal condition"
            annotation(Dialog(group="Nominal condition"));

          parameter Real n = 1.24 "Exponent for heat transfer";
          parameter Modelica.SIunits.Volume VWat = 5.8E-6*abs(Q_flow_nominal)
            "Water volume of radiator"
            annotation(Dialog(tab = "Dynamics", enable = not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)));
          parameter Modelica.SIunits.Mass mDry = 0.0263*abs(Q_flow_nominal)
            "Dry mass of radiator that will be lumped to water heat capacity"
            annotation(Dialog(tab = "Dynamics", enable = not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)));
          parameter Boolean homotopyInitialization = true
            "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));

          // Heat flow rates
          Modelica.SIunits.HeatFlowRate QCon_flow = heatPortCon.Q_flow
            "Heat input into the water due to convective heat transfer with room air";
          Modelica.SIunits.HeatFlowRate QRad_flow = heatPortRad.Q_flow
            "Heat input into the water due to radiative heat transfer with room";
          Modelica.SIunits.HeatFlowRate Q_flow = QCon_flow + QRad_flow
            "Heat input into the water";

          // Heat ports
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPortCon
            "Heat port for convective heat transfer with room air temperature"
            annotation (Placement(transformation(extent={{-30,62},{-10,82}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPortRad
            "Heat port for radiative heat transfer with room radiation temperature"
            annotation (Placement(transformation(extent={{10,62},{30,82}})));

          Fluid.MixingVolumes.MixingVolume[nEle] vol(
            redeclare each package Medium = Medium,
            each nPorts = 2,
            each V=VWat/nEle,
            each final m_flow_nominal = m_flow_nominal,
            each final energyDynamics=energyDynamics,
            each final massDynamics=energyDynamics,
            each final p_start=p_start,
            each final T_start=T_start,
            each final X_start=X_start,
            each final C_start=C_start,
            each final mFactor=mFactor) "Volume for fluid stream"
            annotation (Placement(transformation(extent={{-9,0},{11,-20}})));
        protected
           parameter Modelica.SIunits.SpecificHeatCapacity cp_nominal=
              Medium.specificHeatCapacityCp(
                Medium.setState_pTX(Medium.p_default, T_a_nominal, Medium.X_default))
            "Specific heat capacity at nominal conditions";
           parameter Modelica.SIunits.HeatFlowRate QEle_flow_nominal[nEle](
              each fixed=false, each start=Q_flow_nominal/nEle)
            "Nominal heating power of each element";
           parameter Modelica.SIunits.Temperature TWat_nominal[nEle](
              each fixed=false,
              start={T_a_nominal - i/nEle * (T_a_nominal-T_b_nominal) for i in 1:nEle})
            "Water temperature in each element at nominal conditions";
           parameter Modelica.SIunits.TemperatureDifference[nEle] dTRad_nominal(
            each fixed=false, start={T_a_nominal - i/nEle * (T_a_nominal-T_b_nominal) - TRad_nominal
            for i in 1:nEle})
            "Temperature difference for radiative heat transfer at nominal conditions";
           parameter Modelica.SIunits.TemperatureDifference[nEle] dTCon_nominal(
            each fixed=false, start={T_a_nominal - i/nEle * (T_a_nominal-T_b_nominal) - TAir_nominal
            for i in 1:nEle})
            "Temperature difference for convective heat transfer at nominal conditions";

           parameter Modelica.SIunits.ThermalConductance UAEle(fixed=false, min=0,
             start=Q_flow_nominal/((T_a_nominal+T_b_nominal)/2-((1-fraRad)*TAir_nominal+fraRad*TRad_nominal))/nEle)
            "UA value at nominal condition for each element";

           final parameter Real k = if T_b_nominal > TAir_nominal then 1 else -1
            "Parameter that is used to compute QEle_flow_nominal for heating or cooling mode";

           Buildings.HeatTransfer.Sources.PrescribedHeatFlow[nEle] preCon
            "Heat input into radiator from convective heat transfer"
             annotation (Placement(transformation(extent={{-48,-48},{-28,-28}})));
           Buildings.HeatTransfer.Sources.PrescribedHeatFlow[nEle] preRad
            "Heat input into radiator from radiative heat transfer"
             annotation (Placement(transformation(extent={{-48,-80},{-28,-60}})));

           Modelica.SIunits.TemperatureDifference dTCon[nEle] = heatPortCon.T .- vol.T
            "Temperature difference for convective heat transfer";
           Modelica.SIunits.TemperatureDifference dTRad[nEle] = heatPortRad.T .- vol.T
            "Temperature difference for radiative heat transfer";

          Modelica.Blocks.Sources.RealExpression QCon[nEle](y=if homotopyInitialization
                 then homotopy(actual=(1 - fraRad) .* UAEle .* dTCon .*
                Buildings.Utilities.Math.Functions.regNonZeroPower(
                x=dTCon,
                n=n - 1,
                delta=0.05), simplified=(1 - fraRad) .* UAEle .* abs(dTCon_nominal) .^ (
                n - 1) .* dTCon) else (1 - fraRad) .* UAEle .* dTCon .*
                Buildings.Utilities.Math.Functions.regNonZeroPower(
                x=dTCon,
                n=n - 1,
                delta=0.05)) "Convective heat flow rate"
            annotation (Placement(transformation(extent={{-100,-48},{-80,-28}})));

          Modelica.Blocks.Sources.RealExpression QRad[nEle](y=if homotopyInitialization
                 then homotopy(actual=fraRad .* UAEle .* dTRad .*
                Buildings.Utilities.Math.Functions.regNonZeroPower(
                x=dTRad,
                n=n - 1,
                delta=0.05), simplified=fraRad .* UAEle .* abs(dTRad_nominal) .^ (n - 1)
                 .* dTRad) else fraRad .* UAEle .* dTRad .*
                Buildings.Utilities.Math.Functions.regNonZeroPower(
                x=dTRad,
                n=n - 1,
                delta=0.05)) "Convective heat flow rate"
            annotation (Placement(transformation(extent={{-100,-80},{-80,-60}})));

          Buildings.HeatTransfer.Sources.PrescribedHeatFlow preSumCon
            "Heat input into radiator from convective heat transfer"
            annotation (Placement(transformation(extent={{52,-60},{72,-40}})));
          Modelica.Blocks.Math.Sum sumCon(nin=nEle, k=-ones(nEle))
            "Sum of convective heat flow rate"
            annotation (Placement(transformation(extent={{20,-60},{40,-40}})));
          Modelica.Blocks.Math.Sum sumRad(nin=nEle, k=-ones(nEle))
            "Sum of radiative heat flow rate"
            annotation (Placement(transformation(extent={{20,-90},{40,-70}})));
          Buildings.HeatTransfer.Sources.PrescribedHeatFlow preSumRad
            "Heat input into radiator from convective heat transfer"
            annotation (Placement(transformation(extent={{52,-90},{72,-70}})));
        initial equation
          if T_b_nominal > TAir_nominal then
             assert(T_a_nominal > T_b_nominal,
               "In RadiatorEN442_2, T_a_nominal must be higher than T_b_nominal");
             assert(Q_flow_nominal > 0,
               "In RadiatorEN442_2, nominal power must be bigger than zero if T_b_nominal > TAir_nominal");
          else
             assert(T_a_nominal < T_b_nominal,
               "In RadiatorEN442_2, T_a_nominal must be lower than T_b_nominal");
             assert(Q_flow_nominal < 0,
               "In RadiatorEN442_2, nominal power must be smaller than zero if T_b_nominal < TAir_nominal");
          end if;
          TWat_nominal[1] = T_a_nominal - QEle_flow_nominal[1]/m_flow_nominal/
          Medium.specificHeatCapacityCp(
                Medium.setState_pTX(Medium.p_default, T_a_nominal, Medium.X_default));
          for i in 2:nEle loop
            TWat_nominal[i] = TWat_nominal[i-1] - QEle_flow_nominal[i]/m_flow_nominal/
            Medium.specificHeatCapacityCp(
                Medium.setState_pTX(Medium.p_default, TWat_nominal[i-1], Medium.X_default));
          end for;
          dTRad_nominal = TWat_nominal .- TRad_nominal;
          dTCon_nominal = TWat_nominal .- TAir_nominal;
          Q_flow_nominal = sum(QEle_flow_nominal);

          for i in 1:nEle loop
            QEle_flow_nominal[i] = k * UAEle * ((1-fraRad) *
                           Buildings.Utilities.Math.Functions.powerLinearized(x=k*dTRad_nominal[i],
                           n=n,
                           x0=0.1*k*(T_b_nominal-TRad_nominal))
                           + fraRad *
                           Buildings.Utilities.Math.Functions.powerLinearized(x=k*dTCon_nominal[i],
                           n=n,
                           x0=0.1*k*(T_b_nominal-TAir_nominal)));
           end for;

        equation
          connect(preCon.port, vol.heatPort)       annotation (Line(
              points={{-28,-38},{-20,-38},{-20,-10},{-9,-10}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(preRad.port, vol.heatPort)       annotation (Line(
              points={{-28,-70},{-20,-70},{-20,-10},{-9,-10}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(port_a, vol[1].ports[1]) annotation (Line(
              points={{-100,5.55112e-16},{-75.25,5.55112e-16},{-75.25,1.11022e-15},{
                  -50.5,1.11022e-15},{-50.5,5.55112e-16},{-1,5.55112e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(vol[nEle].ports[2], port_b) annotation (Line(
              points={{3,5.55112e-16},{27.25,5.55112e-16},{27.25,1.11022e-15},{51.5,
                  1.11022e-15},{51.5,5.55112e-16},{100,5.55112e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          for i in 1:nEle-1 loop
            connect(vol[i].ports[2], vol[i+1].ports[1]) annotation (Line(
                points={{3,5.55112e-16},{2,5.55112e-16},{2,1.11022e-15},{1,1.11022e-15},
                    {1,5.55112e-16},{-1,5.55112e-16}},
                color={0,127,255},
                smooth=Smooth.None));
          end for;
          connect(QCon.y, preCon.Q_flow)                  annotation (Line(
              points={{-79,-38},{-48,-38}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sumCon.u, QCon.y)          annotation (Line(
              points={{18,-50},{-60,-50},{-60,-38},{-79,-38}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sumCon.y, preSumCon.Q_flow)     annotation (Line(
              points={{41,-50},{52,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(preSumCon.port, heatPortCon)       annotation (Line(
              points={{72,-50},{80,-50},{80,40},{-20,40},{-20,72}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(QRad.y, preRad.Q_flow)       annotation (Line(
              points={{-79,-70},{-48,-70}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(QRad.y, sumRad.u) annotation (Line(
              points={{-79,-70},{-60,-70},{-60,-80},{18,-80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sumRad.y, preSumRad.Q_flow)        annotation (Line(
              points={{41,-80},{52,-80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(preSumRad.port, heatPortRad)        annotation (Line(
              points={{72,-80},{86,-80},{86,50},{20,50},{20,72}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation ( Icon(graphics={
                Ellipse(
                  extent={{-20,22},{20,-20}},
                  fillColor={127,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-95,6},{106,-4}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-102,-4},{-2,6}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-20,22},{20,-20}},
                  fillColor={127,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-80,60},{80,-60}},
                  lineColor={0,0,0},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-66,30},{66,30}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-66,2},{66,2}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-66,-30},{66,-30}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-66,60},{-66,-60}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{66,60},{66,-60}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
            defaultComponentName="rad",
            Documentation(info="<html>
<p>
This is a model of a radiator that can be used as a dynamic or steady-state model.
The required parameters are data that are typically available from
manufacturers that follow the European Norm EN 442-2.
</p>
<p>
However, to allow for varying mass flow rates, the transferred heat is computed
using a discretization along the water flow path, and heat is exchanged between
each compartment and a uniform room air and radiation temperature.
This discretization is different from the computation in EN 442-2, which
may yield water outlet temperatures that are below
the room temperature at low mass flow rates.
Furthermore, rather than using only one room temperature, this model uses
a room air and room radiation temperature.
</p>
<p>
The transferred heat is modeled as follows:
Let <i>N</i> denote the number of elements used to discretize the radiator model.
For each element <i>i &isin; {1, &hellip; , N}</i>,
the convective and radiative heat transfer
<i>Q<sup>i</sup><sub>c</sub></i> and
<i>Q<sup>i</sup><sub>r</sub></i>
from the radiator to the room is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q<sup>i</sup><sub>c</sub> = sign(T<sup>i</sup>-T<sub>a</sub>)
     (1-f<sub>r</sub>) UA &frasl; N |T<sup>i</sup>-T<sub>a</sub>|<sup>n</sup>
  <br/> <br/>
  Q<sup>i</sup><sub>r</sub> = sign(T<sup>i</sup>-T<sub>r</sub>)
     f<sub>r</sub> UA &frasl; N |T<sup>i</sup>-T<sub>r</sub>|<sup>n</sup>
</p>
<p>
where
<i>T<sup>i</sup></i> is the water temperature of the element,
<i>T<sub>a</sub></i> is the temperature of the room air,
<i>T<sub>r</sub></i> is the radiative temperature,
<i>0 &lt; f<sub>r</sub> &lt; 1</i> is the fraction of radiant to total heat transfer,
<i>UA</i> is the UA-value of the radiator,
and
<i>n</i> is an exponent for the heat transfer.
The model computes the UA-value by numerically solving the above equations
for given
nominal heating power, nominal temperatures, fraction radiant to total heat transfer
and exponent for heat transfer.
</p>
<p>
The parameter <code>energyDynamics</code> (in the Assumptions tab),
determines whether the model computes the dynamic or the steady-state response.
For the transient response, heat storage is computed using a
finite volume approach for the
water and the metal mass, which are both assumed to be at the same
temperature.
</p>
<p>
The default parameters for the heat capacities are valid for a flat plate radiator without fins,
with one plate of water carying fluid, and a height of 0.42 meters.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 29, 2014, by Michael Wetter:<br/>
Made assignment of <code>mFactor</code> final, and changed computation of
density to use default medium states as are also used to compute the
specific heat capacity.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> and removed thermal capacity
which can lead to an index reduction.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed conditional statement in the declaration of the parameter
<code>mDry</code>, as this is incorrect syntax.
</li>
<li>
September 26, 2013 by Michael Wetter:<br/>
Reformulated implementation to avoid mixing textual and graphical
declarations in the <code>equation</code> section.
</li>
<li>
April 4, 2011 by Michael Wetter:<br/>
Changed the implementation to use
<a href=\"modelica://Buildings.Utilities.Math.Functions.regNonZeroPower\">
Buildings.Utilities.Math.Functions.regNonZeroPower</a>.
This allows formulating the model without any non-differentiable function
inside the equation section.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
February 11, 2011 by Michael Wetter:<br/>
Revised the initialization to ensure that at the nominal conditions, the
amount of transferred heat is excatly the same as the specified nominal power.
In the previous implementation, the UA-value was computed using a simplified
expression for the temperature difference, leading to a slightly different amount
of heat transfer.
</li>
<li>
February 4, 2011 by Michael Wetter:<br/>
Simplified implementation.
</li>
<li>
January 30, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end RadiatorEN442_2;
      annotation (preferredView="info", Documentation(info="<html>
This package contains models for radiators that are typically found in hydronic heating systems.
</html>"));
      end Radiators;
    annotation (preferredView="info", Documentation(info="<html>
This package contains models for heat exchangers with and without humidity condensation.
</html>"));
    end HeatExchangers;

    package MixingVolumes "Package with mixing volumes"
      extends Modelica.Icons.VariantsPackage;

      model MixingVolume
        "Mixing volume with inlet and outlet ports (flow reversal is allowed)"
        extends Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume;
      protected
        Modelica.Blocks.Sources.Constant masExc(k=0)
          "Block to set mass exchange in volume"
          annotation (Placement(transformation(extent={{-80,50},{-60,70}})));
      equation
        connect(masExc.y, dynBal.mWat_flow) annotation (Line(
            points={{-59,60},{20,60},{20,12},{38,12}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(masExc.y, steBal.mWat_flow) annotation (Line(
            points={{-59,60},{-40,60},{-40,14},{-22,14}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(QSen_flow.y, steBal.Q_flow) annotation (Line(
            points={{-59,88},{-30,88},{-30,18},{-22,18}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(QSen_flow.y, dynBal.Q_flow) annotation (Line(
            points={{-59,88},{28,88},{28,16},{38,16}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
      defaultComponentName="vol",
      Documentation(info="<html>
<p>
This model represents an instantaneously mixed volume.
Potential and kinetic energy at the port are neglected,
and there is no pressure drop at the ports.
The volume can exchange heat through its <code>heatPort</code>.
</p>
<p>
The volume can be parameterized as a steady-state model or as
dynamic model.</p>
<p>
To increase the numerical robustness of the model, the parameter
<code>prescribedHeatFlowRate</code> can be set by the user.
This parameter only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if there is a model connected to <code>heatPort</code>
that computes the heat flow rate <i>not</i> as a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
</li>
<li>Set <code>prescribedHeatFlowRate=true</code> if the only means of heat flow at the <code>heatPort</code>
is computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.
</li>
</ul>

<h4>Implementation</h4>
<p>
If the model is operated in steady-state and has two fluid ports connected,
then the same energy and mass balance implementation is used as in
steady-state component models, i.e., the use of <code>actualStream</code>
is not used for the properties at the port.
</p>
<p>
The implementation of these balance equations is done in the instances
<code>dynBal</code> for the dynamic balance and <code>steBal</code>
for the steady-state balance. Both models use the same input variables:
</p>
<ul>
<li>
The variable <code>Q_flow</code> is used to add sensible <i>and</i> latent heat to the fluid.
For example, <code>Q_flow</code> participates in the steady-state energy balance<pre>
    port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
</pre>
where <code>m_flowInv</code> approximates the expression <code>1/m_flow</code>.
</li>
<li>
The variable <code>mXi_flow</code> is used to add a species mass flow rate to the fluid.
</li>
</ul>

<p>
For simple models that uses this model, see
<a href=\"modelica://Buildings.Fluid.HeatExchangers.HeaterCoolerPrescribed\">
Buildings.Fluid.HeatExchangers.HeaterCoolerPrescribed</a> and
<a href=\"modelica://Buildings.Fluid.MassExchangers.HumidifierPrescribed\">
Buildings.Fluid.MassExchangers.HumidifierPrescribed</a>.
</p>

</html>",       revisions="<html>
<ul>
<li>
February 11, 2014 by Michael Wetter:<br/>
Redesigned implementation of latent and sensible heat flow rates
as port of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>Buildings.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Ellipse(
                extent={{-100,98},{100,-102}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={170,213,255}), Text(
                extent={{-58,14},{58,-18}},
                lineColor={0,0,0},
                textString="V=%V"),         Text(
                extent={{-152,100},{148,140}},
                textString="%name",
                lineColor={0,0,255})}));
      end MixingVolume;

      package BaseClasses
        "Package with base classes for Buildings.Fluid.MixingVolumes"
        extends Modelica.Icons.BasesPackage;

        partial model PartialMixingVolume
          "Partial mixing volume with inlet and outlet ports (flow reversal is allowed)"

          extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
            "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          // Port definitions
          parameter Integer nPorts=0 "Number of ports"
            annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
          parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
            "Small mass flow rate for regularization of zero flow"
            annotation(Dialog(tab = "Advanced"));
          parameter Boolean allowFlowReversal = true
            "= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports."
            annotation(Dialog(tab="Assumptions"), Evaluate=true);
          parameter Modelica.SIunits.Volume V "Volume";
          parameter Boolean prescribedHeatFlowRate=false
            "Set to true if the model has a prescribed heat flow at its heatPort"
           annotation(Evaluate=true, Dialog(tab="Assumptions",
              enable=use_HeatTransfer,
              group="Heat transfer"));
          parameter Boolean initialize_p = not Medium.singleState
            "= true to set up initial equations for pressure";
          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
              redeclare each package Medium = Medium)
            "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{-40,-10},{40,10}},
              origin={0,-100})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
            "Heat port for sensible heat input"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Modelica.SIunits.Temperature T "Temperature of the fluid";
          Modelica.SIunits.Pressure p "Pressure of the fluid";
          Modelica.SIunits.MassFraction Xi[Medium.nXi]
            "Species concentration of the fluid";
          Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)
            "Trace substance mixture content";
           // Models for the steady-state and dynamic energy balance.
        protected
          Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation steBal(
            sensibleOnly = true,
            redeclare final package Medium=Medium,
            final m_flow_nominal = m_flow_nominal,
            final allowFlowReversal = allowFlowReversal,
            final m_flow_small = m_flow_small) if
                useSteadyStateTwoPort
            "Model for steady-state balance if nPorts=2"
                annotation (Placement(transformation(extent={{-20,0},{0,20}})));
          Buildings.Fluid.Interfaces.ConservationEquation dynBal(
            redeclare final package Medium = Medium,
            final energyDynamics=energyDynamics,
            final massDynamics=massDynamics,
            final p_start=p_start,
            final T_start=T_start,
            final X_start=X_start,
            final C_start=C_start,
            final C_nominal=C_nominal,
            final fluidVolume = V,
            final initialize_p = initialize_p,
            m(start=V*rho_start),
            U(start=V*rho_start*Medium.specificInternalEnergy(
                state_start)),
            nPorts=nPorts,
            final mFactor=mFactor) if
                not useSteadyStateTwoPort "Model for dynamic energy balance"
            annotation (Placement(transformation(extent={{40,0},{60,20}})));

          // Density at medium default values, used to compute the size of control volumes
          parameter Modelica.SIunits.Density rho_default=Medium.density(
            state=state_default) "Density, used to compute fluid mass";
          // Density at start values, used to compute initial values and start guesses
          parameter Modelica.SIunits.Density rho_start=Medium.density(
           state=state_start) "Density, used to compute start and guess values";

          final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
              T=Medium.T_default,
              p=Medium.p_default,
              X=Medium.X_default[1:Medium.nXi])
            "Medium state at default values";
          final parameter Medium.ThermodynamicState state_start = Medium.setState_pTX(
              T=T_start,
              p=p_start,
              X=X_start[1:Medium.nXi]) "Medium state at start values";
          final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
              prescribedHeatFlowRate and (
              energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
            "Flag, true if the model has two ports only and uses a steady state balance"
            annotation (Evaluate=true);
          // Outputs that are needed to assign the medium properties
          Modelica.Blocks.Interfaces.RealOutput hOut_internal(unit="J/kg")
            "Internal connector for leaving temperature of the component";
          Modelica.Blocks.Interfaces.RealOutput XiOut_internal[Medium.nXi](each unit="1")
            "Internal connector for leaving species concentration of the component";
          Modelica.Blocks.Interfaces.RealOutput COut_internal[Medium.nC](each unit="1")
            "Internal connector for leaving trace substances of the component";

          Modelica.Blocks.Sources.RealExpression QSen_flow(y=heatPort.Q_flow)
            "Block to set sensible heat input into volume"
            annotation (Placement(transformation(extent={{-60,78},{-40,98}})));

        equation
          ///////////////////////////////////////////////////////////////////////////
          // asserts
          if not allowFlowReversal then
            assert(ports[1].m_flow > -m_flow_small,
        "Model has flow reversal, but the parameter allowFlowReversal is set to false.
  m_flow_small    = "         + String(m_flow_small) + "
  ports[1].m_flow = "         + String(ports[1].m_flow) + "
");
          end if;
          // Actual definition of port variables.
          //
          // If the model computes the energy and mass balances as steady-state,
          // and if it has only two ports,
          // then we use the same base class as for all other steady state models.
          if useSteadyStateTwoPort then
          connect(steBal.port_a, ports[1]) annotation (Line(
              points={{-20,10},{-22,10},{-22,-60},{0,-60},{0,-100}},
              color={0,127,255},
              smooth=Smooth.None));

          connect(steBal.port_b, ports[2]) annotation (Line(
              points={{5.55112e-16,10},{8,10},{8,10},{8,-88},{0,-88},{0,-100}},
              color={0,127,255},
              smooth=Smooth.None));

            connect(hOut_internal,  steBal.hOut);
            connect(XiOut_internal, steBal.XiOut);
            connect(COut_internal,  steBal.COut);
          else
              connect(dynBal.ports, ports) annotation (Line(
              points={{50,-5.55112e-16},{50,-34},{2.22045e-15,-34},{2.22045e-15,-100}},
              color={0,127,255},
              smooth=Smooth.None));

            connect(hOut_internal,  dynBal.hOut);
            connect(XiOut_internal, dynBal.XiOut);
            connect(COut_internal,  dynBal.COut);
          end if;
          // Medium properties
          p = if nPorts > 0 then ports[1].p else p_start;
          T = Medium.temperature_phX(p=p, h=hOut_internal, X=cat(1,Xi,{1-sum(Xi)}));
          Xi = XiOut_internal;
          C = COut_internal;
          // Port properties
          heatPort.T = T;

          annotation (
        defaultComponentName="vol",
        Documentation(info="<html>
<p>
This is a partial model of an instantaneously mixed volume.
It is used as the base class for all fluid volumes of the package
<a href=\"modelica://Buildings.Fluid.MixingVolumes\">
Buildings.Fluid.MixingVolumes</a>.
</p>

<h4>Implementation</h4>
<p>
If the model is operated in steady-state and has two fluid ports connected,
then the same energy and mass balance implementation is used as in
steady-state component models, i.e., the use of <code>actualStream</code>
is not used for the properties at the port.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://Buildings.Fluid.MixingVolumes\">
Buildings.Fluid.MixingVolumes</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 29, 2014, by Michael Wetter:<br/>
Made assignment of <code>mFactor</code> final, and changed computation of
density to use default medium states as are also used to compute the
specific heat capacity.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Removed <code>Q_flow</code> and added <code>QSen_flow</code>.
This was done to clarify what is sensible and total heat flow rate
as part of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to instance <code>steBal</code> as it has no longer this parameter.
</li>
<li>
September 13, 2013 by Michael Wetter:<br/>
Renamed <code>rho_nominal</code> to <code>rho_start</code>
because this quantity is computed using start values and not
nominal values.
</li>
<li>
April 18, 2013 by Michael Wetter:<br/>
Removed the check of multiple connections to the same element
of a fluid port, as this check required the use of the deprecated
<code>cardinality</code> function.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>Buildings.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
This implementation also simplifies the implementation of
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort\">
Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</a>,
which now uses the same equations as this model.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Ellipse(
                  extent={{-100,98},{100,-102}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={170,213,255}), Text(
                  extent={{-58,14},{58,-18}},
                  lineColor={0,0,0},
                  textString="V=%V"),         Text(
                  extent={{-152,100},{148,140}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end PartialMixingVolume;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.MixingVolumes\">Buildings.Fluid.MixingVolumes</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package contains models for completely mixed volumes.
</p>
<p>
For most situations, the model
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a> should be used.
The other models are only of interest if water should be added to
or subtracted from the fluid volume, such as in a
coil with water vapor condensation.
</p>
</html>"));
    end MixingVolumes;

    package Movers "Package with fan and pump models"
      extends Modelica.Icons.VariantsPackage;

      model FlowMachine_dp
        "Fan or pump with ideally controlled head dp as input signal"
        extends Buildings.Fluid.Movers.BaseClasses.ControlledFlowMachine(
        final control_m_flow = false,
        preSou(
            dp_start=dp_start));

        // Classes used to implement the filtered speed
        parameter Boolean filteredSpeed=true
          "= true, if speed is filtered with a 2nd order CriticalDamping filter"
          annotation(Dialog(tab="Dynamics", group="Filtered speed"));
        parameter Modelica.SIunits.Time riseTime=30
          "Rise time of the filter (time to reach 99.6 % of the speed)"
          annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=filteredSpeed));
        parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.InitialOutput
          "Type of initialization (no init/steady state/initial state/initial output)"
          annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=filteredSpeed));
        parameter Modelica.SIunits.Pressure dp_start(min=0, displayUnit="Pa")=0
          "Initial value of pressure raise"
          annotation(Dialog(tab="Dynamics", group="Filtered speed"));
        parameter Modelica.SIunits.Pressure dp_nominal(min=0, displayUnit="Pa")=10000
          "Nominal pressure raise, used to normalize filter"
          annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=filteredSpeed));
        Modelica.Blocks.Interfaces.RealInput dp_in(min=0, final unit="Pa")
          "Prescribed pressure rise"
          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120}),  iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={-2,120})));

        Modelica.Blocks.Interfaces.RealOutput dp_actual(min=0, final unit="Pa")
          annotation (Placement(transformation(extent={{100,40},{120,60}}),
              iconTransformation(extent={{100,40},{120,60}})));

      protected
        Modelica.Blocks.Math.Gain gain(final k=-1)
          annotation (Placement(transformation(extent={{-20,60},{0,80}})));
        Modelica.Blocks.Continuous.Filter filter(
           order=2,
           f_cut=5/(2*Modelica.Constants.pi*riseTime),
           final init=init,
           final y_start=dp_start,
           u_nominal=abs(dp_nominal),
           x(each stateSelect=StateSelect.always),
           u(final unit="Pa"),
           y(final unit="Pa"),
           final analogFilter=Modelica.Blocks.Types.AnalogFilter.CriticalDamping,
           final filterType=Modelica.Blocks.Types.FilterType.LowPass) if filteredSpeed
          "Second order filter to approximate transient of rotor, and to improve numerics"
          annotation (Placement(transformation(extent={{20,81},{34,95}})));

        Modelica.Blocks.Interfaces.RealOutput dp_filtered(min=0, final unit="Pa") if
           filteredSpeed "Filtered pressure"
          annotation (Placement(transformation(extent={{40,78},{60,98}}),
              iconTransformation(extent={{60,50},{80,70}})));
      equation
        assert(dp_in >= -Modelica.Constants.eps,
          "dp_in cannot be negative. Obtained dp_in = " + String(dp_in));

        connect(dp_in, gain.u) annotation (Line(
            points={{1.11022e-15,120},{1.11022e-15,90},{-30,90},{-30,70},{-22,70}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));

        if filteredSpeed then
          connect(gain.y, filter.u) annotation (Line(
            points={{1,70},{10,70},{10,88},{18.6,88}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(filter.y, dp_actual) annotation (Line(
            points={{34.7,88},{38,88},{38,50},{110,50}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(filter.y, dp_filtered) annotation (Line(
            points={{34.7,88},{50,88}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        else
          connect(gain.y, dp_actual) annotation (Line(
            points={{1,70},{56,70},{56,50},{110,50}},
            color={0,0,127},
            smooth=Smooth.None));
        end if;

        connect(dp_actual, preSou.dp_in) annotation (Line(
            points={{110,50},{60,50},{60,40},{36,40},{36,8}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        annotation (defaultComponentName="fan",
        Documentation(info="<html>
<p>
This model describes a fan or pump with prescribed head.
The input connector provides the difference between
outlet minus inlet pressure.
The efficiency of the device is computed based
on the efficiency curves that take as an argument
the actual volume flow rate divided by the maximum possible volume flow rate.
</p>
<p>
If <code>filteredSpeed=true</code>, then the parameter <code>dp_nominal</code> is
used to normalize the filter. This is used to improve the numerics of the transient response.
The actual pressure raise of the mover at steady-state is independent
of the value of <code>dp_nominal</code>. It is recommended to set
<code>dp_nominal</code> to approximately the pressure raise that the fan has during
full speed.
</p>
<p>
See the
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>",   revisions="<html>
<ul>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>July 5, 2010, by Michael Wetter:<br/>
Changed <code>assert(dp_in >= 0, ...)</code> to <code>assert(dp_in >= -0.1, ...)</code>.
The former implementation triggered the assert if <code>dp_in</code> was solved for
in a nonlinear equation since the solution can be slightly negative while still being
within the solver tolerance.
</li>
<li>March 24, 2010, by Michael Wetter:<br/>
Revised implementation to allow zero flow rate.
</li>
<li>October 1, 2009,
    by Michael Wetter:<br/>
       Added model to the Buildings library.
</ul>
</html>"),Icon(graphics={Text(extent={{20,142},{104,108}},textString="dp_in"),
              Line(
                points={{32,50},{100,50}},
                color={0,0,0},
                smooth=Smooth.None),
              Text(extent={{64,68},{114,54}},
                lineColor={0,0,127},
                textString="dp")}));
      end FlowMachine_dp;

      package BaseClasses
        "Package with base classes for Buildings.Fluid.Movers"
        extends Modelica.Icons.BasesPackage;

        package Characteristics "Functions for fan or pump characteristics"

          record efficiencyParameters "Record for efficiency parameters"
            extends Modelica.Icons.Record;
            parameter Real  r_V[:](each min=0, each max=1, each displayUnit="1")
              "Volumetric flow rate divided by nominal flow rate at user-selected operating points";
            parameter Real eta[size(r_V,1)](
               each min=0, each max=1, each displayUnit="1")
              "Fan or pump efficiency at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
efficiency.
The volume flow rate <code>r_V</code> must be increasing, i.e.,
<code>r_V[i] &lt; r_V[i+1]</code>.
Both vectors, <code>r_V</code> and <code>eta</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end efficiencyParameters;

          function efficiency
            "Flow vs. efficiency characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input
              Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
              data "Efficiency performance data";
            input Real r_V(unit="1")
              "Volumetric flow rate divided by nominal flow rate";
            input Real d[:]
              "Derivatives at support points for spline interpolation";
            output Real eta(min=0, unit="1") "Efficiency";

          protected
            Integer n = size(data.r_V, 1) "Number of data points";
            Integer i "Integer to select data interval";
          algorithm
            if n == 1 then
              eta := data.eta[1];
            else
              i :=1;
              for j in 1:n-1 loop
                 if r_V > data.r_V[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              eta:=Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=r_V,
                          x1=data.r_V[i],
                          x2=data.r_V[i + 1],
                          y1=data.eta[i],
                          y2=data.eta[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;

            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan or pump efficiency for given normalized volume flow rate
and performance data. The efficiency is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &eta; = s(r<sub>V</sub>, d),
</p>
<p>
where
<i>&eta;</i> is the efficiency,
<i>r<sub>V</sub></i> is the normalized volume flow rate, and
<i>d</i> are performance data for fan or pump efficiency.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),             smoothOrder=1);
          end efficiency;
          annotation (Documentation(info="<html>
<p>
This package implements performance curves for fans and pumps,
and records for parameter that can be used with these performance
curves.
</p>

The following performance curves are implemented:<br/>
<table summary=\"summary\" border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
<tr>
<th>Independent variable</th>
<th>Dependent variable</th>
<th>Record for performance data</th>
<th>Function</th>
</tr>
<tr>
<td>Volume flow rate</td>
<td>Pressure</td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters\">
flowParameters</a></td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure\">
pressure</a></td>
</tr>
<tr>
<td>Relative volumetric flow rate</td>
<td>Efficiency</td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters\">
efficiencyParameters</a></td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency\">
efficiency</a></td>
</tr>
<tr>
<td>Volume flow rate</td>
<td>Power</td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters\">
powerParameters</a></td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.power\">
power</a></td>
</tr>
</table>
</html>",
        revisions="<html>
<ul>
<li>
September 29, 2011, by Michael Wetter:<br/>
New implementation due to changes from polynomial to cubic hermite splines.
</li>
</ul>
</html>"));
        end Characteristics;

        model ControlledFlowMachine
          "Partial model for fan or pump with ideally controlled mass flow rate or head as input signal"
          extends Buildings.Fluid.Movers.BaseClasses.PowerInterface(
             final use_powerCharacteristic = false,
             final rho_default = Medium.density(sta_default));

          extends Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine(
           preSou(final control_m_flow=control_m_flow));

          import cha = Buildings.Fluid.Movers.BaseClasses.Characteristics;
        //  parameter Modelica.SIunits.MassFlowRate m_flow_nominal
        //    "Nominal mass flow rate, used as flow rate if control_m_flow";
        //  parameter Modelica.SIunits.MassFlowRate m_flow_max = m_flow_nominal
        //    "Maximum mass flow rate (at zero head)";
          // what to control
          constant Boolean control_m_flow
            "= false to control head instead of m_flow"
            annotation(Evaluate=true);

          Real r_V(start=1)
            "Ratio V_flow/V_flow_max = V_flow/V_flow(dp=0, N=N_nominal)";

        protected
          final parameter Medium.AbsolutePressure p_a_default(displayUnit="Pa") = Medium.p_default
            "Nominal inlet pressure for predefined fan or pump characteristics";
          parameter Medium.ThermodynamicState sta_default = Medium.setState_pTX(
             T=Medium.T_default,
             p=Medium.p_default,
             X=Medium.X_default[1:Medium.nXi]) "Default medium state";

          Modelica.Blocks.Sources.RealExpression PToMedium_flow(y=Q_flow + WFlo) if  addPowerToMedium
            "Heat and work input into medium"
            annotation (Placement(transformation(extent={{-100,10},{-80,30}})));
        initial equation
          V_flow_max=m_flow_nominal/rho_default;
        equation
          r_V = VMachine_flow/V_flow_max;
          etaHyd = cha.efficiency(data=hydraulicEfficiency, r_V=r_V, d=hydDer);
          etaMot = cha.efficiency(data=motorEfficiency,     r_V=r_V, d=motDer);
          dpMachine = -dp;
          VMachine_flow = -port_b.m_flow/rho_in;
          // To compute the electrical power, we set a lower bound for eta to avoid
          // a division by zero.
          P = WFlo / Buildings.Utilities.Math.Functions.smoothMax(x1=eta, x2=1E-5, deltaX=1E-6);

          connect(PToMedium_flow.y, prePow.Q_flow) annotation (Line(
              points={{-79,20},{-70,20}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (defaultComponentName="fan",
            Documentation(info="<html>
<p>
This model describes a fan or pump that takes as an input
the head or the mass flow rate.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
September 13, 2013 by Michael Wetter:<br/>
Corrected computation of <code>sta_default</code> to use medium default
values instead of medium start values.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
October 11, 2012, by Michael Wetter:<br/>
Added implementation of <code>WFlo = eta * P</code> with
guard against division by zero.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
November 11, 2010, by Michael Wetter:<br/>
Changed <code>V_flow_max=m_flow_nominal/rho_nominal;</code> to <code>V_flow_max=m_flow_max/rho_nominal;</code>
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>
March 24, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ControlledFlowMachine;

        model IdealSource
          "Base class for pressure and mass flow source with optional power input"
          extends Buildings.Fluid.Interfaces.PartialTwoPortTransport(
            show_T=false);

          // what to control
          parameter Boolean control_m_flow
            "= false to control dp instead of m_flow"
            annotation(Evaluate = true);
          Modelica.Blocks.Interfaces.RealInput m_flow_in if control_m_flow
            "Prescribed mass flow rate"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-60,80})));
          Modelica.Blocks.Interfaces.RealInput dp_in if not control_m_flow
            "Prescribed outlet pressure"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={60,80})));

        protected
          Modelica.Blocks.Interfaces.RealInput m_flow_internal
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput dp_internal
            "Needed to connect to conditional connector";
        equation

          // Ideal control
          if control_m_flow then
            m_flow = m_flow_internal;
            dp_internal = 0;
          else
            dp = dp_internal;
            m_flow_internal = 0;
          end if;

          connect(dp_internal, dp_in);
          connect(m_flow_internal, m_flow_in);

          // Energy balance (no storage)
          port_a.h_outflow = inStream(port_b.h_outflow);
          port_b.h_outflow = inStream(port_a.h_outflow);

          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,60},{100,-60}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,50},{100,-48}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Text(
                  visible=not control_m_flow,
                  extent={{24,44},{80,24}},
                  lineColor={255,255,255},
                  textString="dp"),
                Text(
                  visible=control_m_flow,
                  extent={{-80,44},{-24,24}},
                  lineColor={255,255,255},
                  textString="m")}),
            Documentation(info="<html>
<p>
Model of a fictious pipe that is used as a base class
for a pressure source or to prescribe a mass flow rate.
</p>
<p>
Note that for fans and pumps with dynamic balance,
both the heat and the flow work are added to the volume of
air or water. This simplifies the equations compared to
adding heat to the volume, and flow work to this model.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
Removed the option to add power to the medium, as this is dealt with in the volume
that is used in the mover model.
</li>
<li>
July 27, 2010 by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>
April 13, 2010 by Michael Wetter:<br/>
Made heat connector optional.
</li>
<li>
March 23, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end IdealSource;

        partial model PartialFlowMachine
          "Partial model to interface fan or pump models with the medium"
          extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
          import Modelica.Constants;

          extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(show_T=false,
            port_a(
              h_outflow(start=h_outflow_start),
              final m_flow(min = if allowFlowReversal then -Constants.inf else 0)),
            port_b(
              h_outflow(start=h_outflow_start),
              p(start=p_start),
              final m_flow(max = if allowFlowReversal then +Constants.inf else 0)),
              final showDesignFlowDirection=false);

          Delays.DelayFirstOrder vol(
            redeclare package Medium = Medium,
            tau=tau,
            energyDynamics=if dynamicBalance then energyDynamics else Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=if dynamicBalance then massDynamics else Modelica.Fluid.Types.Dynamics.SteadyState,
            T_start=T_start,
            X_start=X_start,
            C_start=C_start,
            m_flow_nominal=m_flow_nominal,
            p_start=p_start,
            prescribedHeatFlowRate=true,
            allowFlowReversal=allowFlowReversal,
            nPorts=2) "Fluid volume for dynamic model"
            annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
           parameter Boolean dynamicBalance = true
            "Set to true to use a dynamic balance, which often leads to smaller systems of equations"
            annotation (Evaluate=true, Dialog(tab="Dynamics", group="Equations"));

          parameter Boolean addPowerToMedium=true
            "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations)";

          parameter Modelica.SIunits.Time tau=1
            "Time constant of fluid volume for nominal flow, used if dynamicBalance=true"
            annotation (Dialog(tab="Dynamics", group="Nominal condition", enable=dynamicBalance));

          // Models
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
            "Heat dissipation to environment"
            annotation (Placement(transformation(extent={{-70,-90},{-50,-70}}),
                iconTransformation(extent={{-10,-78},{10,-58}})));

        protected
          Modelica.SIunits.Density rho_in "Density of inflowing fluid";

          Buildings.Fluid.Movers.BaseClasses.IdealSource preSou(
            redeclare final package Medium = Medium,
            final m_flow_small=m_flow_small,
            final allowFlowReversal=allowFlowReversal) "Pressure source"
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));

          Buildings.HeatTransfer.Sources.PrescribedHeatFlow prePow if addPowerToMedium
            "Prescribed power (=heat and flow work) flow for dynamic model"
            annotation (Placement(transformation(extent={{-70,10},{-50,30}})));

          parameter Medium.ThermodynamicState sta_start=Medium.setState_pTX(
              T=T_start, p=p_start, X=X_start) "Medium state at start values";
          parameter Modelica.SIunits.SpecificEnthalpy h_outflow_start = Medium.specificEnthalpy(sta_start)
            "Start value for outflowing enthalpy";

        equation
          // For computing the density, we assume that the fan operates in the design flow direction.
          rho_in = Medium.density(
               Medium.setState_phX(port_a.p, inStream(port_a.h_outflow), inStream(port_a.Xi_outflow)));
          connect(prePow.port, vol.heatPort) annotation (Line(
              points={{-50,20},{-44,20},{-44,10},{-40,10}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(vol.heatPort, heatPort) annotation (Line(
              points={{-40,10},{-40,-80},{-60,-80}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(port_a, vol.ports[1]) annotation (Line(
              points={{-100,5.55112e-16},{-66,5.55112e-16},{-66,-5.55112e-16},{-32,
                  -5.55112e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(vol.ports[2], preSou.port_a) annotation (Line(
              points={{-28,-5.55112e-16},{-5,-5.55112e-16},{-5,6.10623e-16},{20,
                  6.10623e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(preSou.port_b, port_b) annotation (Line(
              points={{40,6.10623e-16},{70,6.10623e-16},{70,5.55112e-16},{100,
                  5.55112e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          annotation(Icon(coordinateSystem(preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}),
            graphics={
                Line(
                  visible=not filteredSpeed,
                  points={{0,100},{0,40}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-100,16},{100,-14}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.HorizontalCylinder),
                Ellipse(
                  extent={{-58,50},{54,-58}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={0,100,199}),
                Polygon(
                  points={{0,50},{0,-56},{54,2},{0,50}},
                  lineColor={0,0,0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={255,255,255}),
                Ellipse(
                  extent={{4,14},{34,-16}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  visible=dynamicBalance,
                  fillColor={0,100,199}),
                Rectangle(
                  visible=filteredSpeed,
                  extent={{-34,40},{32,100}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  visible=filteredSpeed,
                  extent={{-34,100},{32,40}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  visible=filteredSpeed,
                  extent={{-22,92},{20,46}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  textString="M",
                  textStyle={TextStyle.Bold})}),
            Documentation(info="<html>
<p>This is the base model for fans and pumps.
It provides an interface
between the equations that compute head and power consumption,
and the implementation of the energy and pressure balance
of the fluid.
</p>
<p>
Depending on the value of
the parameter <code>dynamicBalance</code>, the fluid volume
is computed using a dynamic balance or a steady-state balance.
</p>
<p>
The parameter <code>addPowerToMedium</code> determines whether
any power is added to the fluid. The default is <code>addPowerToMedium=true</code>,
and hence the outlet enthalpy is higher than the inlet enthalpy if the
flow device is operating.
The setting <code>addPowerToMedium=false</code> is physically incorrect
(since the flow work, the flow friction and the fan heat do not increase
the enthalpy of the medium), but this setting does in some cases lead to simpler equations
and more robust simulation, in particular if the mass flow is equal to zero.
</p>
</html>",     revisions="<html>
<ul>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 29, 2010, by Michael Wetter:<br/>
Reduced fan time constant from 10 to 1 second.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialFlowMachine;

        partial model PowerInterface
          "Partial model to compute power draw and heat dissipation of fans and pumps"

          import Modelica.Constants;

          parameter Boolean use_powerCharacteristic = false
            "Use powerCharacteristic (vs. efficiencyCharacteristic)"
             annotation(Evaluate=true,Dialog(group="Characteristics"));

          parameter Boolean motorCooledByFluid = true
            "If true, then motor heat is added to fluid stream"
            annotation(Dialog(group="Characteristics"));
          parameter Boolean homotopyInitialization = true
            "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));

          parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
              motorEfficiency(r_V={1}, eta={0.7})
            "Normalized volume flow rate vs. efficiency"
            annotation(Placement(transformation(extent={{60,-40},{80,-20}})),
                       Dialog(group="Characteristics"),
                       enable = not use_powerCharacteristic);
          parameter
            Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
              hydraulicEfficiency(r_V={1}, eta={0.7})
            "Normalized volume flow rate vs. efficiency"
            annotation(Placement(transformation(extent={{60,-80},{80,-60}})),
                       Dialog(group="Characteristics"),
                       enable = not use_powerCharacteristic);

          parameter Modelica.SIunits.Density rho_default
            "Fluid density at medium default state";

          Modelica.Blocks.Interfaces.RealOutput P(quantity="Modelica.SIunits.Power",
           unit="W") "Electrical power consumed"
          annotation (Placement(transformation(extent={{100,70},{120,90}})));

          Modelica.SIunits.Power WHyd
            "Hydraulic power input (converted to flow work and heat)";
          Modelica.SIunits.Power WFlo "Flow work";
          Modelica.SIunits.HeatFlowRate Q_flow
            "Heat input from fan or pump to medium";
          Real eta(min=0, max=1) "Global efficiency";
          Real etaHyd(min=0, max=1) "Hydraulic efficiency";
          Real etaMot(min=0, max=1) "Motor efficiency";

          Modelica.SIunits.Pressure dpMachine(displayUnit="Pa")
            "Pressure increase";
          Modelica.SIunits.VolumeFlowRate VMachine_flow "Volume flow rate";
        protected
          parameter Modelica.SIunits.VolumeFlowRate V_flow_max(fixed=false)
            "Maximum volume flow rate, used for smoothing";
          //Modelica.SIunits.HeatFlowRate QThe_flow "Heat input into the medium";
          parameter Modelica.SIunits.VolumeFlowRate delta_V_flow = 1E-3*V_flow_max
            "Factor used for setting heat input into medium to zero at very small flows";
          final parameter Real motDer[size(motorEfficiency.r_V, 1)](each fixed=false)
            "Coefficients for polynomial of pressure vs. flow rate";
          final parameter Real hydDer[size(hydraulicEfficiency.r_V,1)](each fixed=false)
            "Coefficients for polynomial of pressure vs. flow rate";

          Modelica.SIunits.HeatFlowRate QThe_flow
            "Heat input from fan or pump to medium";

        initial algorithm
         // Compute derivatives for cubic spline
         motDer :=
           if use_powerCharacteristic then
             zeros(size(motorEfficiency.r_V, 1))
           elseif ( size(motorEfficiency.r_V, 1) == 1)  then
               {0}
           else
              Buildings.Utilities.Math.Functions.splineDerivatives(
              x=motorEfficiency.r_V,
              y=motorEfficiency.eta,
              ensureMonotonicity=Buildings.Utilities.Math.Functions.isMonotonic(x=motorEfficiency.eta,
                                                                                strict=false));
          hydDer :=
             if use_powerCharacteristic then
               zeros(size(hydraulicEfficiency.r_V, 1))
             elseif ( size(hydraulicEfficiency.r_V, 1) == 1)  then
               {0}
             else
               Buildings.Utilities.Math.Functions.splineDerivatives(
                           x=hydraulicEfficiency.r_V,
                           y=hydraulicEfficiency.eta);
        equation
          eta = etaHyd * etaMot;
        //  WFlo = eta * P;
          // Flow work
          WFlo = dpMachine*VMachine_flow;
          // Hydraulic power (transmitted by shaft), etaHyd = WFlo/WHyd
          etaHyd * WHyd   = WFlo;
          // Heat input into medium
          QThe_flow +  WFlo = if motorCooledByFluid then P else WHyd;
          // At m_flow = 0, the solver may still obtain positive values for QThe_flow.
          // The next statement sets the heat input into the medium to zero for very small flow rates.
          if homotopyInitialization then
            Q_flow = homotopy(actual=Buildings.Utilities.Math.Functions.spliceFunction(pos=QThe_flow, neg=0,
                               x=noEvent(abs(VMachine_flow))-2*delta_V_flow, deltax=delta_V_flow),
                             simplified=0);
          else
            Q_flow = Buildings.Utilities.Math.Functions.spliceFunction(pos=QThe_flow, neg=0,
                               x=noEvent(abs(VMachine_flow))-2*delta_V_flow, deltax=delta_V_flow);
          end if;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
                Text(extent={{64,100},{114,86}},  textString="P",
                  lineColor={0,0,127}),
                Line(
                  points={{0,80},{100,80}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>This is an interface that implements the functions to compute the power draw and the
heat dissipation of fans and pumps. It is used by the model
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface\">
Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface</a>.
</p>
<h4>Implementation</h4>
<p>
Models that extend this model need to provide an implementation of
<code>WFlo = eta * P</code>.
This equation is not implemented in this model to allow other models
to properly guard against division by zero.
</p>
</html>",     revisions="<html>
<ul>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
September 17, 2013, by Michael Wetter:<br/>
Added missing <code>each</code> keyword in declaration of parameters
that are an array.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li><i>October 11, 2012</i> by Michael Wetter:<br/>
    Removed <code>WFlo = eta * P</code> so that classes that use this partial model
    can properly implement the equation so it guards against division by zero.
</li>
<li><i>March 1, 2010</i>
    by Michael Wetter:<br/>
    Revised implementation to allow <code>N=0</code>.
<li><i>October 1, 2009</i>
    by Michael Wetter:<br/>
    Changed model so that it is based on total pressure in Pascals instead of the pump head in meters.
    This change is needed if the device is used with air as a medium. The original formulation in Modelica.Fluid
    converts head to pressure using the density medium.d. Therefore, for fans, head would be converted to pressure
    using the density of air. However, for fans, manufacturers typically publish the head in
    millimeters water (mmH20). Therefore, to avoid confusion and to make this model applicable for any medium,
    the model has been changed to use total pressure in Pascals instead of head in meters.
</li>
<li><i>31 Oct 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br/>
       Model added to the Fluid library</li>
</ul>
</html>"));
        end PowerInterface;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Movers\">Buildings.Fluid.Movers</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains components models for fans and pumps.
</html>"));
    end Movers;

    package Sensors "Package with sensor models"
      extends Modelica.Icons.SensorsPackage;

      model Temperature "Ideal one port temperature sensor"
          extends Buildings.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor;

        Modelica.Blocks.Interfaces.RealOutput T(final quantity="ThermodynamicTemperature",
                                                final unit = "K",
                                                min=0,
                                                displayUnit = "degC")
          "Temperature in port medium"
          annotation (Placement(transformation(extent={{60,-10},{80,10}})));

      equation
        T = Medium.temperature(state=Medium.setState_phX(
              p=port.p, h=inStream(port.h_outflow), X=inStream(port.Xi_outflow)));
      annotation (defaultComponentName="senTem",
          Documentation(info="<html>
<p>
This model outputs the temperature of the fluid connected to its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
<p>
Read the
<a href=\"modelica://Buildings.Fluid.Sensors.UsersGuide\">
Buildings.Fluid.Sensors.UsersGuide</a>
prior to using this model with one fluid port.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"),
        Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,100}}),
                              graphics={
              Line(points={{0,-70},{0,-100}}, color={0,0,127}),
              Ellipse(
                extent={{-20,-98},{20,-60}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-12,40},{12,-68}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{
                    12,80},{12,40},{-12,40}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Line(
                points={{-12,40},{-12,-64}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{12,40},{12,-64}},
                color={0,0,0},
                thickness=0.5),
              Line(points={{-40,-20},{-12,-20}}, color={0,0,0}),
              Line(points={{-40,20},{-12,20}}, color={0,0,0}),
              Line(points={{-40,60},{-12,60}}, color={0,0,0}),
              Line(points={{12,0},{60,0}}, color={0,0,127})}),
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={
              Ellipse(
                extent={{-20,-88},{20,-50}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-12,50},{12,-58}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-12,50},{-12,90},{-10,96},{-6,98},{0,100},{6,98},{10,96},{12,
                    90},{12,50},{-12,50}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Line(
                points={{-12,50},{-12,-54}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{12,50},{12,-54}},
                color={0,0,0},
                thickness=0.5),
              Line(points={{-40,-10},{-12,-10}}, color={0,0,0}),
              Line(points={{-40,30},{-12,30}}, color={0,0,0}),
              Line(points={{-40,70},{-12,70}}, color={0,0,0}),
              Text(
                extent={{126,-30},{6,-60}},
                lineColor={0,0,0},
                textString="T"),
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255}),
              Line(points={{12,0},{60,0}}, color={0,0,127})}));
      end Temperature;

      package BaseClasses
        "Package with base classes for Buildings.Fluid.Sensors"
        extends Modelica.Icons.BasesPackage;

        partial model PartialAbsoluteSensor
          "Partial component to model a sensor that measures a potential variable"

          replaceable package Medium=Modelica.Media.Interfaces.PartialMedium
            "Medium in the sensor"
            annotation(choicesAllMatching=true);

          Modelica.Fluid.Interfaces.FluidPort_a port(redeclare package Medium=Medium, m_flow(min=0))
            annotation (Placement(transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=90)));

        equation
          port.m_flow = 0;
          port.h_outflow = 0;
          port.Xi_outflow = zeros(Medium.nXi);
          port.C_outflow = zeros(Medium.nC);
          annotation (Documentation(info="<html>
<p>
Partial component to model an absolute sensor.
The component can be used for pressure sensor models.
Use for other properties such as temperature or density is discouraged, because the enthalpy at the connector can have different meanings, depending on the connection topology. For these properties, use
<a href=\"modelica://Buildings.Fluid.Sensors.BaseClasses.PartialFlowSensor\">
Buildings.Fluid.Sensors.BaseClasses.PartialFlowSensor</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
February 12, 2011, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
        end PartialAbsoluteSensor;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Sensors\">Buildings.Fluid.Sensors</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
<p>
Package <code>Sensors</code> consists of idealized sensor components that
provide variables of a medium as
output signals. These signals can be, e.g., further processed
with components of the
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>
library.
</p>
</html>", revisions="<html>
<ul>
<li><i>22 Dec 2008</i>
    by R&uuml;diger Franke
    <ul>
    <li>flow sensors based on Modelica.Fluid.Interfaces.PartialTwoPort</li>
    <li>adapted documentation to stream connectors, i.e. less need for two port sensors</li>
    </ul>
<li><i>4 Dec 2008</i>
    by Michael Wetter<br/>
       included sensors for trace substance</li>
<li><i>31 Oct 2007</i>
    by Carsten Heinrich<br/>
       updated sensor models, included one and two port sensors for thermodynamic state variables</li>
</ul>
</html>"));
    end Sensors;

    package Storage "Package with thermal energy storage models"
      extends Modelica.Icons.VariantsPackage;

      model ExpansionVessel "Expansion vessel with fixed pressure"
       extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations(
         final energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
         final massDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial);
       parameter Modelica.SIunits.Volume V_start(start=1)
          "Volume of liquid stored in the vessel at the start of the simulation";
       parameter Modelica.SIunits.Pressure p = Medium.p_default
          "Constant pressure of the expansion vessel";

        Modelica.Fluid.Interfaces.FluidPort_a port_a(
          redeclare package Medium = Medium) "Fluid port"
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
        Modelica.SIunits.Mass m "Mass of liquid in the vessel";

      protected
        final parameter Medium.ThermodynamicState state_start = Medium.setState_pTX(
            T=T_start,
            p=p_start,
            X=X_start[1:Medium.nXi]) "Medium state at start values";
        final parameter Modelica.SIunits.Density rho_start=Medium.density(
         state=state_start) "Density, used to compute start and guess values";

        Modelica.SIunits.Energy H "Internal energy of fluid";
        Modelica.SIunits.Mass[Medium.nXi] mXi
          "Masses of independent components in the fluid";
        Modelica.SIunits.Mass[Medium.nC] mC
          "Masses of trace substances in the fluid";
        Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)
          "Trace substance mixture content";

      initial equation
        m = V_start * rho_start;
        H = m*Medium.specificInternalEnergy(
                Medium.setState_pTX(p=p_start, T=T_start, X= X_start[1:Medium.nXi]));
        mXi = m*X_start[1:Medium.nXi];
        mC = m*C_start[1:Medium.nC];
      equation
        assert(m > 1.0E-8,
          "Expansion vessel is undersized. You need to increase the value of the parameter V_start.");
        // Conservation equations
        der(m)   = port_a.m_flow;
        der(H)   = port_a.m_flow * actualStream(port_a.h_outflow);
        der(mXi) = port_a.m_flow * actualStream(port_a.Xi_outflow);
        der(mC)  = port_a.m_flow * actualStream(port_a.C_outflow);
        // Properties of outgoing flow.
        // The port pressure is set to a constant value.
        port_a.p          = p_start;
        m*port_a.h_outflow  = H;
        m*port_a.Xi_outflow = mXi;
        m*port_a.C_outflow  = mC;

         annotation (Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                  -100},{100,100}}), graphics={
              Text(
                extent={{-148,98},{152,138}},
                textString="%name",
                lineColor={0,0,255}),
              Rectangle(
                extent={{-80,80},{80,-80}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-68,70},{70,-70}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-68,18},{-68,18},{-54,32},{-28,16},{0,30},{26,16},{46,32},{
                    70,18},{70,18},{70,-70},{70,-70},{-68,-70},{-68,-70},{-68,18}},
                lineColor={0,0,255},
                smooth=Smooth.Bezier,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{2,-80},{-2,-90}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid)}),
      defaultComponentName="exp",
      Documentation(info="<html>
<p>
This is a model of a pressure expansion vessel. The vessel has a constant pressure
that is equal to the value of the parameter <code>p_start</code>.
The model takes into account the energy and mass balance of the medium.
It has no heat exchange with the ambient.
</p>
<p>
The expansion vessel needs to be used in closed loops that contain
water to set a reference pressure and, for liquids where the
density is modeled as a function of temperature, to allow for
the thermal expansion of the liquid.
</p>
<p>
Note that alternatively, the model
<a href=\"modelica://Buildings.Fluid.Sources.FixedBoundary\">
Buildings.Fluid.Sources.FixedBoundary</a> may be used to set
a reference pressure. The main difference between these two models
is that in this model, there is an energy and mass balance for the volume.
In contrast, for
<a href=\"modelica://Buildings.Fluid.Sources.FixedBoundary\">
Buildings.Fluid.Sources.FixedBoundary</a>,
any mass flow rate that flows out of the model will be at a user-specified temperature.
Therefore, <a href=\"modelica://Buildings.Fluid.Sources.FixedBoundary\">
Buildings.Fluid.Sources.FixedBoundary</a> leads to smaller systems
of equations, which may result in faster simulation.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 25, 2014 by Michael Wetter:<br/>
Revised the model to use a constant pressure rather than a constant volume of
water and gas. This leads to a simpler model.
</li>
<li>
August 1, 2013 by Michael Wetter:<br/>
Updated model to use new connector <code>mWat_flow</code>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised due to changes in conservation equations in <code>Buildings.Fluid.Interfaces</code>.
</li>
<li>
September 16, 2011 by Michael Wetter:<br/>
Set <code>m(stateSelect=StateSelect.always)</code>, since
setting the <code>stateSelect</code> attribute leads to smaller systems of equations.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
Revised model due to a change in the fluid volume model.
</li>
<li>
Nov. 4, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ExpansionVessel;
    annotation (preferredView="info", Documentation(info="<html>
This package contains thermal energy storage models.
</html>"));
    end Storage;

    package Data "Data for fluid models"
        extends Modelica.Icons.MaterialPropertiesPackage;

      package Fuels "Package with properties of fuels"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record NaturalGasLowerHeatingValue = Buildings.Fluid.Data.Fuels.Generic
            (
            h=50E6,
            d=0.84,
            mCO2=2.23) "Natural gas, lower heating value";

        record NaturalGasHigherHeatingValue = NaturalGasLowerHeatingValue (
            h=55.5E6) "Natural gas, higher heating value";

        record Generic "Generic record of fuel properties"
          extends Modelica.Icons.Record;
          parameter Modelica.SIunits.SpecificEnthalpy h
            "Heating value (lower or upper, depending on fuel)";
          parameter Modelica.SIunits.Density d "Mass density";
          parameter Real mCO2(final min=0)
            "CO2 emission at combustion, in kg/kg fuel";
          annotation (Documentation(info="<html>
<p>
This is a generic record where the fuel properties need to be specified by the user.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 26, 2013 by Michael Wetter:<br/>
Corrected wrong type for <code>mCO2</code>.
It was declared as <code>Modelica.SIunits.MassFraction</code>,
which is incorrect.
</li>
<li>
December 22, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;
          annotation (
      preferredView="info",
      Documentation(info="<html>
<p>
Package with records for fuel properties.
Note that the heating value and the mass density can vary for individual fuels.
The parameter <code>mCO2</code> are the CO<sub>2</sub> emission in kilograms
that are released per kilogram fuel that is burnt.
</p>
</html>",       revisions="<html>
<ul>
<li>
December 22, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Fuels;
      annotation (
    preferredView="info",
    Documentation(info="<html>
<p>
Package with physical properties that are used by models in the package
<a href=\"modelica://Buildings.Fluid\">Buildings.Fluid</a>.
</p>
</html>"));
    end Data;

    package Types "Package with type definitions"

      type EfficiencyCurves = enumeration(
          Constant "constant",
          Polynomial "Polynomial",
          QuadraticLinear "quadratic in x1, linear in x2")
        "Enumeration to define the efficiency curves";

      type CvTypes = enumeration(
          OpPoint "flow coefficient defined by m_flow_nominal/sqrt(dp_nominal)",

          Kv "Kv (metric) flow coefficient",
          Cv "Cv (US) flow coefficient",
          Av "Av (metric) flow coefficient")
        "Enumeration to define the choice of valve flow coefficient" annotation (
          Documentation(info="<html>

<p>
Enumeration to define the choice of valve flow coefficient
(to be selected via choices menu):
</p>

<table summary=\"summary\"  border=\"1\">
<tr><th>Enumeration</th>
    <th>Description</th></tr>

<tr><td>OpPoint</td>
    <td>flow coefficient defined by ratio m_flow_nominal/sqrt(dp_nominal)</td></tr>

<tr><td>Kv</td>
    <td>Kv (metric) flow coefficient</td></tr>

<tr><td>Cv</td>
    <td>Cv (US) flow coefficient</td></tr>

<tr><td>Av</td>
    <td>Av (metric) flow coefficient</td></tr>

</table>

<p>
The details of the coefficients are explained in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">
Users Guide</a>.
</p>

</html>"));

    annotation (preferredView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
    end Types;

    package BaseClasses "Package with base classes for Buildings.Fluid"
      extends Modelica.Icons.BasesPackage;

      package FlowModels "Flow models for pressure drop calculations"
        extends Modelica.Icons.BasesPackage;

        function basicFlowFunction_dp "Basic class for flow models"

          input Modelica.SIunits.Pressure dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate";
          output Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
        protected
          Modelica.SIunits.Pressure dp_turbulent(displayUnit="Pa")
            "Turbulent flow if |dp| >= dp_small, not a parameter because k can be a function of time";
        protected
         Real kSqu(unit="kg.m") "Flow coefficient, kSqu=k^2=m_flow^2/|dp|";
        algorithm
         kSqu:=k*k;
         dp_turbulent :=m_flow_turbulent^2/kSqu;
         m_flow :=Modelica.Fluid.Utilities.regRoot2(x=dp, x_small=dp_turbulent, k1=kSqu, k2=kSqu);

        annotation(LateInline=true,
                   inverse(dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k, m_flow_turbulent=m_flow_turbulent)),
                   smoothOrder=2,
                   Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>m_flow=0</code> if <code>dp=0</code>,
as this causes the derivative to be discontinuous at <code>dp=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Implemented linearized model in this model instead of
in the functions
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
and
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>.
With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2010 by Michael Wetter:<br/>
Changed implementation to allow <code>k=0</code>, which is
the case for a closed valve with no leakage
</li>
</ul>
</html>"),
        revisions="<html>
<ul>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>");
        end basicFlowFunction_dp;

        function basicFlowFunction_m_flow "Basic class for flow models"

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate";
          output Modelica.SIunits.Pressure dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
        protected
         Real kSquInv(unit="1/(kg.m)") "Flow coefficient";
        algorithm
         kSquInv:=1/k^2;
         dp :=Modelica.Fluid.Utilities.regSquare2(x=m_flow, x_small=m_flow_turbulent, k1=kSquInv, k2=kSquInv);

         annotation (LateInline=true,
                     inverse(m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k, m_flow_turbulent=m_flow_turbulent)),
                     smoothOrder=2,
                     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = sign(m) (m &frasl; k)<sup>2</sup>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>"),
        revisions="<html>
<ul>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>dp=0</code> if <code>m_flow=0</code>,
as this causes the derivative to be discontinuous at <code>m_flow=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>");
        end basicFlowFunction_m_flow;
      annotation (Documentation(info="<html>
This package contains a basic flow model that is used by the
various models that compute pressure drop.
Because the density does not change signficantly in heating,
ventilation and air conditioning systems for buildings,
this model computes the pressure drop based on the mass flow
rate and not the volume flow rate. This typically leads to simpler
equations because it does not require
the mass density, which changes when the flow is reversed.
Although, for conceptual design of building energy system, there is
in general not enough information available that would warrant a more
detailed pressure drop calculation.
If a more detailed computation of the flow resistance is needed,
then a user can use models from the
<code>Modelica.Fluid</code> library.
</html>",       revisions="<html>
<ul>
<li>
April 10, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end FlowModels;

      partial model PartialResistance
        "Partial model for a hydraulic resistance"
          extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
           show_T=false,
           m_flow(start=0, nominal=m_flow_nominal_pos),
           dp(start=0, nominal=dp_nominal_pos),
           final m_flow_small = 1E-4*abs(m_flow_nominal));

        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));

        parameter Modelica.SIunits.Pressure dp_nominal(displayUnit="Pa")
          "Pressure drop at nominal mass flow rate"                                annotation(Dialog(group = "Nominal condition"));
        parameter Boolean homotopyInitialization = true
          "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean linearized = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        parameter Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
          "Turbulent flow if |m_flow| >= m_flow_turbulent";

      protected
        parameter Medium.ThermodynamicState sta_default=
           Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.SIunits.DynamicViscosity eta_default=Medium.dynamicViscosity(sta_default)
          "Dynamic viscosity, used to compute transition to turbulent flow regime";
      protected
        final parameter Modelica.SIunits.MassFlowRate m_flow_nominal_pos = abs(m_flow_nominal)
          "Absolute value of nominal flow rate";
        final parameter Modelica.SIunits.Pressure dp_nominal_pos = abs(dp_nominal)
          "Absolute value of nominal pressure";
      equation
        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = inStream(port_b.h_outflow);
        port_b.h_outflow = inStream(port_a.h_outflow);

        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;

        // Transport of substances
        port_a.Xi_outflow = inStream(port_b.Xi_outflow);
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = inStream(port_b.C_outflow);
        port_b.C_outflow = inStream(port_a.C_outflow);

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-42}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,22},{100,-24}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255}),
              Rectangle(
                visible=linearized,
                extent={{-100,22},{100,-24}},
                fillPattern=FillPattern.Backward,
                fillColor={0,128,255},
                pattern=LinePattern.None,
                lineColor={255,255,255})}),
                defaultComponentName="res",
      Documentation(info="<html>
<p>
Partial model for a flow resistance, possible with variable flow coefficient.
Models that extend this class need to implement an equation that relates
<code>m_flow</code> and <code>dp</code>, and they need to assign the parameter
<code>m_flow_turbulent</code>.
</p>
<p>
See for example
<a href=\"modelica://Buildings.Fluid.FixedResistances.FixedResistanceDpM\">
Buildings.Fluid.FixedResistances.FixedResistanceDpM</a> for a model that extends
this base class.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to base class as it has no longer this parameter.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
February 12, 2012, by Michael Wetter:<br/>
Removed duplicate declaration of <code>m_flow_nominal</code>.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Made assignment of <code>m_flow_small</code> <code>final</code> as it is no
longer used in the base class.
</li>
<li>
January 16, 2012, by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>Buildings.Fluid.BaseClasses.PartialResistance</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>Buildings.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>Buildings.Fluid.FixedResistances.FixedResistanceDpM</code>.
</li>
<li>
August 5, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
June 20, 2011, by Michael Wetter:<br/>
Set start values for <code>m_flow</code> and <code>dp</code> to zero, since
most HVAC systems start at zero flow. With this change, the start values
appear in the GUI and can be set by the user.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>m_flow_nominal_pos</code> and <code>dp_nominal_pos</code> to allow
providing negative nominal values which will be used, for example, to set start
values of flow splitters which may have negative flow rates and pressure drop
at the initial condition.
</li>
<li>
March 23, 2011 by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 30, 2010 by Michael Wetter:<br/>
Changed base classes to allow easier initialization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
      revisions="<html>
<ul>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Extracted pressure drop computation and implemented it in the
new model
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.BasicFlowModel\">
Buildings.Fluid.BaseClasses.FlowModels.BasicFlowModel</a>.
</li>
<li>
September 18, 2008, by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>");
      end PartialResistance;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid\">Buildings.Fluid</a>.
</p>
</html>"));
    end BaseClasses;

    package Interfaces "Package with interfaces for fluid models"
      extends Modelica.Icons.InterfacesPackage;

      model ConservationEquation "Lumped volume with mass and energy balance"

        extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
        // Port definitions
        parameter Integer nPorts=0 "Number of ports"
          annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
        parameter Boolean initialize_p = not Medium.singleState
          "= true to set up initial equations for pressure";
        parameter Real mFactor = 1
          "Factor to scale the thermal mass of the volume";
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
            redeclare each final package Medium = Medium)
          "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-40,-10},{40,10}},
            origin={0,-100})));

        // Set nominal attributes where literal values can be used.
        Medium.BaseProperties medium(
          preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState),
          p(start=p_start,
            stateSelect=if not (massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
                           then StateSelect.prefer else StateSelect.default),
          h(start=hStart),
          T(start=T_start,
            stateSelect=if (not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState))
                           then StateSelect.prefer else StateSelect.default),
          Xi(start=X_start[1:Medium.nXi],
             each stateSelect=if (not (substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState))
                           then StateSelect.prefer else StateSelect.default),
          X(start=X_start),
          d(start=rho_nominal)) "Medium properties";

        Modelica.SIunits.Energy U "Internal energy of fluid";
        Modelica.SIunits.Mass m "Mass of fluid";
        Modelica.SIunits.Mass[Medium.nXi] mXi
          "Masses of independent components in the fluid";
        Modelica.SIunits.Mass[Medium.nC] mC
          "Masses of trace substances in the fluid";
        // C need to be added here because unlike for Xi, which has medium.Xi,
        // there is no variable medium.C
        Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)
          "Trace substance mixture content";

        Modelica.SIunits.MassFlowRate mb_flow "Mass flows across boundaries";
        Modelica.SIunits.MassFlowRate[Medium.nXi] mbXi_flow
          "Substance mass flows across boundaries";
        Medium.ExtraPropertyFlowRate[Medium.nC] mbC_flow
          "Trace substance mass flows across boundaries";
        Modelica.SIunits.EnthalpyFlowRate Hb_flow
          "Enthalpy flow across boundaries or energy source/sink";

        // Inputs that need to be defined by an extending class
        input Modelica.SIunits.Volume fluidVolume "Volume";

        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transfered into the medium"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(unit="kg/s")
          "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,0},{-100,40}})));

        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg",
                                                   start=hStart)
          "Leaving enthalpy of the component"
           annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));
        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));
      protected
        Medium.EnthalpyFlowRate ports_H_flow[nPorts];
        Modelica.SIunits.MassFlowRate ports_mXi_flow[nPorts,Medium.nXi];
        Medium.ExtraPropertyFlowRate ports_mC_flow[nPorts,Medium.nC];

        parameter Modelica.SIunits.Density rho_nominal=Medium.density(
         Medium.setState_pTX(
           T=T_start,
           p=p_start,
           X=X_start[1:Medium.nXi])) "Density, used to compute fluid mass";

        // Parameter that is used to construct the vector mXi_flow
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";
        parameter Modelica.SIunits.SpecificEnthalpy hStart=
          Medium.specificEnthalpy_pTX(p_start, T_start, X_start)
          "Start value for specific enthalpy";
      initial equation
        // Assert that the substance with name 'water' has been found.
        assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
            "If Medium.nXi > 1, then substance 'water' must be present for one component.'"
               + Medium.mediumName + "'.\n"
               + "Check medium model.");

        // Make sure that if energyDynamics is SteadyState, then
        // massDynamics is also SteadyState.
        // Otherwise, the system of ordinary differential equations may be inconsistent.
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          assert(massDynamics == energyDynamics, "
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
        end if;

        // initialization of balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
            medium.T = T_start;
        else
          if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
              der(medium.T) = 0;
          end if;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          if initialize_p then
            medium.p = p_start;
          end if;
        else
          if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            if initialize_p then
              der(medium.p) = 0;
            end if;
          end if;
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          medium.Xi = X_start[1:Medium.nXi];
        else
          if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(medium.Xi) = zeros(Medium.nXi);
          end if;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          C = C_start[1:Medium.nC];
        else
          if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(C) = zeros(Medium.nC);
          end if;
        end if;

      equation
        // Total quantities
        m = fluidVolume*medium.d;
        mXi = m*medium.Xi;
        U = m*medium.u*mFactor;
        mC = m*C;

        hOut = medium.h;
        XiOut = medium.Xi;
        COut = C;

        for i in 1:nPorts loop
          ports_H_flow[i]     = ports[i].m_flow * actualStream(ports[i].h_outflow)
            "Enthalpy flow";
          ports_mXi_flow[i,:] = ports[i].m_flow * actualStream(ports[i].Xi_outflow)
            "Component mass flow";
          ports_mC_flow[i,:]  = ports[i].m_flow * actualStream(ports[i].C_outflow)
            "Trace substance mass flow";
        end for;

        for i in 1:Medium.nXi loop
          mbXi_flow[i] = sum(ports_mXi_flow[:,i]);
        end for;

        for i in 1:Medium.nC loop
          mbC_flow[i]  = sum(ports_mC_flow[:,i]);
        end for;

        mb_flow = sum(ports.m_flow);
        Hb_flow = sum(ports_H_flow);

        // Energy and mass balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = Hb_flow + Q_flow;
        else
          der(U) = Hb_flow + Q_flow;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = mb_flow + mWat_flow;
        else
          der(m) = mb_flow + mWat_flow;
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nXi) = mbXi_flow + mWat_flow * s;
        else
          der(mXi) = mbXi_flow + mWat_flow * s;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nC)  = mbC_flow;
        else
          der(mC)  = mbC_flow;
        end if;

        // Properties of outgoing flows
        for i in 1:nPorts loop
            ports[i].p          = medium.p;
            ports[i].h_outflow  = medium.h;
            ports[i].Xi_outflow = medium.Xi;
            ports[i].C_outflow  = C;
        end for;

        annotation (
          Documentation(info="<html>
<p>
Basic model for an ideally mixed fluid volume with the ability to store mass and energy.
It implements a dynamic or a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>
<h4>Implementation</h4>
<p>
When extending or instantiating this model, the input
<code>fluidVolume</code>, which is the actual volume occupied by the fluid,
needs to be assigned.
For most components, this can be set to a parameter.
</p>
Input connectors of the model are
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium, and
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium.
</li>
</ul>
<p>
The model can be used as a dynamic model or as a steady-state model.
However, for a steady-state model with exactly two fluid ports connected,
the model
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation\">
Buildings.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
provides a more efficient implementation.
</p>
<p>
For a model that instantiates this model, see
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Set start attributes in <code>medium</code> to avoid in OpenModelica the warning
alias set with several free start values.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.<br/>
Corrected the syntax error
<code>Medium.ExtraProperty C[Medium.nC](each nominal=C_nominal)</code>
to
<code>Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)</code>
because <code>C_nominal</code> is a vector.
This syntax error caused a compilation error in OpenModelica.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
July 31, 2011 by Michael Wetter:<br/>
Added test to stop model translation if the setting for
<code>energyBalance</code> and <code>massBalance</code>
can lead to inconsistent equations.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Removed the option to use <code>h_start</code>, as this
is not needed for building simulation.
Also removed the reference to <code>Modelica.Fluid.System</code>.
Moved parameters and medium to
<a href=\"Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start value for medium density.
</li>
<li>
March 29, 2011 by Michael Wetter:<br/>
Changed default value for <code>substanceDynamics</code> and
<code>traceDynamics</code> from <code>energyDynamics</code>
to <code>massDynamics</code>.
</li>
<li>
September 28, 2010 by Michael Wetter:<br/>
Changed array index for nominal value of <code>Xi</code>.
<li>
September 13, 2010 by Michael Wetter:<br/>
Set nominal attributes for medium based on default medium values.
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added parameter <code>C_nominal</code> which is used as the nominal attribute for <code>C</code>.
Without this value, the ODE solver gives wrong results for concentrations around 1E-7.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li><i>February 6, 2010</i> by Michael Wetter:<br/>
Added to <code>Medium.BaseProperties</code> the initialization
<code>X(start=X_start[1:Medium.nX])</code>. Previously, the initialization
was only done for <code>Xi</code> but not for <code>X</code>, which caused the
medium to be initialized to <code>reference_X</code>, ignoring the value of <code>X_start</code>.
</li>
<li><i>October 12, 2009</i> by Michael Wetter:<br/>
Implemented first version in <code>Buildings</code> library, based on model from
<code>Modelica.Fluid 1.0</code>.
</li>
</ul>
</html>"),Icon(graphics={            Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-89,17},{-54,34}},
                lineColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-89,52},{-54,69}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-42,-28},{-6,-28},{18,4},{40,12},{66,14}},
                color={255,255,255},
                smooth=Smooth.Bezier),
              Text(
                extent={{-155,-120},{145,-160}},
                lineColor={0,0,255},
                textString="%name")}));
      end ConservationEquation;

      record LumpedVolumeDeclarations "Declarations for lumped volumes"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choicesAllMatching = true);

        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Formulation of energy balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Formulation of mass balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics substanceDynamics=energyDynamics
          "Formulation of substance balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics traceDynamics=energyDynamics
          "Formulation of trace substance balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start=Medium.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX] = Medium.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
             quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Medium.ExtraProperty C_nominal[Medium.nC](
             quantity=Medium.extraPropertiesNames) = fill(1E-2, Medium.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Real mFactor=1
          "Factor to scale the thermal mass of the volume"
          annotation(Dialog(tab="Advanced"));

      annotation (preferredView="info",
      Documentation(info="<html>
<p>
This class contains parameters and medium properties
that are used in the lumped  volume model, and in models that extend the
lumped volume model.
</p>
<p>
These parameters are used by
<a href=\"modelica://Buildings.Fluid.Interfaces.ConservationEquation\">
Buildings.Fluid.Interfaces.ConservationEquation</a>,
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a>,
<a href=\"modelica://Buildings.Rooms.MixedAir\">
Buildings.Rooms.MixedAir</a>, and by
<a href=\"modelica://Buildings.Rooms.BaseClasses.MixedAir\">
Buildings.Rooms.BaseClasses.MixedAir</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
August 2, 2011, by Michael Wetter:<br/>
Set <code>substanceDynamics</code> and <code>traceDynamics</code> to final
and equal to <code>energyDynamics</code>,
as there is no need to make them different from <code>energyDynamics</code>.
</li>
<li>
August 1, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.DynamicFreeInitial</code> because
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code> leads
to high order DAE that Dymola cannot reduce.
</li>
<li>
July 31, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LumpedVolumeDeclarations;

      partial model PartialTwoPort "Partial component with two ports"
        import Modelica.Constants;

        replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choicesAllMatching = true);

        parameter Boolean allowFlowReversal = true
          "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a(
          redeclare final package Medium = Medium,
           m_flow(min=if allowFlowReversal then -Constants.inf else 0))
          "Fluid connector a (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(
          redeclare final package Medium = Medium,
          m_flow(max=if allowFlowReversal then +Constants.inf else 0))
          "Fluid connector b (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{110,-10},{90,10}}), iconTransformation(extent={{110,-10},{90,10}})));
        // Model structure, e.g., used for visualization
      protected
        parameter Boolean port_a_exposesState = false
          "= true if port_a exposes the state of a fluid volume";
        parameter Boolean port_b_exposesState = false
          "= true if port_b.p exposes the state of a fluid volume";
        parameter Boolean showDesignFlowDirection = true
          "= false to hide the arrow in the model icon";

        annotation (
          Documentation(info="<html>
<p>
This partial model defines an interface for components with two ports.
The treatment of the design flow direction and of flow reversal are predefined based on the parameter <code>allowFlowReversal</code>.
The component may transport fluid and may have internal storage for a given fluid <code>Medium</code>.
</p>
<p>
An extending model providing direct access to internal storage of mass or energy through <code>port_a</code> or <code>port_b</code>
should redefine the protected parameters <code>port_a_exposesState</code> and <code>port_b_exposesState</code> appropriately.
This will be visualized at the port icons, in order to improve the understanding of fluid model diagrams.
</p>
<h4>Implementation</h4>
<p>
This model is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>
but it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, an in practice,
users have not used this global definition to assign parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
Declared medium in ports to be <code>final</code>.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
              Polygon(
                points={{20,-70},{60,-85},{20,-100},{20,-70}},
                lineColor={0,128,255},
                smooth=Smooth.None,
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=showDesignFlowDirection),
              Polygon(
                points={{20,-75},{50,-85},{20,-95},{20,-75}},
                lineColor={255,255,255},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                visible=allowFlowReversal),
              Line(
                points={{55,-85},{-60,-85}},
                color={0,128,255},
                smooth=Smooth.None,
                visible=showDesignFlowDirection),
              Text(
                extent={{-149,-114},{151,-154}},
                lineColor={0,0,255},
                textString="%name"),
              Ellipse(
                extent={{-110,26},{-90,-24}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                visible=port_a_exposesState),
              Ellipse(
                extent={{90,25},{110,-25}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                visible=port_b_exposesState)}));
      end PartialTwoPort;

      partial model PartialTwoPortInterface
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialTwoPort(
          port_a(p(start=Medium.p_default)),
          port_b(p(start=Medium.p_default)));

        parameter Modelica.SIunits.MassFlowRate m_flow_nominal
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
         parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));

        Modelica.SIunits.MassFlowRate m_flow(start=0) = port_a.m_flow
          "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
        Modelica.SIunits.Pressure dp(start=0, displayUnit="Pa")
          "Pressure difference between port_a and port_b";

        Medium.ThermodynamicState sta_a=
            Medium.setState_phX(port_a.p,
                                noEvent(actualStream(port_a.h_outflow)),
                                noEvent(actualStream(port_a.Xi_outflow))) if
               show_T "Medium properties in port_a";

        Medium.ThermodynamicState sta_b=
            Medium.setState_phX(port_b.p,
                                noEvent(actualStream(port_b.h_outflow)),
                                noEvent(actualStream(port_b.Xi_outflow))) if
                show_T "Medium properties in port_b";
      equation
        dp = port_a.p - port_b.p;
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models that
transports a fluid between two ports. It is similar to
<a href=\"Modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>, but it does not
include the species balance
</p>
<pre>
  port_b.Xi_outflow = inStream(port_a.Xi_outflow);
</pre>
<p>
Thus, it can be used as a base class for a heat <i>and</i> mass transfer component
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations. See for example
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a</code> and <code>sta_b</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>. Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definition of <code>dp</code> because it causes some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Changed condition to remove <code>sta_a</code> to also
compute the state at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
March 11, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortInterface;

      partial model PartialTwoPortTransport
        "Partial element transporting fluid between two ports without storage of mass or energy"
        extends Buildings.Fluid.Interfaces.PartialTwoPort(
          final port_a_exposesState=false,
          final port_b_exposesState=false);

        // Advanced
        // Note: value of dp_start shall be refined by derived model,
        // based on local dp_nominal
        parameter Medium.AbsolutePressure dp_start = 0
          "Guess value of dp = port_a.p - port_b.p"
          annotation(Dialog(tab = "Advanced", enable=from_dp));
        parameter Medium.MassFlowRate m_flow_start = 0
          "Guess value of m_flow = port_a.m_flow"
          annotation(Dialog(tab = "Advanced", enable=not from_dp));
        // Note: value of m_flow_small shall be refined by derived model,
        // based on local m_flow_nominal
        parameter Medium.MassFlowRate m_flow_small
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));

        // Diagnostics
        parameter Boolean show_T = true
          "= true, if temperatures at port_a and port_b are computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
        parameter Boolean show_V_flow = true
          "= true, if volume flow rate at inflowing port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));

        // Variables
        Medium.MassFlowRate m_flow(
           min=if allowFlowReversal then -Modelica.Constants.inf else 0,
           start = m_flow_start) "Mass flow rate in design flow direction";
        Modelica.SIunits.Pressure dp(start=dp_start)
          "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";

        Modelica.SIunits.VolumeFlowRate V_flow=
            m_flow/Modelica.Fluid.Utilities.regStep(m_flow,
                        Medium.density(state_a),
                        Medium.density(state_b),
                        m_flow_small) if show_V_flow
          "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";

        Medium.Temperature port_a_T=
            Modelica.Fluid.Utilities.regStep(port_a.m_flow,
                        Medium.temperature(state_a),
                        Medium.temperature(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow)),
                        m_flow_small) if show_T
          "Temperature close to port_a, if show_T = true";
        Medium.Temperature port_b_T=
            Modelica.Fluid.Utilities.regStep(port_b.m_flow,
                        Medium.temperature(state_b),
                        Medium.temperature(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow)),
                        m_flow_small) if show_T
          "Temperature close to port_b, if show_T = true";
      protected
        Medium.ThermodynamicState state_a
          "state for medium inflowing through port_a";
        Medium.ThermodynamicState state_b
          "state for medium inflowing through port_b";
      equation
        // medium states
        state_a = Medium.setState_phX(
                    port_a.p,
                    inStream(port_a.h_outflow),
                    inStream(port_a.Xi_outflow));
        state_b = Medium.setState_phX(
                    port_b.p,
                    inStream(port_b.h_outflow),
                    inStream(port_b.Xi_outflow));

        // Pressure drop in design flow direction
        dp = port_a.p - port_b.p;

        // Design direction of mass flow rate
        m_flow = port_a.m_flow;
        assert(m_flow > -m_flow_small or allowFlowReversal,
            "Reverting flow occurs even though allowFlowReversal is false");

        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;

        // Transport of substances
        port_a.Xi_outflow = inStream(port_b.Xi_outflow);
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = inStream(port_b.C_outflow);
        port_b.C_outflow = inStream(port_a.C_outflow);

        annotation (
          Documentation(info="<html>
<p>
This component transports fluid between its two ports, without storing mass or energy.
Energy may be exchanged with the environment though, e.g., in the form of work.
<code>PartialTwoPortTransport</code> is intended as base class for devices like orifices, valves and simple fluid machines.</p>
<p>
Three equations need to be added by an extending class using this component:
</p>
<ul>
<li>The momentum balance specifying the relationship between the pressure drop <code>dp</code> and the mass flow rate <code>m_flow</code>,</li>
<li><code>port_b.h_outflow</code> for flow in design direction, and</li>
<li><code>port_a.h_outflow</code> for flow in reverse direction.</li>
</ul>
<p>
Moreover appropriate values shall be assigned to the following parameters:
</p>
<ul>
<li><code>dp_start</code> for a guess of the pressure drop</li>
<li><code>m_flow_small</code> for regularization of zero flow.</li>
</ul>
<h4>Implementation</h4>
<p>
This is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>
except that it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, an in practice,
users have not used this global definition to assign parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortTransport;

      model StaticTwoPortConservationEquation
        "Partial model for static energy and mass conservation equations"
        extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
        showDesignFlowDirection = false);

        constant Boolean sensibleOnly "Set to true if sensible exchange only";

        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transfered into the medium"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(unit="kg/s")
          "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));

        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg",
                                                   start=Medium.specificEnthalpy_pTX(
                                                           p=Medium.p_default,
                                                           T=Medium.T_default,
                                                           X=Medium.X_default))
          "Leaving temperature of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));

        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));

        constant Boolean use_safeDivision=true
          "Set to true to improve numerical robustness";
      protected
        Real m_flowInv(unit="s/kg") "Regularization of 1/m_flow";

        Modelica.SIunits.MassFlowRate mXi_flow[Medium.nXi]
          "Mass flow rates of independent substances added to the medium";

        // Parameters that is used to construct the vector mXi_flow
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";

      initial equation
        // Assert that the substance with name 'water' has been found.
        assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
            "If Medium.nXi > 1, then substance 'water' must be present for one component.'"
               + Medium.mediumName + "'.\n"
               + "Check medium model.");

      equation
       // Species flow rate from connector mWat_flow
       mXi_flow = mWat_flow * s;
        // Regularization of m_flow around the origin to avoid a division by zero
       if use_safeDivision then
          m_flowInv = Buildings.Utilities.Math.Functions.inverseXRegularized(x=port_a.m_flow, delta=m_flow_small/1E3);
       else
           m_flowInv = 0; // m_flowInv is not used if use_safeDivision = false.
       end if;

       if allowFlowReversal then
         // Formulate hOut using spliceFunction. This avoids an event iteration.
         // The introduced error is small because deltax=m_flow_small/1e3
         hOut = Buildings.Utilities.Math.Functions.spliceFunction(pos=port_b.h_outflow,
                                                                  neg=port_a.h_outflow,
                                                                  x=port_a.m_flow,
                                                                  deltax=m_flow_small/1E3);
         XiOut = Buildings.Utilities.Math.Functions.spliceFunction(pos=port_b.Xi_outflow,
                                                                  neg=port_a.Xi_outflow,
                                                                  x=port_a.m_flow,
                                                                  deltax=m_flow_small/1E3);
         COut = Buildings.Utilities.Math.Functions.spliceFunction(pos=port_b.C_outflow,
                                                                  neg=port_a.C_outflow,
                                                                  x=port_a.m_flow,
                                                                  deltax=m_flow_small/1E3);
       else
         hOut =  port_b.h_outflow;
         XiOut = port_b.Xi_outflow;
         COut =  port_b.C_outflow;
       end if;

        //////////////////////////////////////////////////////////////////////////////////////////
        // Energy balance and mass balance
        if sensibleOnly then
          // Mass balance
          port_a.m_flow = -port_b.m_flow;
          // Energy balance
          if use_safeDivision then
            port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
            port_a.h_outflow = inStream(port_b.h_outflow) - Q_flow * m_flowInv;
          else
            port_a.m_flow * (inStream(port_a.h_outflow) - port_b.h_outflow) = -Q_flow;
            port_a.m_flow * (inStream(port_b.h_outflow) - port_a.h_outflow) = +Q_flow;
          end if;
          // Transport of species
          port_a.Xi_outflow = inStream(port_b.Xi_outflow);
          port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          // Transport of trace substances
          port_a.C_outflow = inStream(port_b.C_outflow);
          port_b.C_outflow = inStream(port_a.C_outflow);
        else
          // Mass balance (no storage)
          port_a.m_flow + port_b.m_flow = -mWat_flow;
          // Energy balance.
          // This equation is approximate since m_flow = port_a.m_flow is used for the mass flow rate
          // at both ports. Since mWat_flow << m_flow, the error is small.
          if use_safeDivision then
            port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
            port_a.h_outflow = inStream(port_b.h_outflow) - Q_flow * m_flowInv;
            // Transport of species
            port_b.Xi_outflow = inStream(port_a.Xi_outflow) + mXi_flow * m_flowInv;
            port_a.Xi_outflow = inStream(port_b.Xi_outflow) - mXi_flow * m_flowInv;
           else
            port_a.m_flow * (inStream(port_a.h_outflow) - port_b.h_outflow) = -Q_flow;
            port_a.m_flow * (inStream(port_b.h_outflow) - port_a.h_outflow) = +Q_flow;
            // Transport of species
            port_a.m_flow * (inStream(port_a.Xi_outflow) - port_b.Xi_outflow) = -mXi_flow;
            port_a.m_flow * (inStream(port_b.Xi_outflow) - port_a.Xi_outflow) = +mXi_flow;
           end if;

          // Transport of trace substances
         port_a.m_flow*port_a.C_outflow = -port_b.m_flow*inStream(port_b.C_outflow);
         port_b.m_flow*port_b.C_outflow = -port_a.m_flow*inStream(port_a.C_outflow);

        end if; // sensibleOnly

        //////////////////////////////////////////////////////////////////////////////////////////
        // No pressure drop in this model
        port_a.p = port_b.p;

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This model transports fluid between its two ports, without storing mass or energy.
It implements a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>
<h4>Implementation</h4>
Input connectors of the model are
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium, and
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium.
</li>
</ul>

<p>
The model can only be used as a steady-state model with two fluid ports.
For a model with a dynamic balance, and more fluid ports, use
<a href=\"modelica://Buildings.Fluid.Interfaces.ConservationEquation\">
Buildings.Fluid.Interfaces.ConservationEquation</a>.
</p>
<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
October 21, 2013 by Michael Wetter:<br/>
Corrected sign error in the equation that is used if <code>use_safeDivision=false</code>
and <code>sensibleOnly=true</code>.
This only affects internal numerical tests, but not any examples in the library
as the constant <code>use_safeDivision</code> is set to <code>true</code> by default.
</li>
<li>
September 25, 2013 by Michael Wetter:<br/>
Reformulated computation of outlet properties to avoid an event at zero mass flow rate.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.
</li>
<li>
May 7, 2013 by Michael Wetter:<br/>
Removed <code>for</code> loops for species balance and trace substance balance,
as they cause the error <code>Error: Operand port_a.Xi_outflow[1] to operator inStream is not a stream variable.</code>
in OpenModelica.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
June 22, 2012 by Michael Wetter:<br/>
Reformulated implementation with <code>m_flowInv</code> to use <code>port_a.m_flow * ...</code>
if <code>use_safeDivision=false</code>. This avoids a division by zero if
<code>port_a.m_flow=0</code>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>Buildings.Fluid.Interfaces</code>.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-93,72},{-58,89}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Text(
                extent={{-93,37},{-58,54}},
                lineColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-41,103},{-10,117}},
                lineColor={0,0,127},
                textString="hOut"),
              Text(
                extent={{10,103},{41,117}},
                lineColor={0,0,127},
                textString="XiOut"),
              Text(
                extent={{61,103},{92,117}},
                lineColor={0,0,127},
                textString="COut"),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{6,14},{6,-37}},     color={255,255,255}),
              Line(points={{54,14},{6,14}},     color={255,255,255}),
              Line(points={{6,-37},{-42,-37}},  color={255,255,255})}));
      end StaticTwoPortConservationEquation;

      record TwoPortFlowResistanceParameters
        "Parameters for flow resistance for models with two ports"

        parameter Boolean computeFlowResistance = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance"));

        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance,
                      tab="Flow resistance"));
        parameter Modelica.SIunits.Pressure dp_nominal(min=0, displayUnit="Pa")
          "Pressure"                                annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance,
                     tab="Flow resistance"));
        parameter Real deltaM = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance, tab="Flow resistance"));

      annotation (preferredView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in models that have one fluid stream.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
PartialTwoPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TwoPortFlowResistanceParameters;

      model TwoPortHeatMassExchanger
        "Partial model transporting one fluid stream with storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
          port_a(h_outflow(start=h_outflow_start)),
          port_b(h_outflow(start=h_outflow_start)));
        extends Buildings.Fluid.Interfaces.TwoPortFlowResistanceParameters(
          final computeFlowResistance=true);

        parameter Modelica.SIunits.Time tau = 30
          "Time constant at nominal flow (if energyDynamics <> SteadyState)"
           annotation (Dialog(tab = "Dynamics", group="Nominal condition"));

        // Advanced
        parameter Boolean homotopyInitialization = true
          "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        // Dynamics
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Formulation of energy balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Formulation of mass balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start = Medium.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX] = Medium.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
             quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));

        replaceable Buildings.Fluid.MixingVolumes.MixingVolume vol
        constrainedby
          Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
          redeclare final package Medium = Medium,
          nPorts = 2,
          V=m_flow_nominal*tau/rho_default,
          final m_flow_nominal = m_flow_nominal,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start) "Volume for fluid stream"
           annotation (Placement(transformation(extent={{-9,0},{11,-20}})));

        Buildings.Fluid.FixedResistances.FixedResistanceDpM preDro(
          redeclare final package Medium = Medium,
          final use_dh=false,
          final m_flow_nominal=m_flow_nominal,
          final deltaM=deltaM,
          final allowFlowReversal=allowFlowReversal,
          final show_T=false,
          final from_dp=from_dp,
          final linearized=linearizeFlowResistance,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp_nominal) "Pressure drop model"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));

      protected
        parameter Medium.ThermodynamicState sta_default=Medium.setState_pTX(
            T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.SIunits.Density rho_default=Medium.density(sta_default)
          "Density, used to compute fluid volume";
        parameter Medium.ThermodynamicState sta_start=Medium.setState_pTX(
            T=T_start, p=p_start, X=X_start);
        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_start = Medium.specificEnthalpy(sta_start)
          "Start value for outflowing enthalpy";

      initial algorithm
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau > Modelica.Constants.eps,
      "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = "       + String(tau) + "\n");
        assert((massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau > Modelica.Constants.eps,
      "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = "       + String(tau) + "\n");

      equation
        connect(vol.ports[2], port_b) annotation (Line(
            points={{1,0},{100,0}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(port_a, preDro.port_a) annotation (Line(
            points={{-100,0},{-90,0},{-90,0},{-80,0},{-80,0},{-60,0}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(preDro.port_b, vol.ports[1]) annotation (Line(
            points={{-40,0},{1,0}},
            color={0,127,255},
            smooth=Smooth.None));
        annotation (
          Documentation(info="<html>
<p>
This component transports one fluid stream.
It provides the basic model for implementing dynamic and steady-state
models that exchange heat and water vapor with the fluid stream.
The model also computes the pressure drop due to the flow resistance.
By setting the parameter <code>dp_nominal=0</code>, the computation
of the pressure drop can be avoided.
The variable <code>vol.heatPort.T</code> always has the value of
the temperature of the medium that leaves the component.
For the actual temperatures at the port, the variables <code>sta_a.T</code>
and <code>sta_b.T</code> can be used. These two variables are provided by
the base class
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
Buildings.Fluid.Interfaces.PartialTwoPortInterface</a>.
</p>

For models that extend this model, see for example
<ul>
<li>
the ideal heater or cooler
<a href=\"modelica://Buildings.Fluid.HeatExchangers.HeaterCoolerPrescribed\">
Buildings.Fluid.HeatExchangers.HeaterCoolerPrescribed</a>,
</li>
<li>
the ideal humidifier
<a href=\"modelica://Buildings.Fluid.MassExchangers.HumidifierPrescribed\">
Buildings.Fluid.MassExchangers.HumidifierPrescribed</a>, and
</li>
<li>
the boiler
<a href=\"modelica://Buildings.Fluid.Boilers.BoilerPolynomial\">
Buildings.Fluid.Boilers.BoilerPolynomial</a>.
</li>
</ul>

<h4>Implementation</h4>
<p>
The variable names follow the conventions used in
<a href=\"modelica://Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX\">
Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX
</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in pressure drop element to be final.
</li>
<li>
May 28, 2014, by Michael Wetter:<br/>
Removed <code>annotation(Evaluate=true)</code> for parameter <code>tau</code>.
This is needed to allow changing the time constant after translation.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
October 17, 2012, by Michael Wetter:<br/>
Fixed broken link in documentation.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Removed assignment of <code>m_flow_small</code> as it is no
longer used in the pressure drop model.
</li>
<li>
January 15, 2011, by Michael Wetter:<br/>
Fixed wrong class reference in information section.
</li>
<li>
September 13, 2011, by Michael Wetter:<br/>
Changed assignment of <code>vol(mass/energyDynamics=...)</code> as the
previous assignment caused a non-literal start value that was ignored.
</li>
<li>
July 29, 2011, by Michael Wetter:<br/>
Added start value for outflowing enthalpy.
</li>
<li>
July 11, 2011, by Michael Wetter:<br/>
Changed parameterization of fluid volume so that steady-state balance is
used when <code>tau = 0</code>.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Removed temperature sensor and changed implementation of fluid volume
to allow use of this model for the steady-state and dynamic humidifier
<a href=\"modelica://Buildings.Fluid.MassExchangers.HumidifierPrescribed\">
Buildings.Fluid.MassExchangers.HumidifierPrescribed</a>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
January 29, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,60},{70,-60}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-101,6},{100,-4}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{0,-4},{100,6}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid)}));
      end TwoPortHeatMassExchanger;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains basic classes that are used to build
component models that change the state of the
fluid. The classes are not directly usable, but can
be extended when building a new model.
</p>
</html>"));
    end Interfaces;
  annotation (
  preferredView="info", Documentation(info="<html>
This package contains components for fluid flow systems such as
pumps, valves and sensors. For other fluid flow models, see
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a>.
</html>"),
  Icon(graphics={
          Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}},
              lineColor={0,0,0}),
          Line(points={{2,42},{2,-10}}, color={0,0,0}),
          Rectangle(
            extent={{-18,50},{22,42}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid)}));
  end Fluid;

  package HeatTransfer "Package with heat transfer models"
    extends Modelica.Icons.Package;

    package Conduction "Package with models for heat conduction"
      extends Modelica.Icons.VariantsPackage;

      model SingleLayer "Model for single layer heat conductance"
        extends Buildings.HeatTransfer.Conduction.BaseClasses.PartialConductor(
         final R=if (material.R == 0) then material.x/material.k/A else material.R/A);
         // if material.R == 0, then the material specifies material.k, and this model specifies x
         // For resistances, material.k need not be specified, and hence we use material.R
        // The value T[:].start is used by the solver when finding initial states
        // that satisfy dT/dt=0, which requires solving a system of nonlinear equations
        // if the convection coefficient is a function of temperature.
        Modelica.SIunits.Temperature T[nSta](start=
           {T_a_start+(T_b_start-T_a_start) * UA *
              sum(1/(if (k==1 or k==nSta+1) then UAnSta2 else UAnSta) for k in 1:i) for i in 1:nSta},
            each nominal = 300) "Temperature at the states";
        Modelica.SIunits.HeatFlowRate Q_flow[nSta+1]
          "Heat flow rate from state i to i+1";
        Modelica.SIunits.SpecificInternalEnergy u[nSta](start=
           material.c*{T_a_start+(T_b_start-T_a_start) * UA *
              sum(1/(if (k==1 or k==nSta+1) then UAnSta2 else UAnSta) for k in 1:i) for i in 1:nSta},
              each nominal = 270000)
          "Definition of specific internal energy (enthalpy in solids)!";
        replaceable parameter Data.BaseClasses.Material material
          "Material from Data.Solids, Data.SolidsPCM or Data.Resistances"
          annotation (choicesAllMatching=true, Placement(transformation(extent={{60,60},
                  {80,80}})));

        parameter Boolean steadyStateInitial=false
          "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
              annotation (Dialog(group="Initialization"), Evaluate=true);
        parameter Modelica.SIunits.Temperature T_a_start=293.15
          "Initial temperature at port_a, used if steadyStateInitial = false"
          annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
        parameter Modelica.SIunits.Temperature T_b_start=293.15
          "Initial temperature at port_b, used if steadyStateInitial = false"
          annotation (Dialog(group="Initialization", enable=not steadyStateInitial));

      protected
        final parameter Integer nSta(min=1) = material.nSta
          "Number of state variables";
        final parameter Modelica.SIunits.ThermalConductance UAnSta = UA*nSta
          "Thermal conductance between nodes";
        final parameter Modelica.SIunits.ThermalConductance UAnSta2 = 2*UAnSta
          "Thermal conductance between nodes and surface boundary";
        parameter Modelica.SIunits.Mass m = A*material.x*material.d/material.nSta
          "Mass associated with the temperature state";
        parameter Modelica.SIunits.HeatCapacity C = m*material.c
          "Heat capacity associated with the temperature state";

        parameter Modelica.SIunits.SpecificInternalEnergy ud[Buildings.HeatTransfer.Conduction.nSupPCM](each fixed=false)
          "Support points for derivatives (used for PCM)";
        parameter Modelica.SIunits.Temperature Td[Buildings.HeatTransfer.Conduction.nSupPCM](each fixed=false)
          "Support points for derivatives (used for PCM)";
        parameter Real dT_du[Buildings.HeatTransfer.Conduction.nSupPCM](each fixed=false, each unit="kg.K2/J")
          "Derivatives dT/du at the support points (used for PCM)";

      initial equation
        // The initialization is only done for materials that store energy.
          if not material.steadyState then
            if steadyStateInitial then
              if material.phasechange then
                der(u) = zeros(nSta);
              else
                der(T) = zeros(nSta);
              end if;
            else
              for i in 1:nSta loop
                T[i] = T_a_start+(T_b_start-T_a_start) * UA *
                  sum(1/(if (k==1 or k==nSta+1) then UAnSta2 else UAnSta) for k in 1:i);
              end for;
            end if;
          end if;

         if material.phasechange then
           (ud, Td, dT_du) = Buildings.HeatTransfer.Conduction.BaseClasses.der_temperature_u(
             c=   material.c,
             TSol=material.TSol,
             TLiq=material.TLiq,
             LHea=material.LHea,
             ensureMonotonicity=material.ensureMonotonicity);
         else
           ud    = zeros(Buildings.HeatTransfer.Conduction.nSupPCM);
           Td    = zeros(Buildings.HeatTransfer.Conduction.nSupPCM);
           dT_du = zeros(Buildings.HeatTransfer.Conduction.nSupPCM);
         end if;
      equation
          port_a.Q_flow = +Q_flow[1];
          port_b.Q_flow = -Q_flow[nSta+1];

          port_a.T-T[1] = Q_flow[1]/UAnSta2;
          T[nSta] -port_b.T = Q_flow[nSta+1]/UAnSta2;

          for i in 2:nSta loop
             // Q_flow[i] is heat flowing from (i-1) to (i)
             T[i-1]-T[i] = Q_flow[i]/UAnSta;
          end for;

          // Steady-state heat balance
          if material.steadyState then
            for i in 2:nSta+1 loop
              Q_flow[i] = Q_flow[1];
              if material.phasechange then
                // Phase change material
                T[i-1]=Buildings.HeatTransfer.Conduction.BaseClasses.temperature_u(
                          ud=ud,
                          Td=Td,
                          dT_du=dT_du,
                          u=u[i-1]);
              else
                // Regular material
                u[i-1]=material.c*T[i-1];
              end if;
            end for;
          else
            // Transient heat conduction
            if material.phasechange then
              // Phase change material
              for i in 1:nSta loop
                der(u[i]) = (Q_flow[i]-Q_flow[i+1])/m;
                // Recalculation of temperature based on specific internal energy
                T[i]=Buildings.HeatTransfer.Conduction.BaseClasses.temperature_u(
                          ud=ud,
                          Td=Td,
                          dT_du=dT_du,
                          u=u[i]);
              end for;
            else
              // Regular material
              for i in 1:nSta loop
                der(T[i]) = (Q_flow[i]-Q_flow[i+1])/C;
                u[i]=material.c*T[i];
              end for;
            end if;
          end if;

        annotation ( Icon(coordinateSystem(
                preserveAspectRatio=false,extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-94,4},{92,-4}},
                lineColor={0,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{12,8},{14,8},{16,4},{18,-2},{18,-6},{16,-12},{10,-16},{6,-20},
                    {-2,-22},{-6,-18},{-12,-12},{-14,-2},{-12,4},{-10,8},{-8,10},{-6,
                    12},{-2,14},{2,14},{8,12},{12,8}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-6,-16},{2,-18},{8,-16},{14,-14},{10,-16},{6,-20},{-2,-22},{
                    -8,-20},{-12,-12},{-14,-2},{-12,4},{-10,8},{-8,10},{-10,0},{-10,-8},
                    {-6,-16}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,54},{-42,-60}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Text(
                extent={{-100,-74},{6,-92}},
                lineColor={0,0,255},
                textString="%x"),
              Rectangle(
                extent={{44,54},{62,-60}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Text(
                extent={{8,-68},{86,-98}},
                lineColor={0,0,255},
                textString="%nSta")}),
      defaultComponentName="lay",
          Documentation(info="<html>
This is a model of a heat conductor for a single layer of homogeneous material
that computes transient or steady-state heat conduction.

<h4>Transient heat conduction in materials without phase change</h4>
<p>
If the material is a record that extends
<a href=\"modelica://Buildings.HeatTransfer.Data.Solids\">
Buildings.HeatTransfer.Data.Solids</a> and its
specific heat capacity (as defined by the record <code>material.c</code>)
is non-zero, then this model computes <i>transient</i> heat conduction, i.e., it
computes a numerical approximation to the solution of the heat equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
   &rho; c (&part; T(s,t) &frasl; &part;t) =
    k (&part;&sup2; T(s,t) &frasl; &part;s&sup2;),
</p>
<p>
where
<i>&rho;</i>
is the mass density,
<i>c</i>
is the specific heat capacity per unit mass,
<i>T</i>
is the temperature at location <i>s</i> and time <i>t</i> and
<i>k</i> is the heat conductivity.
At the locations <i>s=0</i> and <i>s=x</i>, where <i>x</i> is the
material thickness, the temperature and heat flow rate is equal to the
temperature and heat flow rate of the heat ports.
</p>
<h4>Transient heat conduction in phase change materials</h4>
<p>
If the material is declared using a record of type
<a href=\"modelica://Buildings.HeatTransfer.Data.SolidsPCM\">
Buildings.HeatTransfer.Data.SolidsPCM</a>, the heat transfer
in a phase change material is computed.
The record <a href=\"modelica://Buildings.HeatTransfer.Data.SolidsPCM\">
Buildings.HeatTransfer.Data.SolidsPCM</a>
declares the solidus temperature <code>TSol</code>,
the liquidus temperature <code>TLiq</code> and the latent heat of
phase transformation <code>LHea</code>.
For heat transfer with phase change, the specific internal energy <i>u</i>
is the dependent variable, rather than the temperature.
Therefore, the governing equation is
</p>
<p align=\"center\" style=\"font-style:italic;\">
   &rho; (&part; u(s,t) &frasl; &part;t) =
    k (&part;&sup2; T(s,t) &frasl; &part;s&sup2;).
</p>
<p>
The constitutive
relation between specific internal energy <i>u</i> and temperature <i>T</i> is defined in
<a href=\"modelica://Buildings.HeatTransfer.Conduction.BaseClasses.enthalpyTemperature\">
Buildings.HeatTransfer.Conduction.BaseClasses.enthalyTemperature</a> by using
cubic hermite spline interpolation with linear extrapolation.
</p>
<h4>Steady-state heat conduction</h4>
<p>
If <code>material.c=0</code>, or if the material extends
<a href=\"modelica://Buildings.HeatTransfer.Data.Resistances\">
Buildings.HeatTransfer.Data.Resistances</a>,
then steady-state heat conduction is computed. In this situation, the heat
flow between its heat ports is
</p>
<p align=\"center\" style=\"font-style:italic;\">
   Q = A &nbsp; k &frasl; x &nbsp; (T<sub>a</sub>-T<sub>b</sub>),
</p>
<p>
where
<i>A</i> is the cross sectional area,
<i>x</i> is the layer thickness,
<i>T<sub>a</sub></i> is the temperature at port a and
<i>T<sub>b</sub></i> is the temperature at port b.
</p>
<h4>Spatial discretization</h4>
<p>
To spatially discretize the heat equation, the construction is
divided into compartments with <code>material.nSta &ge; 1</code> state variables.
The state variables are connected to each other through thermal conductors.
There is also a thermal conductor
between the surfaces and the outermost state variables. Thus, to obtain
the surface temperature, use <code>port_a.T</code> (or <code>port_b.T</code>)
and not the variable <code>T[1]</code>.
Each compartment has the same material properties.
To build multi-layer constructions,
use
<a href=\"Buildings.HeatTransfer.Conduction.MultiLayer\">
Buildings.HeatTransfer.Conduction.MultiLayer</a> instead of this model.
</p>

</html>",
      revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed the input argument for the function
<code>Buildings.HeatTransfer.Conduction.BaseClasses.der_temperature_u</code>
from type
<code>Buildings.HeatTransfer.Data.BaseClasses.Material</code>
to the elements of this type as OpenModelica fails to translate the
model if the input to this function is a record.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
January 22, 2013, by Armin Teskeredzic:<br/>
Implementation of phase-change materials based on enthalpy-linearisation method.
Phase-change properties defined in <code>material</code> record and relationship
between enthalpy and temperature defined in the <code>EnthalpyTemperature</code> function.
</li>
<li>
March 9, 2012, by Michael Wetter:<br/>
Removed protected variable <code>der_T</code> as it is not required.
</li>
<li>
March 6 2010, by Michael Wetter:<br/>
Changed implementation to allow steady-state and transient heat conduction
depending on the specific heat capacity of the material. This allows using the
same model in composite constructions in which some layers are
computed steady-state and other transient.
</li><li>
February 5 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end SingleLayer;

      model MultiLayer
        "Model for heat conductance through a solid with multiple material layers"
        extends Buildings.HeatTransfer.Conduction.BaseClasses.PartialConductor(
         final R=sum(layers.material[i].R for i in 1:nLay));
        Modelica.SIunits.Temperature T[sum(nSta)](each nominal = 300)
          "Temperature at the states";
        Modelica.SIunits.HeatFlowRate Q_flow[sum(nSta)+nLay]
          "Heat flow rate from state i to i+1";
        extends
          Buildings.HeatTransfer.Conduction.BaseClasses.PartialConstruction;

      protected
        Buildings.HeatTransfer.Conduction.SingleLayer[layers.nLay] lay(
         each final A=A,
         material = {layers.material[i] for i in 1:layers.nLay},
         T_a_start = _T_a_start,
         T_b_start = _T_b_start,
         each steadyStateInitial = steadyStateInitial) "Material layer"
          annotation (Placement(transformation(extent={{-20,-10},{0,10}})));

        final parameter Modelica.SIunits.Temperature _T_a_start[nLay](each fixed=false)
          "Initial temperature at port_a of respective layer, used if steadyStateInitial = false";
        final parameter Modelica.SIunits.Temperature _T_b_start[nLay](each fixed=false)
          "Initial temperature at port_b of respective layer, used if steadyStateInitial = false";

      initial equation
        _T_a_start = { T_b_start+(T_a_start-T_b_start) * 1/R *
          sum(layers.material[k].R for k in i:nLay) for i in 1:nLay};
        _T_b_start = { T_a_start+(T_b_start-T_a_start) * 1/R *
          sum(layers.material[k].R for k in 1:i) for i in 1:nLay};
      equation
        // This section assigns the temperatures and heat flow rates of the layer models to
        // an array that makes plotting the results easier.
        for i in 1:nLay loop
          for j in 1:nSta[i] loop
            T[sum(nSta[k] for k in 1:(i-1)) +j] = lay[i].T[j];
          end for;
          for j in 1:nSta[i]+1 loop
            Q_flow[sum(nSta[k] for k in 1:i-1)+(i-1)+j] = lay[i].Q_flow[j];
          end for;
        end for;
        connect(port_a, lay[1].port_a) annotation (Line(
            points={{-100,5.55112e-16},{-60,5.55112e-16},{-60,6.10623e-16},{-20,
                6.10623e-16}},
            color={191,0,0},
            smooth=Smooth.None));
        for i in 1:nLay-1 loop
        connect(lay[i].port_b, lay[i+1].port_a) annotation (Line(
            points={{5.55112e-16,6.10623e-16},{20,6.10623e-16},{20,-20},{-40,-20},{
                  -40,6.10623e-16},{-20,6.10623e-16}},
            color={191,0,0},
            smooth=Smooth.None));
        end for;
        connect(lay[nLay].port_b, port_b) annotation (Line(
            points={{5.55112e-16,6.10623e-16},{49,6.10623e-16},{49,5.55112e-16},{100,
                5.55112e-16}},
            color={191,0,0},
            smooth=Smooth.None));

        annotation ( Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-90,2},{92,-4}},
                lineColor={0,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-36,12},{-34,12},{-32,8},{-30,2},{-30,-2},{-32,-8},{-38,-12},
                    {-42,-16},{-50,-18},{-54,-14},{-60,-8},{-62,2},{-60,8},{-58,12},{
                    -56,14},{-54,16},{-50,18},{-46,18},{-40,16},{-36,12}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-54,-12},{-46,-14},{-40,-12},{-34,-10},{-38,-12},{-42,-16},{
                    -50,-18},{-56,-16},{-60,-8},{-62,2},{-60,8},{-58,12},{-56,14},{-58,
                    4},{-58,-4},{-54,-12}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-80,50},{-68,-52}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Polygon(
                points={{50,10},{52,10},{54,6},{56,0},{56,-4},{54,-10},{48,-14},{44,-18},
                    {36,-20},{32,-16},{26,-10},{24,0},{26,6},{28,10},{30,12},{32,14},
                    {36,16},{40,16},{46,14},{50,10}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{32,-14},{40,-16},{46,-14},{52,-12},{48,-14},{44,-18},{36,-20},
                    {30,-18},{26,-10},{24,0},{26,6},{28,10},{30,12},{28,2},{28,-6},{
                    32,-14}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-20,50},{-8,-52}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Rectangle(
                extent={{4,50},{16,-52}},
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Forward),
              Rectangle(
                extent={{64,48},{76,-54}},
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Forward)}),
          defaultComponentName="heaCon",
          Documentation(info="<html>
<p>
This is a model of a heat conductor with multiple material layers and energy storage.
The construction has at least one material layer, and each layer has
at least one temperature node. The layers are modeled using an instance of
<a href=\"Buildings.HeatTransfer.Conduction.SingleLayer\">
Buildings.HeatTransfer.Conduction.SingleLayer</a>.
</p>
<p>
The construction material is defined by a record of the package
<a href=\"modelica://Buildings.HeatTransfer.Data.OpaqueConstructions\">
Buildings.HeatTransfer.Data.OpaqueConstructions</a>.
This record allows specifying materials that store energy, and material
that are a thermal conductor only with no heat storage.
To assign the material properties to this model, do the following:
</p>
<ol>
<li>
Create an instance of a record of
<a href=\"modelica://Buildings.HeatTransfer.Data.OpaqueConstructions\">
Buildings.HeatTransfer.Data.OpaqueConstructions</a>, for example
by dragging the record into the schematic model editor.
</li>
<li>
Make sure the instance has the attribute <code>parameter</code>, which may not be
assigned automatically when you drop the model in a graphical editor. For
example, an instanciation may look like
<pre>
 parameter Data.OpaqueConstructions.Insulation100Concrete200 layers
   \"Material layers of construction\"
   annotation (Placement(transformation(extent={{-80,60},{-60,80}})));
</pre>
</li>
<li>
Assign the instance of the material to the instance of the heat transfer
model as shown in
<a href=\"modelica://Buildings.HeatTransfer.Examples.ConductorMultiLayer\">
Buildings.HeatTransfer.Examples.ConductorMultiLayer</a>.
</li>
</ol>
<p>
To obtain the surface temperature of the construction, use <code>port_a.T</code> (or <code>port_b.T</code>)
and not the variable <code>T[1]</code> because there is a thermal resistance between the surface
and the temperature state.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 15, 2014, by Michael Wetter:<br/>
Changed assignment of <code>R</code> to be in the <code>extends</code> statement
to avoid a division by zero in OpenModelica.
</li>
<li>
September 9, 2014, by Michael Wetter:<br/>
Reverted change from March 1 2013 as this causes an error during model check
in Dymola 2015 FD01 beta1.
</li>
<li>
August 12, 2014, by Michael Wetter:<br/>
Reformulated the protected elements and the model instantiation to avoid
a warning in the OpenModelica parser.
</li>
<li>
March 1, 2013, by Michael Wetter:<br/>
Removed <code>initial equation</code> section and assigned the protected parameters
<code>_T_a_start</code> and <code>_T_b_start</code> directly to avoid a warning during
translation.
</li>
<li>
March 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end MultiLayer;

      constant Integer nSupPCM = 6
        "Number of support points to approximate u(T) releation, used only for phase change material";

      package BaseClasses
        "Package with base classes for Buildings.HeatTransfer.Conduction"
        extends Modelica.Icons.BasesPackage;

        partial model PartialConductor "Partial model for heat conductor"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Modelica.SIunits.Area A "Heat transfer area";
          final parameter Modelica.SIunits.CoefficientOfHeatTransfer U = UA/A
            "U-value (without surface heat transfer coefficients)";
          final parameter Modelica.SIunits.ThermalConductance UA = 1/R
            "Thermal conductance of construction (without surface heat transfer coefficients)";
          parameter Modelica.SIunits.ThermalResistance R
            "Thermal resistance of construction";

          Modelica.SIunits.TemperatureDifference dT "port_a.T - port_b.T";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
            "Heat port at surface a" annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
            "Heat port at surface b" annotation (Placement(transformation(extent={{90,-10},{
                    110,10}})));
        equation
          dT = port_a.T - port_b.T;
          annotation (    Documentation(info="<html>
Partial model for single layer and multi layer heat conductors.
The heat conductor can be steady-state or transient.
</html>",         revisions="<html>
<ul>
<li>
March 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialConductor;

        model PartialConstruction "Partial model for multi-layer constructions"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Modelica.SIunits.Area A "Heat transfer area";

          replaceable parameter
            Buildings.HeatTransfer.Data.OpaqueConstructions.Generic
            layers "Construction definition from Data.OpaqueConstructions"
            annotation (choicesAllMatching=true, Placement(transformation(extent={{60,60},
                    {80,80}})));

          final parameter Integer nLay(min=1, fixed=true) = layers.nLay
            "Number of layers";
          final parameter Integer nSta[nLay](each min=1)={layers.material[i].nSta for i in 1:nLay}
            "Number of states"  annotation(Evaluate=true);
          parameter Boolean steadyStateInitial=false
            "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
                annotation (Dialog(group="Initialization"), Evaluate=true);
          parameter Modelica.SIunits.Temperature T_a_start=293.15
            "Initial temperature at port_a, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
          parameter Modelica.SIunits.Temperature T_b_start=293.15
            "Initial temperature at port_b, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
          annotation (    Documentation(info="<html>
Partial model for constructions and multi-layer heat conductors.
</html>",         revisions="<html>
<ul>
<li>
August 12, 2014, by Michael Wetter:<br/>
Added missing <code>each</code> keyword in <code>min</code>
attribute of <code>nSta</code>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialConstruction;

        function der_temperature_u
          "Computes the derivative of the temperature of a phase change material with respect to specific internal energy"
          input Modelica.SIunits.SpecificHeatCapacity c
            "Specific heat capacity";
          input Modelica.SIunits.Temperature TSol
            "Solidus temperature, used only for PCM.";
          input Modelica.SIunits.Temperature TLiq
            "Liquidus temperature, used only for PCM";
          input Modelica.SIunits.SpecificInternalEnergy LHea
            "Latent heat of phase change";
          input Boolean ensureMonotonicity = false
            "Set to true to force derivatives dT/du to be monotone";

          output Modelica.SIunits.SpecificInternalEnergy ud[Buildings.HeatTransfer.Conduction.nSupPCM]
            "Support points for derivatives";
          output Modelica.SIunits.Temperature Td[Buildings.HeatTransfer.Conduction.nSupPCM]
            "Support points for derivatives";
          output Real dT_du[Buildings.HeatTransfer.Conduction.nSupPCM](fixed=false, unit="kg.K2/J")
            "Derivatives dT/du at the support points";
        protected
          parameter Real scale=0.999
            "Used to place points on the phase transition";
          parameter Modelica.SIunits.Temperature Tm1=TSol+(1-scale)*(TLiq-TSol)
            "Support point";
          parameter Modelica.SIunits.Temperature Tm2=TSol+scale*(TLiq-TSol)
            "Support point";
        algorithm
          assert(Buildings.HeatTransfer.Conduction.nSupPCM == 6,
            "The material must have exactly 6 support points for the u(T) relation.");
          assert(TLiq > TSol, "TLiq has to be larger than TSol.");
          // Get the derivative values at the support points
          ud:={c*scale*TSol,
               c*TSol,
               c*Tm1 + LHea*(Tm1 - TSol)/(TLiq - TSol),
               c*Tm2 + LHea*(Tm2 - TSol)/(TLiq - TSol),
               c*TLiq + LHea,
               c*(TLiq + TSol*(1 - scale)) + LHea};
          Td:={scale*TSol,
               TSol,
               Tm1,
               Tm2,
               TLiq,
               TLiq + TSol*(1 - scale)};
          dT_du := Buildings.Utilities.Math.Functions.splineDerivatives(
              x=ud,
              y=Td,
              ensureMonotonicity=ensureMonotonicity);
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
This function computes at the support points <i>T<sub>d</sub></i> the derivatives
<i>dT/du</i> of the cubic hermite spline approximation to the
temperature vs. specific internal energy relation.
These derivatives are then used by the function
<a href=\"modelica://Buildings.HeatTransfer.Conduction.BaseClasses.temperature_u\">
Buildings.HeatTransfer.Conduction.BaseClasses.temperature_u</a>
to compute for a given specific internal energy the temperature.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed the input argument from type
<code>Buildings.HeatTransfer.Data.BaseClasses.Material</code>
to the elements of this type as OpenModelica fails to translate the
model if the input to this function is a record.
</li>
<li>
October 13, 2014, by Michael Wetter:<br/>
Corrected the input argument to be an instance of
<code>Buildings.HeatTransfer.Data.BaseClasses.Material</code> rather than
<code>Buildings.HeatTransfer.Data.Solids.Generic</code>.
</li>
<li>
March 9, 2013, by Michael Wetter:<br/>
Revised implementation to use new data record.
</li>
<li>
January 19, 2013, by Armin Teskeredzic:<br/>
First implementations.
</li>
</ul>
</html>"));
        end der_temperature_u;

        function temperature_u
          "Computes the temperature of a phase change material for a given specific internal energy"

          input Modelica.SIunits.SpecificInternalEnergy ud[Buildings.HeatTransfer.Conduction.nSupPCM]
            "Support points for derivatives";
          input Modelica.SIunits.Temperature Td[Buildings.HeatTransfer.Conduction.nSupPCM]
            "Support points for derivatives";
          input Real dT_du[:](each fixed=false, unit="kg.K2/J")
            "Derivatives dT/du at the support points";

          input Modelica.SIunits.SpecificInternalEnergy u
            "Specific internal energy";

          output Modelica.SIunits.Temperature T "Resulting temperature";
        protected
          Integer i "Integer to select data interval";
        algorithm
          // i is a counter that is used to pick the derivative
          // that corresponds to the interval that contains x
          i := 1;
          for j in 1:size(ud,1) - 1 loop
            if u > ud[j] then
              i := j;
            end if;
          end for;
          // Extrapolate or interpolate the data
          T :=  Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
             x=u,
             x1=ud[i],
             x2=ud[i + 1],
             y1=Td[i],
             y2=Td[i + 1],
             y1d=dT_du[i],
             y2d=dT_du[i + 1]);
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
This function computes for a given specific internal energy <i>u</i>
the temperature <i>T(u)</i>, using a cubic hermite spline approximation to the
temperature vs. specific internal energy relation.
Input to the function are the derivatives <i>dT/du</i> at the support points.
These derivatives can be computed using
<a href=\"modelica://Buildings.HeatTransfer.Conduction.BaseClasses.der_temperature_u\">
Buildings.HeatTransfer.Conduction.BaseClasses.der_temperature_u</a>.
</p>
<h4>Implementation</h4>
<p>
The derivatives <i>dT/du</i> are an input to this function because they typically only need
to be computed once, whereas <i>T(u)</i> must be evaluated at each time step.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 9, 2013, by Michael Wetter:<br/>
Revised implementation to use new data record.
</li>
<li>
January 19, 2013, by Armin Teskeredzic:<br/>
First implementations.
</li>
</ul>
</html>"));
        end temperature_u;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Conduction\">Buildings.HeatTransfer.Conduction</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package provides component models to compute heat conduction.
</p>
<h4>Implementation</h4>
<p>
The package declares the constant <code>nSupPCM</code>,
which is equal to the number of support points that are used
to approximate the specific internal energy versus temperature relation.
This approximation is used by
<code>Buildings.HeatTransfer.Conduction.SingleLayer</code>
to replace the piece-wise linear function by a cubic hermite spline, with
linear extrapolation, in order to avoid state events during the simulation.
</p>
</html>",     revisions="<html>
<ul>
<li>
March 10, 2013, by Michael Wetter:<br/>
Added constant <code>nSupPCM</code>.
</li>
<li>
February 5, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end Conduction;

    package Convection "Package with models for convective heat transfer"
      extends Modelica.Icons.VariantsPackage;

      model Exterior "Model for a exterior (outside) convective heat transfer"
        extends Buildings.HeatTransfer.Convection.BaseClasses.PartialConvection;

        parameter Buildings.HeatTransfer.Types.ExteriorConvection conMod=
          Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind
          "Convective heat transfer model"
        annotation(Evaluate=true);
        parameter Buildings.HeatTransfer.Types.SurfaceRoughness roughness=
          Buildings.HeatTransfer.Types.SurfaceRoughness.Medium
          "Surface roughness"
          annotation (Dialog(enable=(conMod <> Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));
        parameter Modelica.SIunits.Angle azi "Surface azimuth";

        Modelica.Blocks.Interfaces.RealInput v(unit="m/s") "Wind speed"
          annotation (Placement(transformation(extent={{-140,80},{-100,120}})));
        Modelica.Blocks.Interfaces.RealInput dir(unit="rad", displayUnit="deg",
           min=0, max=2*Modelica.Constants.pi)
          "Wind direction (0=wind from North)"
          annotation (Placement(transformation(extent={{-140,30},{-100,70}})));
        Modelica.SIunits.CoefficientOfHeatTransfer hF
          "Convective heat transfer coefficient due to forced convection";
        Modelica.SIunits.HeatFlux qN_flow
          "Convective heat flux from solid -> fluid due to natural convection";
        Modelica.SIunits.HeatFlux qF_flow
          "Convective heat flux from solid -> fluid due to forced convection";
      protected
         parameter Real R(fixed=false) "Surface roughness";
         Real W(min=0.5, max=1) "Wind direction modifier";
      initial equation
        if (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.VeryRough) then
          R=2.17;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.Rough) then
          R=1.67;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.Medium) then
          R=1.52;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.MediumSmooth) then
          R=1.13;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.Smooth) then
          R=1.11;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.VerySmooth) then
          R=1.00;
        else
          R=0;
        end if;
      equation
        if (conMod == Buildings.HeatTransfer.Types.ExteriorConvection.Fixed) then
          qN_flow = hFixed * dT;
          W = 1;
          hF = 0;
          qF_flow = 0;
        else
          // Even if hCon is a step function with a step at zero,
          // the product hCon*dT is differentiable at zero with
          // a continuous first derivative
          if isCeiling then
             qN_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(
                                                                                   dT=dT);
          elseif isFloor then
             qN_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(
                                                                                 dT=dT);
          else
             qN_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(
                                                                                dT=dT);
          end if;
          // Forced convection
          W = Buildings.HeatTransfer.Convection.Functions.windDirectionModifier(
                                                                     azi=azi, dir=dir);
          hF = 2.537 * W * R * 2 / A^(0.25) *
               Buildings.Utilities.Math.Functions.regNonZeroPower(x=v, n=0.5, delta=0.5);
          qF_flow = hF*dT;
        end if;
        q_flow = qN_flow + qF_flow;

        annotation ( Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-90,80},{-60,-80}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Text(
                extent={{-35,42},{-5,20}},
                lineColor={255,0,0},
                textString="Q_flow"),
              Line(points={{-60,20},{76,20}}, color={191,0,0}),
              Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
              Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
              Line(points={{6,80},{6,-80}}, color={0,127,255}),
              Line(points={{40,80},{40,-80}}, color={0,127,255}),
              Line(points={{76,80},{76,-80}}, color={0,127,255}),
              Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
              Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
              Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
              Line(points={{6,-80},{16,-60}}, color={0,127,255}),
              Line(points={{40,-80},{30,-60}}, color={0,127,255}),
              Line(points={{40,-80},{50,-60}}, color={0,127,255}),
              Line(points={{76,-80},{66,-60}}, color={0,127,255}),
              Line(points={{76,-80},{86,-60}}, color={0,127,255}),
              Line(points={{56,-30},{76,-20}}, color={191,0,0}),
              Line(points={{56,-10},{76,-20}}, color={191,0,0}),
              Line(points={{56,10},{76,20}}, color={191,0,0}),
              Line(points={{56,30},{76,20}}, color={191,0,0}),
                                               Text(
                extent={{-102,128},{-64,98}},
                lineColor={0,0,127},
                textString="v"),               Text(
                extent={{-100,64},{-62,34}},
                lineColor={0,0,127},
                textString="dir")}),
          defaultComponentName="con",
          Documentation(info="<html>
<p>
This is a model for a convective heat transfer for exterior, outside-facing surfaces.
The parameter <code>conMod</code> determines the model that is used to compute
the heat transfer coefficient:
</p>

<ol>
<li><p>If <code>conMod=
<a href=\"modelica://Buildings.HeatTransfer.Types.ExteriorConvection\">
Buildings.HeatTransfer.Types.ExteriorConvection.Fixed</a>
</code>, then
the convective heat transfer coefficient is set to the value specified by the parameter
<code>hFixed</code>.
</p>
</li>
<li>
<p>
If <code>conMod=
<a href=\"modelica://Buildings.HeatTransfer.Types.ExteriorConvection\">
Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind</a>
</code>,
then the convective heat transfer coefficient is
computed based on wind speed, wind direction and temperature difference.
</p>
<p>
The total convection coefficient <i>h<sub>t</sub></i> is the sum of the
temperature-driven free convection coefficient <i>h<sub>n</sub></i>
and the wind-driven forced convection coefficient <i>h<sub>f</sub></i>,
<p align=\"center\" style=\"font-style:italic;\">
 h<sub>t</sub> = h<sub>n</sub> + h<sub>f</sub>
</p>
The free convection coefficient <i>h<sub>n</sub></i> is computed in the same way as in
<a href=\"modelica://Buildings.HeatTransfer.Convection.Interior\">
Buildings.HeatTransfer.Convection.Interior</a>.
The forced convection coefficient <i>h<sub>f</sub></i>
is computed based on a correlation by Sparrow, Ramsey, and Mass
(1979), which is
<p align=\"center\" style=\"font-style:italic;\">
 h<sub>f</sub> = 2.537 W R &radic;( P v &frasl; A )
</p>
<p>
where <i>W=1</i> for windward surfaces and
<i>W=0.5</i> for leeward surfaces, with leeward defined as greater than 100 degrees
from normal incidence,
<i>R</i> is a surface roughness multiplier,
<i>P</i> is the perimeter of the surface and
<i>A</i> is the area of the surface.
This is the same equation as implemented in EnergyPlus 6.0.
</p>
<p>
We make the simplified assumption that the surface is square, and hence we set
<p align=\"center\" style=\"font-style:italic;\">
 h<sub>f</sub> = 2.537 W R &radic;( 4 v &frasl; &radic;(A) )
</p>
<p>
The surface roughness is specified by the parameter <code>surfaceRoughness</code>
which has to be set to a type of
<a href=\"modelica://Buildings.HeatTransfer.Types.SurfaceRoughness\">
Buildings.HeatTransfer.Types.SurfaceRoughness</a>.The coefficients for the surface roughness are
</p>

<table summary=\"summary\" border=\"1\">
<tr>
<th>Roughness index</th>
<th><i>R</i></th>
<th>Example material</th>
</tr>
<tr><td>VeryRough</td>   <td>2.17</td>  <td>Stucco</td></tr>
<tr><td>Rough</td>        <td>1.67</td>  <td>Brick</td></tr>
<tr><td>MediumRough</td> <td>1.52</td>  <td>Concrete</td></tr>
<tr><td>MediumSmooth</td><td>1.13</td>  <td>Clear pine</td></tr>
<tr><td>Smooth</td>       <td>1.11</td>  <td>Smooth plaster</td></tr>
<tr><td>VerySmooth</td>  <td>1.00</td>  <td>Glass</td></tr>
</table>

</li>
</ol>
<h4>References</h4>
<p>
Sparrow, E. M., J. W. Ramsey, and E. A. Mass. 1979. Effect of Finite Width on Heat Transfer
and Fluid Flow about an Inclined Rectangular Plate. Journal of Heat Transfer, Vol. 101, p.
204.
</p>
<p>
Walton, G. N. 1981. Passive Solar Extension of the Building Loads Analysis and System
Thermodynamics (BLAST) Program, Technical Report, United States Army Construction
Engineering Research Laboratory, Champaign, IL.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 29, 2011, by Michael Wetter:<br/>
Fixed error in assignment of wind-based convection coefficient.
The old implementation did not take into account the surface roughness.
Bug fix is due to feedback from Tobias Klingbeil (Fraunhofer ISE).
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Exterior;

      model Interior
        "Model for a interior (room-side) convective heat transfer"
        extends Buildings.HeatTransfer.Convection.BaseClasses.PartialConvection;

        parameter Buildings.HeatTransfer.Types.InteriorConvection conMod=
          Buildings.HeatTransfer.Types.InteriorConvection.Fixed
          "Convective heat transfer model"
        annotation(Evaluate=true);
        parameter Boolean homotopyInitialization = true
          "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
      protected
        constant Modelica.SIunits.Temperature dT0 = 2
          "Initial temperature used in homotopy method";
      equation
        if (conMod == Buildings.HeatTransfer.Types.InteriorConvection.Fixed) then
          q_flow = hFixed * dT;
        else
          // Even if hCon is a step function with a step at zero,
          // the product hCon*dT is differentiable at zero with
          // a continuous first derivative
          if homotopyInitialization then
            if isCeiling then
               q_flow = homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT),
                          simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT0));
            elseif isFloor then
               q_flow = homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT),
                          simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT0));
            else
               q_flow = homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT),
                          simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT0));
            end if;
          else
            if isCeiling then
               q_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT);
            elseif isFloor then
               q_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT);
            else
               q_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT);
            end if;
          end if;

        end if;

        annotation ( Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-90,80},{-60,-80}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Text(
                extent={{-35,42},{-5,20}},
                lineColor={255,0,0},
                textString="Q_flow"),
              Line(points={{-60,20},{76,20}}, color={191,0,0}),
              Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
              Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
              Line(points={{6,80},{6,-80}}, color={0,127,255}),
              Line(points={{40,80},{40,-80}}, color={0,127,255}),
              Line(points={{76,80},{76,-80}}, color={0,127,255}),
              Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
              Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
              Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
              Line(points={{6,-80},{16,-60}}, color={0,127,255}),
              Line(points={{40,-80},{30,-60}}, color={0,127,255}),
              Line(points={{40,-80},{50,-60}}, color={0,127,255}),
              Line(points={{76,-80},{66,-60}}, color={0,127,255}),
              Line(points={{76,-80},{86,-60}}, color={0,127,255}),
              Line(points={{56,-30},{76,-20}}, color={191,0,0}),
              Line(points={{56,-10},{76,-20}}, color={191,0,0}),
              Line(points={{56,10},{76,20}}, color={191,0,0}),
              Line(points={{56,30},{76,20}}, color={191,0,0})}),
          defaultComponentName="con",
          Documentation(info="<html>
This is a model for a convective heat transfer for interior, room-facing surfaces.
The parameter <code>conMod</code> determines the model that is used to compute
the heat transfer coefficient:
<br/>

<ul>
<li><p>If <code>conMod=<a href=\"modelica://Buildings.HeatTransfer.Types.InteriorConvection\">
Buildings.HeatTransfer.Types.InteriorConvection.Fixed</a></code>, then
the convective heat transfer coefficient is set to the value specified by the parameter
<code>hFixed</code>.
</p>
</li>
<li>

If <code>conMod=<a href=\"modelica://Buildings.HeatTransfer.Types.InteriorConvection\">
Buildings.HeatTransfer.Types.InteriorConvection.Temperature</a></code>, then
the convective heat tranfer coefficient is a function of the temperature difference.
The convective heat flux is computed using
<br/>
<ul>
<li>
for floors the function
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor\">
Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor</a>
</li>
<li>
for ceilings the function
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling\">
Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling</a>
</li>
<li>
for walls the function
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall\">
Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall</a>
</li>
</ul>
</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Interior;

      package Functions "Functions for convective heat transfer"

        package HeatFlux "Correlations for convective heat flux"

          function wall "Free convection, wall"
            extends
              Buildings.HeatTransfer.Convection.Functions.HeatFlux.BaseClasses.PartialHeatFlux;
          algorithm
            q_flow := noEvent(smooth(1, if (dT > 0) then 1.3*dT^1.3333 else -1.3*(-dT)^1.3333));

          annotation (smoothOrder=1,
          Documentation(info=
          "<html>
<p>
This function computes the buoyancy-driven convective heat flux as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  q&#775; = h &Delta;T,
</p>
<p>
where
<i>&Delta;T</i> is the solid temperature minus the fluid temperature and
<i>h</i> is the convective heat transfer coefficient
for a wall, computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
h=1.3 |&Delta;T|<sup>0.3333</sup>.
</p>
</html>", revisions="<html>
<ul>
<li>
July 28, 2014, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end wall;

          function floor "Free convection, floor"
            extends
              Buildings.HeatTransfer.Convection.Functions.HeatFlux.BaseClasses.PartialHeatFlux;

          algorithm
            q_flow  := noEvent(smooth(1, if (dT>0) then 1.51*dT^1.3333 else -0.76*(-dT)^1.3333));

          annotation(smoothOrder=1,
          Documentation(info=
          "<html>
<p>
This function computes the buoyancy-driven convective heat flux as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  q&#775; = h &Delta;T,
</p>
<p>
where
<i>&Delta;T</i> is the solid temperature minus the fluid temperature and
<i>h</i> is the convective heat transfer coefficient
for a floor, computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
h=k |&Delta;T|<sup>0.3333</sup>,
</p>
<p>
where
<i>k=0.76</i> if the fluid is warmer than the floor,
or <i>k=1.51</i> otherwise.
</p>
</html>", revisions="<html>
<ul>
<li>
July 28, 2014, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end floor;

          function ceiling "Free convection, ceiling"
            extends
              Buildings.HeatTransfer.Convection.Functions.HeatFlux.BaseClasses.PartialHeatFlux;

          algorithm
             q_flow  := noEvent(smooth(1, if (dT>0) then 0.76*dT^1.3333 else -1.51*(-dT)^1.3333));

          annotation(smoothOrder=1,
                      Documentation(info=
          "<html>
<p>
This function computes the buoyancy-driven convective heat flux as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  q&#775; = h &Delta;T,
</p>
<p>
where
<i>&Delta;T</i> is the solid temperature minus the fluid temperature and
<i>h</i> is the convective heat transfer coefficient
for a ceiling, computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
h=k |&Delta;T|<sup>0.3333</sup>,
</p>
<p>
where
<i>k=1.51</i> if the fluid is warmer than the ceiling,
or <i>k=0.76</i> otherwise.
</p>
</html>", revisions="<html>
<ul>
<li>
July 28, 2014, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end ceiling;

          function rayleigh
            "Rayleigh number with smooth transition to lower limit"
            extends Modelica.Icons.Function;
           input Modelica.SIunits.Length x "Layer thickness";
           input Modelica.SIunits.Density rho "Mass density";
           input Modelica.SIunits.SpecificHeatCapacity c_p
              "Specific heat capacity";
           input Modelica.SIunits.DynamicViscosity mu "Dynamic viscosity";
           input Modelica.SIunits.ThermalConductivity k "Thermal conductivity";
           input Modelica.SIunits.Temperature T_a "Temperature of surface a";
           input Modelica.SIunits.Temperature T_b "Temperature of surface b";
           input Real Ra_min "Minimum value for Rayleigh number";
           output Real Ra "Rayleigh number";
          protected
           Modelica.SIunits.TemperatureDifference dT "Temperature difference";
          algorithm
            dT :=abs(T_a - T_b);
            Ra := rho^2*x^3*Modelica.Constants.g_n*c_p*dT/((T_a+T_b)/2*mu*k);
            Ra := Buildings.Utilities.Math.Functions.smoothMax(x1=Ra, x2=Ra_min, deltaX=Ra_min/10);
          annotation (smoothOrder=1,
          Documentation(info="<html>
This function returns the Rayleigh number.
The parameter <code>RaMin</code> is used to transition
to a lower limit for the Rayleigh number.
This is helpful to avoid a Rayleigh number of zero or
to avoid an expression for a convection coefficient that
has an infinite derivative near zero, i.e., if <i>h=f(Ra<sup>(1/2)</sup>)</i>.
</html>", revisions="<html>
<ul>
<li>
July 2, 2013, by Michael Wetter:<br/>
Renamed function from <code>raleigh</code> to <code>rayleigh</code>.
</li>
<li>
August 18 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end rayleigh;

          package BaseClasses
            "Base classes for convective heat transfer coefficients"
            extends Modelica.Icons.BasesPackage;

            partial function PartialHeatFlux
              "Partial function for convective heat flux"
              extends Modelica.Icons.Function;

             input Modelica.SIunits.TemperatureDifference dT
                "Temperature difference solid minus fluid";
             output Modelica.SIunits.HeatFlux q_flow
                "Convective heat flux from solid to fluid";
            annotation (Documentation(info=
            "<html>
<p>
Partial function that is used to implement the convective heat flux
as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  q&#775; = h &Delta;T,
</p>
<p>
where
<i>&Delta;T</i> is the solid temperature minus the fluid temperature and
<i>h</i> is the convective heat transfer coefficient.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 28, 2014, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end PartialHeatFlux;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux\">Buildings.HeatTransfer.Convection.Functions.HeatFlux</a>.
</p>
</html>"));
          end BaseClasses;
          annotation (Documentation(info="<html>
<p>
This package contains functions for the convective heat transfer.
Input into the functions is the temperature difference between
the solid and the fluid.
The functions compute the convective heat flux, rather than the
convective heat transfer coefficient,
because the convective heat transfer coefficient
is not differentiable around zero for some flow configurations,
such as buoyancy driven flow at a horizontal surface. However, the
product of convective heat transfer coefficient times temperature
difference is differentiable around zero.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 8 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end HeatFlux;

        function windDirectionModifier
          "Wind direction modifier that is used to compute the wind-driven convective heat transfer coefficient"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.Angle azi "Surface azimuth";
          input Modelica.SIunits.Angle dir(min=0, max=2*Modelica.Constants.pi)
            "Wind direction (0=wind from North)";
          output Real W "Wind direction modifier";
        protected
          constant Modelica.SIunits.Angle lee = Modelica.SIunits.Conversions.from_deg(100)
            "Angle at which the transition occurs";
          constant Real cosLee = Modelica.Math.cos(lee)
            "Cosine of the angle at which the transition occurs";
        algorithm
        // The wind direction is defined in TMY3 as dir=0 if from North, and 0 <= dir < 2*pi
        // Hence, we subtract pi to redefine dir=0 as wind coming from the south.
        // This simplifies the implementation since a surface azimuth is defined as azi=0
        // if the surface is south-facing
          W:=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=0.5,
            neg=1,
            x=cosLee-Modelica.Math.cos(azi+Modelica.Constants.pi-dir),
            deltax=0.05);
            annotation (
        smoothOrder=1,
        Documentation(info="<html>
<p>
Function that outputs <i>1</i> if the incidence angle is below 100 degrees, and
<i>0.5</i> otherwise.
The implementation is once continuously differentiable in its input arguments.
</p>
<p>
See
<a href=\"modelica://Buildings.HeatTransfer.Examples.ExteriorConvection\">
Buildings.HeatTransfer.Examples.ExteriorConvection</a>
for an example that uses this function.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 30, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end windDirectionModifier;
        annotation (Documentation(revisions="<html>
<ul>
<li>
March 8 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>",       info="<html>
This package contains functions that are used in the
package
<a href=\"modelica://Buildings.HeatTransfer\">
Buildings.HeatTransfer</a>.
</html>"));
      end Functions;

      package BaseClasses
        "Package with base classes for Buildings.HeatTransfer.Convection"
        extends Modelica.Icons.BasesPackage;

        partial model PartialConvection "Partial model for heat convection"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed=3
            "Constant convection coefficient";
          Modelica.SIunits.HeatFlowRate Q_flow
            "Heat flow rate from solid -> fluid";
          Modelica.SIunits.HeatFlux q_flow
            "Convective heat flux from solid -> fluid";
          Modelica.SIunits.TemperatureDifference dT(start=0)
            "= solid.T - fluid.T";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a solid
                                      annotation (Placement(transformation(extent={{-110,
                    -10},{-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b fluid
                                      annotation (Placement(transformation(extent={{90,-10},
                    {110,10}})));

          parameter Modelica.SIunits.Angle til(displayUnit="deg")
            "Surface tilt"
            annotation (Dialog(enable= not (conMod == Buildings.HeatTransfer.Types.InteriorConvection.fixed)));

        protected
          final parameter Real cosTil=Modelica.Math.cos(til)
            "Cosine of window tilt";
          final parameter Real sinTil=Modelica.Math.sin(til)
            "Sine of window tilt";
          final parameter Boolean isCeiling = abs(sinTil) < 10E-10 and cosTil > 0
            "Flag, true if the surface is a ceiling";
          final parameter Boolean isFloor = abs(sinTil) < 10E-10 and cosTil < 0
            "Flag, true if the surface is a floor";

        equation
          dT = solid.T - fluid.T;
          solid.Q_flow = Q_flow;
          fluid.Q_flow = -Q_flow;
          Q_flow = A*q_flow;
          annotation ( Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-35,42},{-5,20}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0})}),
            Documentation(info="<html>
Partial model for a convective heat transfer model.
</html>",         revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 8 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialConvection;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Convection\">Buildings.HeatTransfer.Convection</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package provides component models to compute heat convection.
</p>
</html>"));
    end Convection;

    package Radiosity "Package with models for radiosity transfer"
      extends Modelica.Icons.VariantsPackage;

      model OutdoorRadiosity
        "Model for the outdoor radiosity that strikes the window"
        parameter Modelica.SIunits.Area A "Area of receiving surface";
        parameter Real vieFacSky(final min=0, final max=1)
          "View factor from receiving surface to sky (=1 for roofs)";
        parameter Boolean linearize=false
          "Set to true to linearize emissive power"
          annotation (Evaluate=true);
        parameter Modelica.SIunits.Temperature T0=293.15
          "Temperature used to linearize radiative heat transfer"
          annotation (Dialog(enable=linearize));
        Real TRad4(unit="K4") "4th power of the mean outdoor temperature";
        Modelica.SIunits.Temperature TRad "Mean radiant temperature";

        Modelica.Blocks.Interfaces.RealInput TOut(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Outside temperature" annotation (Placement(transformation(extent={{
                  -140,-60},{-100,-20}}), iconTransformation(extent={{-140,-60},{-100,
                  -20}})));
        Modelica.Blocks.Interfaces.RealInput TBlaSky(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Black body sky temperature" annotation (Placement(transformation(
                extent={{-140,20},{-100,60}}), iconTransformation(extent={{-140,20},{
                  -100,60}})));
        Buildings.HeatTransfer.Interfaces.RadiosityOutflow JOut
          "Radiosity that flows out of component" annotation (Placement(
              transformation(extent={{100,-10},{120,10}}), iconTransformation(extent=
                  {{100,-10},{120,10}})));
      protected
        final parameter Real T03(
          min=0,
          final unit="K3") = T0^3 "3rd power of temperature T0";
        final parameter Real T04(
          min=0,
          final unit="K4") = T0^4 "4th power of temperature T0";
      equation
        TRad4 = (vieFacSky*TBlaSky^4 + (1 - vieFacSky)*TOut^4);
        JOut = A*Modelica.Constants.sigma*TRad4;
        TRad = if linearize then (TRad4 + 3*T04)/(4*T03) else TRad4^(1/4);

        annotation (
          Icon(graphics={
              Text(
                extent={{-96,-10},{-54,-52}},
                lineColor={0,0,127},
                textString="TOut"),
              Text(
                extent={{64,16},{94,-12}},
                lineColor={0,0,127},
                textString="J"),
              Line(
                points={{6,-36},{28,-8},{20,-8},{28,-8},{28,-16},{28,-16}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,-36},{42,-36},{34,-30},{42,-36},{36,-42}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,28},{28,0},{20,0},{28,0},{28,8},{28,8}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,28},{42,28},{34,34},{42,28},{36,22}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,28},{28,56},{20,56},{28,56},{28,48},{28,48}},
                color={127,0,0},
                smooth=Smooth.None),
              Rectangle(
                extent={{4,74},{-34,-42}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-34,-42},{66,-60}},
                pattern=LinePattern.None,
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Text(
                extent={{-150,142},{150,102}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{-96,72},{-54,30}},
                lineColor={0,0,127},
                textString="TBlaSky")}),
          defaultComponentName="radOut",
          Documentation(info="<html>
<p>
Model for the infrared radiosity balance of the outdoor environment.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
February 10, 2012, by Wangda Zuo:<br/>
Fixed a bug in the temperature linearization.
</li>
<li>
February 8, 2012 by Michael Wetter:<br/>
Changed implementation to use the same equations as is used for opaque walls.
</li>
<li>
August 18, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end OutdoorRadiosity;

      block RadiositySplitter
        "Splits the incoming radiosity into two flows based on an input signal"
        extends Modelica.Blocks.Icons.Block;

        Interfaces.RadiosityInflow JIn "Inflowing radiosity"
          annotation (Placement(transformation(extent={{-120,50},{-100,70}})));
        Modelica.Blocks.Interfaces.RealInput u(min=0, max=1)
          "u times incoming radiosity"
          annotation (Placement(
              transformation(extent={{-140,-80},{-100,-40}}), iconTransformation(
                extent={{-140,-80},{-100,-40}})));
        Interfaces.RadiosityOutflow JOut_1 "u times incoming radiosity"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));

        Interfaces.RadiosityOutflow JOut_2 "(1-u) times incoming radiosity"
          annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
      equation
        JOut_1 = u    * JIn;
        JOut_2 = (1-u)* JIn;
        annotation (
      defaultComponentName="radSpl",
          Documentation(info="<html>
<p>
This blocks splits the incoming radiosity into two fluxes according to
</p>
<p align=\"center\" style=\"font-style:italic;\">
  J<sub>Out,1</sub> = u J<sub>In</sub>,<br/>
  J<sub>Out,2</sub> = (1-u)  J<sub>In</sub>.
</p>
<p>
This block may be used to split the radiosity flux into a fraction that
strikes the shaded part of a window, and a fraction that strikes the
non-shaded part.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
October 23 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,127}),
          Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,127}),
          Line(points={{50,0},{100,0}}, color={0,0,127}),
          Line(points={{-30,0},{30,0}}, color={0,0,0}),
          Line(points={{-15,25.99},{15,-25.99}}, color={0,0,0}),
          Line(points={{-15,-25.99},{15,25.99}}, color={0,0,0}),
          Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,127}),
          Line(points={{102,60},{42,60},{32,40}},    color={0,0,255}),
          Line(points={{102,-60},{42,-60},{32,-40}},    color={0,0,255})}),
          Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Rectangle(
            extent={{-100,-100},{100,100}},
            lineColor={0,0,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,255}),
          Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,255}),
          Line(points={{50,0},{100,0}}, color={0,0,255}),
          Line(points={{-30,0},{30,0}}, color={0,0,0}),
          Line(points={{-15,25.99},{15,-25.99}}, color={0,0,0}),
          Line(points={{-15,-25.99},{15,25.99}}, color={0,0,0}),
          Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,255}),
          Line(points={{100,60},{40,60},{30,40}},    color={0,0,255}),
          Line(points={{100,-60},{40,-60},{30,-40}},    color={0,0,255})}));
      end RadiositySplitter;

      package BaseClasses
        "Package with base classes for Buildings.HeatTransfer.Radiosity"
        extends Modelica.Icons.BasesPackage;

        partial block RadiosityTwoSurfaces
          "Model for the radiosity balance of a device with two surfaces"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Modelica.SIunits.Area A "Surface area";

          Buildings.HeatTransfer.Interfaces.RadiosityInflow JIn_a(start=A*0.8*Modelica.Constants.sigma*293.15^4)
            "Incoming radiosity at surface a"
            annotation (Placement(transformation(extent={{-120,30},{-100,50}})));
          Buildings.HeatTransfer.Interfaces.RadiosityInflow JIn_b(start=A*0.8*Modelica.Constants.sigma*293.15^4)
            "Incoming radiosity at surface b"
            annotation (Placement(transformation(extent={{120,-50},{100,-30}})));
          Buildings.HeatTransfer.Interfaces.RadiosityOutflow JOut_a
            "Outgoing radiosity at surface a"
            annotation (Placement(transformation(extent={{-100,-50},{-120,-30}})));
          Buildings.HeatTransfer.Interfaces.RadiosityOutflow JOut_b
            "Outgoing radiosity at surface b"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));

          annotation (           Documentation(info="<html>
Partial model for a device with two surfaces.
</html>",         revisions="<html>
<ul>
<li>
February 3, by Michael Wetter:<br/>
Corrected bug in start value of radiosity port.
</li>
<li>
August 19 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end RadiosityTwoSurfaces;

        model ParametersTwoSurfaces
          "Parameters that are used to model two surfaces with the same area"
          parameter Modelica.SIunits.Emissivity absIR_a
            "Infrared absorptivity of surface a";
          parameter Modelica.SIunits.Emissivity absIR_b
            "Infrared absorptivity of surface b";
          parameter Modelica.SIunits.ReflectionCoefficient rhoIR_a
            "Infrared reflectivity of surface a";
          parameter Modelica.SIunits.ReflectionCoefficient rhoIR_b
            "Infrared reflectivity of surface b";
          parameter Modelica.SIunits.TransmissionCoefficient tauIR
            "Infrared transmissivity of glass pane";
          parameter Boolean linearize = false
            "Set to true to linearize emissive power"
          annotation (Evaluate=true);
          parameter Modelica.SIunits.Temperature T0=293.15
            "Temperature used to linearize radiative heat transfer"
            annotation (Dialog(enable=linearize));
        protected
         final parameter Real T03(min=0, final unit="K3")=T0^3
            "3rd power of temperature T0";
         final parameter Real T04(min=0, final unit="K4")=T0^4
            "4th power of temperature T0";
        initial equation
          assert(abs(1-absIR_a-rhoIR_a-tauIR) < 1E-8,
            "Absorptivity, reflectivity and transmissivity of surface a do not add up to one. Check parameters.");
            assert(abs(1-absIR_b-rhoIR_b-tauIR) < 1E-8,
            "Absorptivity, reflectivity and transmissivity of surface b do not add up to one. Check parameters.");

        annotation (
        Documentation(
        info="<html>
<p>
Parameters that are used for classes with two surfaces.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed tolerance of the <code>assert</code> statement.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 20, 2012, by Wangda Zuo:<br/>
Added <code>T04</code> for temperature linearization.
</li>
<li>
August 23, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ParametersTwoSurfaces;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Radiosity\">Buildings.HeatTransfer.Radiosity</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package provides component models for the
infrared radiative heat exchange of window assemblies.
The models are according to TARCOG 2006,
except for the outdoor radiosity, which is computed by
<a href=\"modelica://Buildings.HeatTransfer.Radiosity.OutdoorRadiosity\">
Buildings.HeatTransfer.Radiosity.OutdoorRadiosity</a>.
The outdoor radiosity is different from the TARCOG implementation so
that the same equations are used for windows as are used for
opaque walls in the room heat transfer model of the package
<a href=\"modelica://Buildings.Rooms\">
Buildings.Rooms</a>.
</p>
<p>
By definition, incoming and outcoming radiosity are both positive.
This is required to connect incoming and outcoming radiosity connectors.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>"));
    end Radiosity;

    package Sources "Thermal sources"
    extends Modelica.Icons.SourcesPackage;

      model PrescribedTemperature
        "Variable temperature boundary condition in Kelvin"

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                  -10},{110,10}})));
        Modelica.Blocks.Interfaces.RealInput T annotation (Placement(transformation(
                extent={{-140,-20},{-100,20}})));
      equation
        port.T = T;
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                pattern=LinePattern.None,
                fillColor={159,159,223},
                fillPattern=FillPattern.Backward),
              Line(
                points={{-102,0},{64,0}},
                color={191,0,0},
                thickness=0.5),
              Text(
                extent={{0,0},{-100,-100}},
                lineColor={0,0,0},
                textString="K"),
              Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
              Polygon(
                points={{50,-20},{50,20},{90,0},{50,-20}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<HTML>
<p>
This model represents a variable temperature boundary condition.
The temperature in [K] is given as input signal <b>T</b>
to the model. The effect is that an instance of this model acts as
an infinite reservoir able to absorb or generate as much energy
as required to keep the temperature at the specified value.
</p>
</html>"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                pattern=LinePattern.None,
                fillColor={159,159,223},
                fillPattern=FillPattern.Backward),
              Text(
                extent={{0,0},{-100,-100}},
                lineColor={0,0,0},
                textString="K"),
              Line(
                points={{-102,0},{64,0}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{52,-20},{52,20},{90,0},{52,-20}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}));
      end PrescribedTemperature;

      model PrescribedHeatFlow "Prescribed heat flow boundary condition"
        Modelica.Blocks.Interfaces.RealInput Q_flow
              annotation (Placement(transformation(
              origin={-100,0},
              extent={{20,-20},{-20,20}},
              rotation=180)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                  -10},{110,10}})));
      equation
        port.Q_flow = -Q_flow;
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Line(
                points={{-60,-20},{40,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-60,20},{40,20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,20}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{40,0},{40,40},{70,20},{40,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{40,-40},{40,0},{70,-20},{40,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{70,40},{90,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,100},{150,60}},
                textString="%name",
                lineColor={0,0,255})}),
          Documentation(info="<HTML>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The amount of heat
is given by the input signal Q_flow into the model. The heat flows into the
component to which the component PrescribedHeatFlow is connected,
if the input signal is positive.
</p>
<p>
This model is identical to
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>, except that
the parameters <code>alpha</code> and <code>T_ref</code> have
been deleted as these can cause division by zero in some fluid flow models.
</p>
</html>",    revisions="<html>
<ul>
<li>
March 29 2011, by Michael Wetter:<br/>
First implementation based on <a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>.
</li>
</ul>
</html>"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(
                points={{-60,-20},{68,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-60,20},{68,20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,20}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{60,0},{60,40},{90,20},{60,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{60,-40},{60,0},{90,-20},{60,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}));
      end PrescribedHeatFlow;
      annotation (   Documentation(info="<html>
This package is identical to
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources\">
Modelica.Thermal.HeatTransfer.Sources</a>, except that
the parameters <code>alpha</code> and <code>T_ref</code> have
been deleted in the models
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow</a> and
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>
 as these can cause division by zero in some fluid flow models.
</html>"));
    end Sources;

    package Windows "Package with models for windows"
      extends Modelica.Icons.VariantsPackage;

      model Window "Model for a window"

        parameter Buildings.HeatTransfer.Data.GlazingSystems.Generic glaSys
          "Glazing system"
          annotation (choicesAllMatching=true, Placement(transformation(extent={{150,174},
                  {170,194}})));
        parameter Modelica.SIunits.Area A "Heat transfer area";
        parameter Real fFra(min=0, max=1)=0.1 "Fraction of frame";
        final parameter Modelica.SIunits.Area AFra = fFra*A "Frame area";
        final parameter Modelica.SIunits.Area AGla = A-AFra "Glass area";
        parameter Boolean linearize=false
          "Set to true to linearize emissive power";
        parameter Modelica.SIunits.Angle til(displayUnit="deg") "Surface tilt";

        Interfaces.RadiosityOutflow JOutUns_a
          "Outgoing radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-200,70},{-220,90}})));
        Interfaces.RadiosityInflow JInUns_a
          "Incoming radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-220,110},{-200,130}})));
        Interfaces.RadiosityOutflow JOutSha_a if haveShade
          "Outgoing radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-200,-110},{-220,-90}})));
        Interfaces.RadiosityInflow JInSha_a if haveShade
          "Incoming radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-220,-70},{-200,-50}})));

        Interfaces.RadiosityOutflow JOutUns_b
          "Outgoing radiosity that connects to unshaded part of glass at room-side"
          annotation (Placement(transformation(extent={{200,110},{220,130}})));
        Interfaces.RadiosityInflow JInUns_b
          "Incoming radiosity that connects to unshaded part of glass at room-side"
          annotation (Placement(transformation(extent={{220,70},{200,90}})));
        Interfaces.RadiosityOutflow JOutSha_b if haveShade
          "Outgoing radiosity that connects to shaded part of glass at room-side"
          annotation (Placement(transformation(extent={{200,-70},{220,-50}})));
        Interfaces.RadiosityInflow JInSha_b if haveShade
          "Incoming radiosity that connects to shaded part of glass at room-side"
          annotation (Placement(transformation(extent={{220,-110},{200,-90}})));

        Buildings.HeatTransfer.Windows.BaseClasses.CenterOfGlass glaUns(
          final glaSys=glaSys,
          final A=AGla,
          final til=til,
          final linearize=linearize) "Model for unshaded center of glass"
          annotation (Placement(transformation(extent={{-10,10},{10,30}})));

        Buildings.HeatTransfer.Windows.BaseClasses.CenterOfGlass glaSha(
          final glaSys=glaSys,
          final A=AGla,
          final til=til,
          final linearize=linearize) if haveShade
          "Model for shaded center of glass"
          annotation (Placement(transformation(extent={{-10,-30},{10,-10}})));

        Modelica.Thermal.HeatTransfer.Components.ThermalConductor frame(G=AFra*
              glaSys.UFra) "Thermal conductance of frame"
          annotation (Placement(transformation(extent={{-10,-170},{10,-150}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns_a
          "Heat port at unshaded glass of exterior-facing surface"
                                                          annotation (Placement(transformation(extent={{-210,10},
                  {-190,30}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaUns_b
          "Heat port at unshaded glass of room-facing surface"
                                                      annotation (Placement(transformation(extent={{190,10},
                  {210,30}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha_a if haveShade
          "Heat port at shaded glass of exterior-facing surface"
          annotation (Placement(transformation(extent={{-210, -30}, {-190,-10}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaSha_b if haveShade
          "Heat port at shaded glass of room-facing surface"
        annotation (Placement(transformation(extent={{190,-30}, {210,-10}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a fra_a
          "Heat port at frame of exterior-facing surface"                                   annotation (Placement(transformation(extent={{-210,
                  -170},{-190,-150}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b fra_b
          "Heat port at frame of room-facing surface"                                       annotation (Placement(transformation(extent={{192,
                  -170},{212,-150}})));
        Modelica.Blocks.Interfaces.RealInput uSha(min=0, max=1) if
             haveShade
          "Control signal for the shading device. 0: unshaded; 1: fully shaded (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-240,140},{-200,180}})));

        Modelica.Blocks.Interfaces.RealInput QAbsUns_flow[glaSys.nLay](each unit="W",
            each quantity="Power")
          "Solar radiation absorbed by unshaded part of glass"
                                                             annotation (Placement(
              transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-80,-220}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-80,-220})));
        Modelica.Blocks.Interfaces.RealInput QAbsSha_flow[glaSys.nLay](each unit="W",
            each quantity="Power") if haveShade
          "Solar radiation absorbed by shaded part of glass"
                                              annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={60,-220}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={80,-220})));

      protected
        final parameter Boolean haveShade = glaSys.haveExteriorShade or glaSys.haveInteriorShade
          "Parameter, equal to true if the window has a shade"
          annotation(Evaluate=true);

        BaseClasses.ShadingSignal shaSig(final haveShade=glaSys.haveExteriorShade or glaSys.haveInteriorShade)
          "Block to constrain the shading control signal to be strictly within (0, 1) if a shade is present"
          annotation (Placement(transformation(extent={{-60,150},{-40,170}})));

      equation
        connect(frame.port_a, fra_a) annotation (Line(
            points={{-10,-160},{-200,-160}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(frame.port_b, fra_b)  annotation (Line(
            points={{10,-160},{202,-160}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(glaUns.glass_a, glaUns_a)
                                        annotation (Line(
            points={{-10,20},{-200,20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(glaUns.glass_b, glaUns_b)
                                        annotation (Line(
            points={{10,20},{200,20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(shaSig.yCom, glaUns.u) annotation (Line(
            points={{-39,154},{-20,154},{-20,28},{-11,28}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaSig.y, glaSha.u) annotation (Line(
            points={{-39,160},{-24,160},{-24,-12},{-11,-12}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaSig.u, uSha)
                             annotation (Line(
            points={{-62,160},{-220,160}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(glaSha.glass_a, glaSha_a) annotation (Line(
            points={{-10,-20},{-200,-20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(glaSha.glass_b, glaSha_b) annotation (Line(
            points={{10,-20},{200,-20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(JInUns_a, glaUns.JIn_a) annotation (Line(
            points={{-210,120},{-40,120},{-40,24},{-11,24}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(glaUns.JOut_a, JOutUns_a) annotation (Line(
            points={{-11,16},{-46,16},{-46,80},{-210,80}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(glaUns.JOut_b, JOutUns_b) annotation (Line(
            points={{11,24},{170,24},{170,120},{210,120}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(JInUns_b, glaUns.JIn_b) annotation (Line(
            points={{210,80},{176,80},{176,16},{11,16}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(JInSha_a, glaSha.JIn_a) annotation (Line(
            points={{-210,-60},{-46,-60},{-46,-16},{-11,-16}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(glaSha.JOut_a, JOutSha_a) annotation (Line(
            points={{-11,-24},{-42,-24},{-42,-100},{-210,-100}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(glaSha.JOut_b, JOutSha_b) annotation (Line(
            points={{11,-16},{176,-16},{176,-60},{210,-60}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(JInSha_b, glaSha.JIn_b) annotation (Line(
            points={{210,-100},{172,-100},{172,-24},{11,-24}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(glaUns.QAbs_flow, QAbsUns_flow) annotation (Line(
            points={{6.10623e-16,9},{6.10623e-16,0},{-80,0},{-80,-220}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(glaSha.QAbs_flow,QAbsSha_flow)  annotation (Line(
            points={{6.10623e-16,-31},{6.10623e-16,-60},{60,-60},{60,-220}},
            color={0,0,127},
            smooth=Smooth.None));

        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -200},{200,200}}),     graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-200,-200},{200,200}}),                                           graphics={
              Polygon(
                visible=  glaSys.haveInteriorShade,
                points={{48,160},{48,60},{116,-4},{116,96},{48,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.CrossDiag,
                fillColor={215,215,215}),
              Line(
                points={{-74,-88},{28,-88}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{28,160},{28,-88},{90,-152},{90,96},{28,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-184,176},{-134,140}},
                lineColor={0,0,127},
                textString="uSha"),            Text(
                extent={{-60,238},{38,190}},
                lineColor={0,0,255},
                textString="%name"),
              Polygon(
                points={{38,138},{38,-84},{78,-124},{78,96},{38,138}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-102,160},{48,160}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-12,-152},{90,-152}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{-20,160},{-20,-88},{42,-152},{42,96},{-20,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-10,138},{-10,-84},{30,-124},{30,96},{-10,138}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-74,160},{-74,-88},{-12,-152},{-12,96},{-74,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-64,136},{-64,-86},{-24,-126},{-24,94},{-64,136}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                visible=  glaSys.haveExteriorShade,
                points={{-102,160},{-102,60},{-34,-4},{-34,96},{-102,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.CrossDiag,
                fillColor={215,215,215}),
              Line(
                points={{-34,96},{116,96}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-198,-160},{-60,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{84,-160},{200,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{56,20},{198,20}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-200,20},{-56,20}},
                color={160,0,0},
                smooth=Smooth.None), Ellipse(
                extent={{-226,234},{-164,170}},
                lineColor={255,255,0},
                fillColor={255,213,170},
                fillPattern=FillPattern.Sphere),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-198,-20},{-44,-20}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{56,-20},{198,-20}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-60,-100},{-60,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{84,-118},{84,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Text(
                extent={{36,-162},{126,-202}},
                lineColor={0,0,127},
                textString="QAbsSha"),
              Text(
                visible=  haveShade,
                extent={{-124,-164},{-34,-204}},
                lineColor={0,0,127},
                textString="QAbsUns")}),
          defaultComponentName="win",
          Documentation(info="<html>
<h4>Overview</h4>
<p>
This is a model for a window system. The equations are similar to the
equations used in the Window 5 model and described in TARCOG 2006.
The model computes
the heat balance from the exterior surface to
the room-facing surface for a window system.
The window system can have
an exterior or an interior shade, but not both, or it can
have no shade.
The convective heat transfer between the window system and the outside air
or the room is <em>not</em> computed by this model.
They can be computed using the models
<a href=\"modelica://Buildings.HeatTransfer.Windows.ExteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.ExteriorHeatTransfer</a>
and
<a href=\"modelica://Buildings.HeatTransfer.Windows.InteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.InteriorHeatTransfer</a>.
</p>

<h4>Limitations</h4>
<p>
To calculate the angular transmittance, reflectance and absorptance of a glazing system, Window 5 model first calculates the value for each wave length, then calculate the weighted value over entire wave lengths.
Current window model in Buildings library only uses the weighted value of each glass.
As a result, there are some differences in prediciton between the current Modelica window model and WINDOW 5.
The difference is small for single layer window or multi-layer window with the same glasses.
But it can be large for multi-layer window with different glasses.
</p>

<h4>Parameters</h4>
<p>
This model takes as the parameter <code>glaSys</code> a data record
from the package
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a>.
This data record specifies the properties of the glasses,
the gas fills, the frame and of
the shades, if any shade is present.
Whether a shade is present or not is determined by the parameters
<code>glaSys.haveExteriorShade</code> and
<code>glaSys.haveInteriorShade</code>.
</p>
<p>
The parameter <code>linearize</code> can be used
to linearize the model equations.
</p>
<h4>Ports</h4>
<p>
If a shade is present, then the input port <code>u</code> is used
to determine the
shade position. Set <code>u=0</code> to have the window in the
unshaded mode,
and set <code>u=1</code> to have the window shade completely deployed.
Any intermediate value is possible.
If no shade is present, then this port will be removed.
</p>
<p>
For the heat ports, the suffix <code>_a</code> is used for the exterior, outside-facing side
of the window, and the suffix <code>_b</code> is used for the interior, room-facing surface
of the window.
Each side has heat ports that connect to the glass, to the frame, and, optionally, to the
shade. If no shade is present, then the heat port to the shade will be removed.
</p>

<h4>Description of the Physics</h4>
<p>
The model has three main submodels that implement the relevant
heat balances:</p>
<ol>
<li>
The model <code>frame</code> computes heat conduction
through the frame.
</li>
<li>
The model <code>glaUns</code> computes the heat balance of the part of the
window that is unshaded. For example, if <code>u=0.2</code>, then this model accounts for
the 80% of the window that is not behind the shade or blind.
</li>
<li>
The model <code>glaSha</code> computes the heat balance of the part of the
window that is shaded. For example, if <code>u=0.2</code>, then this model accounts for
the 20% of the window that is behind the shade or blind.
If the parameter <code>glaSys</code> specifies that the window has no exterior
and no interior shade, then the model <code>glaSha</code> will be removed.
</li>
</ol>

<p>
The models <code>glaUns</code> and <code>glaSha</code>
compute the solar radiation that is absorbed by each
glass pane and the solar radiation that is transitted
through the window as a function of the solar incidence angle.
They then compute a heat balance that takes into account heat conduction through the glass,
heat convection through the gas layer,
and infrared radiation from the exterior and the room through the glass and gas layers.
The infrared radiative heat exchange is computed using a radiosity balance.
Heat conduction through the frame is computed using a heat flow path that is parallel to the
glazing system, i.e., there is no heat exchange between the frame
and the glazing layer.
</p>

<h4>Validation</h4>
<p>
The window model has been validated by using measurement data at LBNL's Test Cell 71T and by using
a comparative model validation with the WINDOW 6 program. These validations are described in Nouidui et al. (2012).
The window model has also been validated as part of the BESTEST validations that are implemented in
<a href=\"modelica://Buildings.Rooms.Examples.BESTEST\">
Buildings.Rooms.Examples.BESTEST</a>.
</p>

<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with or without
shading devices, Technical Report, Oct. 17, 2006.
</p>

<p>
Thierry Stephane Nouidui, Michael Wetter, and Wangda Zuo.
<a href=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/2012-simBuild-windowValidation.pdf\">
Validation of the window model of the Modelica Buildings library.</a>
<i>Proc. of the 5th SimBuild Conference</i>, Madison, WI, USA, August 2012.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
December 19, 2011, by Wangda Zuo:<br/>
Add a warning note to remind users that the model does not count wave length dependence for calculation.
</li>
<li>
March 10 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Window;

      model ExteriorHeatTransfer
        "Model for heat convection and radiation at the exterior surface of a window that may have a shading device"
        extends BaseClasses.PartialWindowBoundaryCondition(final thisSideHasShade=haveExteriorShade);
        parameter Modelica.SIunits.Emissivity absIRSha_air
          "Infrared absorptivity of shade surface that faces air"
              annotation (Dialog(group="Shading"));
        parameter Modelica.SIunits.Emissivity absIRSha_glass
          "Infrared absorptivity of shade surface that faces glass"
          annotation (Dialog(group="Shading"));

        parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_air
          "Infrared transmissivity of shade for radiation coming from the exterior or the room"
          annotation (Dialog(group="Shading"));
        parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_glass
          "Infrared transmissivity of shade for radiation coming from the glass"
          annotation (Dialog(group="Shading"));

        parameter Boolean linearizeRadiation
          "Set to true to linearize emissive power";
        parameter Real vieFacSky(final min=0, final max=1, final unit="1")
          "View factor from receiving surface to sky";

        Modelica.Blocks.Interfaces.RealInput vWin(final unit="m/s")
          "Wind speed"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}}),
              iconTransformation(extent={{-116,32},{-100,48}})));
        Buildings.HeatTransfer.Windows.BaseClasses.ExteriorConvectionCoefficient
          conCoeGla(                                          final A=AGla)
          "Model for the outside convective heat transfer coefficient of the glass"
          annotation (Placement(transformation(extent={{-84,40},{-64,60}})));
        Buildings.HeatTransfer.Windows.BaseClasses.ExteriorConvectionCoefficient
          conCoeFra(                                          final A=AFra)
          "Model for the outside convective heat transfer coefficient of the frame"
          annotation (Placement(transformation(extent={{-20,-80},{0,-60}})));
       Radiosity.OutdoorRadiosity radOut(
         final A=AGla, vieFacSky=vieFacSky,
          linearize=linearizeRadiation) "Outdoor radiosity"
          annotation (Placement(transformation(extent={{-72,-72},{-52,-52}})));

        Modelica.Blocks.Interfaces.RealInput TBlaSky(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Black body sky temperature"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}}),
              iconTransformation(extent={{-120,-50},{-100,-30}})));
        Modelica.Blocks.Interfaces.RealInput TOut(final quantity="ThermodynamicTemperature",
                                                  final unit = "K", min=0)
          "Outside temperature"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}}),
              iconTransformation(extent={{-120,-92},{-100,-72}})));
        Interfaces.RadiosityOutflow JOutUns
          "Outgoing radiosity that connects to unshaded part of glass"
          annotation (Placement(transformation(extent={{100,70},{120,90}})));
        Interfaces.RadiosityInflow JInUns
          "Incoming radiosity that connects to unshaded part of glass"
          annotation (Placement(transformation(extent={{120,50},{100,70}})));
        Interfaces.RadiosityOutflow JOutSha if haveShade
          "Outgoing radiosity that connects to shaded part of glass"
          annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
        Interfaces.RadiosityInflow JInSha if haveShade
          "Incoming radiosity that connects to shaded part of glass"
          annotation (Placement(transformation(extent={{120,-90},{100,-70}})));
        Modelica.Blocks.Interfaces.RealInput QSolAbs_flow(unit="W", quantity="Power") if
             haveShade "Solar radiation absorbed by shade"
          annotation (Placement(transformation(
              origin={0,-120},
              extent={{-20,-20},{20,20}},
              rotation=90), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,-110})));

        BaseClasses.ShadeRadiation shaRad(
          final thisSideHasShade=thisSideHasShade,
          final A=AGla,
          final linearize=linearizeRadiation,
          final absIR_air=if thisSideHasShade then absIRSha_air else 0,
          final absIR_glass=if thisSideHasShade then absIRSha_glass else 0,
          final tauIR_air=if thisSideHasShade then tauIRSha_air else 1,
          final tauIR_glass=if thisSideHasShade then tauIRSha_glass else 1) if
             haveShade "Radiative heat balance of shade"
          annotation (Placement(transformation(extent={{0,-20},{20,0}})));
      protected
        Radiosity.RadiositySplitter radShaOut
          "Radiosity that strikes shading device"
          annotation (Placement(transformation(extent={{-40,-40},{-20,-20}})));
        BaseClasses.ShadeConvection shaCon(final thisSideHasShade=thisSideHasShade,
            final A=AGla) if
             haveShade "Convective heat balance of shade"
          annotation (Placement(transformation(extent={{0,20},{20,40}})));
      equation
        assert(-1E-10<vieFacSky and 1.00001 > vieFacSky,
               "View factor to sky is out of range. vieFacSky = " + String(vieFacSky)
               + "\n   Check parameters.");

        connect(vWin, conCoeGla.v)
                                 annotation (Line(
            points={{-120,40},{-90,40},{-90,50},{-86,50}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(vWin, conCoeFra.v) annotation (Line(
            points={{-120,40},{-90,40},{-90,-70},{-22,-70}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeFra.GCon, conFra.Gc) annotation (Line(
            points={{1,-70},{40,-70},{40,-78}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeGla.GCon, proSha.u1) annotation (Line(
            points={{-63,50},{-56,50},{-56,36},{-52,36}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeGla.GCon, proUns.u2) annotation (Line(
            points={{-63,50},{-40,50},{-40,74},{18,74}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radOut.JOut, radShaOut.JIn) annotation (Line(
            points={{-51,-62},{-46,-62},{-46,-24},{-41,-24}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(radOut.TBlaSky, TBlaSky) annotation (Line(
            points={{-74,-58},{-86,-58},{-86,-40},{-120,-40}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radOut.TOut, TOut) annotation (Line(
            points={{-74,-66},{-86,-66},{-86,-80},{-120,-80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radShaOut.JOut_2,JOutUns)  annotation (Line(
            points={{-19,-36},{90,-36},{90,80},{110,80}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(shaRad.JOut_glass, JOutSha)
                                           annotation (Line(
            points={{21,-14},{80,-14},{80,-60},{110,-60}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(shaRad.JIn_glass, JInSha)
                                         annotation (Line(
            points={{21,-18},{70,-18},{70,-80},{110,-80}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(radShaOut.JOut_1, shaRad.JIn_air)
                                                 annotation (Line(
            points={{-19,-24},{-12,-24},{-12,-14},{-1,-14}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(shaRad.u, shaSig.y)
                                   annotation (Line(
            points={{-1,-2},{-60,-2},{-60,80},{-69,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(glaSha, shaCon.glass) annotation (Line(
            points={{100,-20},{30,-20},{30,30},{19.4,30}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(shaCon.air, air) annotation (Line(
            points={{0,30},{-20,30},{-20,10},{-80,10},{-80,5.55112e-16},{-100,
                5.55112e-16},{-100,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(shaCon.Gc, proSha.y) annotation (Line(
            points={{-1,34},{-24,34},{-24,30},{-29,30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaCon.TSha, shaRad.TSha) annotation (Line(
            points={{16,19},{16,6},{26,6},{26,-26},{15,-26},{15,-21}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaRad.QRadAbs_flow, shaCon.QRadAbs_flow) annotation (Line(
            points={{5,-21},{5,-26},{-6,-26},{-6,12},{4,12},{4,19}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radShaOut.u, shaSig.y) annotation (Line(
            points={{-42,-36},{-60,-36},{-60,80},{-69,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaRad.QSolAbs_flow, QSolAbs_flow) annotation (Line(
            points={{10,-21},{10,-84},{8.88178e-16,-84},{8.88178e-16,-120}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation ( Icon(graphics={
              Text(
                extent={{-94,48},{-52,32}},
                lineColor={0,0,127},
                textString="vWind"), Ellipse(
                extent={{-110,110},{-90,90}},
                lineColor={255,255,0},
                fillColor={255,213,170},
                fillPattern=FillPattern.Sphere),
              Text(
                extent={{-96,-76},{-66,-88}},
                lineColor={0,0,127},
                textString="TOut"),
              Text(
                extent={{-94,-34},{-54,-46}},
                lineColor={0,0,127},
                textString="TBlaSky"),
              Text(
                extent={{-38,-84},{28,-102}},
                lineColor={0,0,127},
                textString="QSolAbs")}),
      defaultComponentName="extHeaTra",
                 Documentation(info="<html>
<p>
Model for the convective heat transfer between a window shade, a window surface
and the room air.
This model is applicable for the outside-facing surface of a window system and
can be used with the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a>.
</p>
<p>
This model adds the convective heat transfer coefficient to its base model.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 8 2012, by Michael Wetter:<br/>
Changed model to use new implementation of
<a href=\"modelica://Buildings.HeatTransfer.Radiosity.OutdoorRadiosity\">
Buildings.HeatTransfer.Radiosity.OutdoorRadiosity</a>.
This change leads to the use of the same equations for the radiative
heat transfer between window and ambient as is used for
the opaque constructions.
</li>
<li>
October 25 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ExteriorHeatTransfer;

      model InteriorHeatTransferConvective
        "Model for heat convection at the interior surface of a window that may have a shading device"
        extends BaseClasses.PartialWindowBoundaryCondition(final thisSideHasShade=haveInteriorShade);
        Buildings.HeatTransfer.Windows.BaseClasses.InteriorConvectionCoefficient
          conCoeGla(final A=AGla)
          "Model for the inside convective heat transfer coefficient of the glass"
          annotation (Placement(transformation(extent={{-90,40},{-70,60}})));
        Buildings.HeatTransfer.Windows.BaseClasses.InteriorConvectionCoefficient
          conCoeFra(final A=AFra)
          "Model for the inside convective heat transfer coefficient of the frame"
          annotation (Placement(transformation(extent={{-20,-80},{0,-60}})));

        BaseClasses.ShadeConvection conSha(
          final A=AGla,
          final thisSideHasShade=thisSideHasShade) if
             haveShade "Convection model for shade"
          annotation (Placement(transformation(extent={{-8,-20},{12,0}})));
       Modelica.Blocks.Interfaces.RealInput QRadAbs_flow(final unit="W") if
             haveShade
          "Total net radiation that is absorbed by the shade (positive if absorbed)"
           annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                             rotation=270,
              origin={-60,-110}),         iconTransformation(extent={{10,-10},{-10,10}},
              rotation=270,
              origin={-60,-110})));
        Modelica.Blocks.Interfaces.RealOutput TSha(
         final unit="K",
         final quantity="ThermodynamicTemperature") if
            haveShade "Shade temperature"
                             annotation (
            Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={0,-110}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={0,-110})));
      equation
        connect(conCoeFra.GCon, conFra.Gc) annotation (Line(
            points={{1,-70},{40,-70},{40,-78}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeGla.GCon, proUns.u2) annotation (Line(
            points={{-69,50},{8,50},{8,74},{18,74}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeGla.GCon, proSha.u1) annotation (Line(
            points={{-69,50},{-56,50},{-56,36},{-52,36}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(conSha.glass, glaSha) annotation (Line(
            points={{11.4,-10},{54,-10},{54,-20},{100,-20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(proSha.y, conSha.Gc) annotation (Line(
            points={{-29,30},{-20,30},{-20,-6},{-9,-6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conSha.TSha, TSha) annotation (Line(
            points={{8,-21},{8,-96},{0,-96},{0,-110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(QRadAbs_flow, conSha.QRadAbs_flow) annotation (Line(
            points={{-60,-110},{-60,-40},{-4,-40},{-4,-21}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(conFra.fluid, air) annotation (Line(
            points={{30,-88},{-80,-88},{-80,5.55112e-16},{-100,5.55112e-16},{-100,0}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(air, conSha.air) annotation (Line(
            points={{-100,0},{-80,0},{-80,-10},{-8,-10}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation (defaultComponentName="intConSha",
      Documentation(info="<html>
<p>
Model for the convective heat transfer between a window shade, a window surface
and the room air.
This model is applicable for the room-facing surface of a window system and
can be used with the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a>.
</p>
<p>
This model adds the convective heat transfer coefficient to its base model.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 11, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
               graphics={
              Text(
                extent={{-94,-82},{-28,-100}},
                lineColor={0,0,127},
                textString="QRadAbs"),
              Text(
                extent={{-28,-84},{34,-100}},
                lineColor={0,0,127},
                textString="TSha")}));
      end InteriorHeatTransferConvective;

      model FixedShade
        "Model for exterior shade due to overhang and/or side fin"
        extends HeatTransfer.Windows.BaseClasses.ShadeInterface_weatherBus;
        parameter Buildings.Rooms.BaseClasses.ParameterConstructionWithWindow conPar
          "Construction parameters";

        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle azi(displayUnit="deg")
          "Surface azimuth; azi= -90 degree East; azi= 0 South";

        Modelica.Blocks.Routing.Multiplex4 mulFraSun(
          n1=1,
          n2=1,
          n3=1,
          n4=1) "Multiplex for fraction of shaded area"
          annotation (Placement(transformation(extent={{32,0},{52,20}})));

        Modelica.Blocks.Math.Add sumFraSun
          "Addition of sun exposed window area fractions"
          annotation (Placement(transformation(extent={{-40,-40},{-28,-28}})));

        Modelica.Blocks.Math.Add resFraSun(k2=1.0, k1=-1.0)
          "Calculates resultant sun exposed window area fraction"
          annotation (Placement(transformation(extent={{-40,-6},{-28,6}})));
        Modelica.Blocks.Sources.Constant overlap(k=1.0)
          "Overlap of sun exposed window area fraction"
          annotation (Placement(transformation(extent={{-40,20},{-28,32}})));
        Modelica.Blocks.Sources.Constant noSunCond(k=small)
          "Condition when the sun is not in front of window"
          annotation (Placement(transformation(extent={{-20,-40},{-8,-28}})));

      protected
        constant Real small = 0.001
          "Small number, used to avoid that sun-exposed fraction of window is negative";

        final parameter Boolean haveOverhang = conPar.ove.haveOverhang
          "Flag for overhang" annotation (Evaluate=true);

        final parameter Boolean haveSideFins = conPar.sidFin.haveSideFins
          "Flag for sidefins" annotation (Evaluate=true);
        final parameter Boolean haveOverhangAndSideFins= (haveOverhang
             and haveSideFins) "Flag for overhang and sidefins";

        final parameter Integer idx = if haveOverhangAndSideFins then 2 elseif haveOverhang then 1 elseif haveSideFins then 3 else 4
          "Integer used to pick the appropriate output signal";

        HeatTransfer.Windows.BaseClasses.Overhang ove(
          final lat=lat,
          final azi=conPar.azi,
          final hWin=conPar.hWin,
          final wWin=conPar.wWin,
          final dep=conPar.ove.dep,
          final gap=conPar.ove.gap,
          final wR=conPar.ove.wR,
          final wL=conPar.ove.wL) "Model for overhang"
          annotation (Placement(transformation(extent={{-40,40},{-20,60}})));

        HeatTransfer.Windows.BaseClasses.SideFins sidFin(
          final hWin=conPar.hWin,
          final wWin=conPar.wWin,
          final h=conPar.sidFin.h,
          final dep=conPar.sidFin.dep,
          final gap=conPar.sidFin.gap) "Model for side fins"
          annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));

        BoundaryConditions.SolarGeometry.BaseClasses.WallSolarAzimuth walSolAzi
          "Angle measured in horizontal plane between projection of sun's rays and normal to vertical surface"
           annotation (Placement(transformation(extent={{-80,-90},{-60,-70}})));
        Modelica.Blocks.Math.Product mulHDir
          "Multiplication to obtain direct solar irradiation on shaded window"
          annotation (Placement(transformation(extent={{60,50},{80,70}})));

        Modelica.Blocks.Routing.Extractor extFraSun(final allowOutOfRange=false, final
            nin=4,
          index(start=idx, fixed=true))
          "Extractor to pick the appropriate output signal"
          annotation (Placement(transformation(extent={{60,0},{80,20}})));
        Modelica.Blocks.Sources.IntegerConstant idxSou(final k=idx)
          "Source term to pick output signal"
          annotation (Placement(transformation(extent={{40,-80},{60,-60}})));
        Modelica.Blocks.Sources.Constant const(k=1)
          annotation (Placement(transformation(extent={{0,-90},{20,-70}})));

        Utilities.Math.SmoothMax smoMax(deltaX=small/2)
          "Limiter to avoid that the fraction of sun-exposed window is below zero"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
      equation
        connect(weaBus.solAlt, walSolAzi.alt) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,-76},{-82,-76},{-82,
                -75.2}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));

        connect(incAng, walSolAzi.incAng) annotation (Line(
            points={{-120,-60},{-96,-60},{-96,-84.8},{-82,-84.8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(walSolAzi.verAzi, ove.verAzi) annotation (Line(
            points={{-59,-80},{-54,-80},{-54,54},{-42,54}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(walSolAzi.verAzi, sidFin.verAzi) annotation (Line(
            points={{-59,-80},{-54,-80},{-54,-56},{-42,-56}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.solAlt, sidFin.alt) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,-64},{-42,-64}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(mulHDir.y, HDirTil) annotation (Line(
            points={{81,60},{110,60}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(mulHDir.u1, HDirTilUns) annotation (Line(
            points={{58,66},{40,66},{40,80},{-60,80},{-60,60},{-120,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus, ove.weaBus) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,50},{-40.2,50}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(extFraSun.y, fraSun) annotation (Line(
            points={{81,10},{90,10},{90,5.55112e-16},{110,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(extFraSun.y, mulHDir.u2) annotation (Line(
            points={{81,10},{90,10},{90,40},{40,40},{40,54},{58,54}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(mulFraSun.y, extFraSun.u)    annotation (Line(
            points={{53,10},{58,10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(ove.fraSun, mulFraSun.u1[1])    annotation (Line(
            points={{-19,50},{24,50},{24,19},{30,19}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(sidFin.fraSun, mulFraSun.u3[1])    annotation (Line(
            points={{-19,-60},{22,-60},{22,7},{30,7}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(const.y, mulFraSun.u4[1])    annotation (Line(
            points={{21,-80},{26,-80},{26,1},{30,1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.solAlt, ove.alt) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,46},{-42,46}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(ove.fraSun, sumFraSun.u1)
                                    annotation (Line(
            points={{-19,50},{-14,50},{-14,36},{-48,36},{-48,-30.4},{-41.2,-30.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(sumFraSun.y, resFraSun.u2)
                                annotation (Line(
            points={{-27.4,-34},{-22,-34},{-22,-22},{-44,-22},{-44,-3.6},{-41.2,-3.6}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(overlap.y, resFraSun.u1)
                                    annotation (Line(
            points={{-27.4,26},{-22,26},{-22,10},{-44,10},{-44,3.6},{-41.2,3.6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(sidFin.fraSun, sumFraSun.u2)
                                       annotation (Line(
            points={{-19,-60},{-12,-60},{-12,-44},{-48,-44},{-48,-37.6},{-41.2,-37.6}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(idxSou.y, extFraSun.index) annotation (Line(
            points={{61,-70},{70,-70},{70,-2}},
            color={255,127,0},
            smooth=Smooth.None));
        connect(resFraSun.y, smoMax.u1) annotation (Line(
            points={{-27.4,-1.88738e-16},{-19.7,-1.88738e-16},{-19.7,6},{-12,6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(noSunCond.y, smoMax.u2) annotation (Line(
            points={{-7.4,-34},{0,-34},{0,-14},{-20,-14},{-20,-6},{-12,-6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(smoMax.y, mulFraSun.u2[1]) annotation (Line(
            points={{11,6.10623e-16},{18,6.10623e-16},{18,13},{30,13}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation ( Icon(graphics={Bitmap(extent={{-92,92},{92,-92}},
                  fileName="modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/Overhang.png")}),
      defaultComponentName="sha",
      Documentation(info="<html>
<p>
This model outputs the fraction of the window area that is sun exposed
for a window that may have an overhang and sidefins.
Depending on the record with construction data <code>conPar</code>,
an overhang, side fins or no external shade is modeled.
The model allows having an overhang and side fins at the same time.
In such a case, the overhang width should be
measured from the window edge to the sidefin,
because the overhang width beyond the sidefin will
cast a shadow on the side fin and not on the window.
Similarly, the side fin height should be measured
from the upper window edge to the overhang,
because the side fin height above the
overhang will not cast a shadow on the window.
The parameters for the dimensions of the overhang and side fins are as
described in the models
<a href=\"modelica://Buildings.HeatTransfer.Windows.Overhang\">
Buildings.HeatTransfer.Windows.Overhang</a>
and
<a href=\"modelica://Buildings.HeatTransfer.Windows.SideFins\">
Buildings.HeatTransfer.Windows.SideFins</a>.
</p>

<h4>Limitations</h4>
<p>
For overhangs, the model assumes that
</p>
<ul>
<li>
the overhang is at least as wide as the window, i.e.,
<i>w<sub>L</sub> &ge; 0</i> and
<i>w<sub>R</sub> &ge; 0</i>, and
</li>
<li>
the overhang is horizontal.
</li>
</ul>

<p>
For side fins, the model assumes that
</p>
<ul>
<li>
the side fins are placed symmetrically to the left and right of the window,
</li>
<li>
the top of the side fins must be at an equal or greater height than the window, and
</li>
<li>
the side fins extends at least to the lower edge of the window.
</li>
</ul>

<h4>Implementation</h4>
<p>
The detailed calculation method is explained in
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.SideFins\">
Buildings.HeatTransfer.Windows.BaseClasses.SideFins</a>
and in
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.Overhang\">
Buildings.HeatTransfer.Windows.BaseClasses.Overhang</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
July 7, 2012, by Michael Wetter:<br/>
Renamed model from <code>Shade</code> to <code>FixedShade</code> because
shade is already used for window interior and exterior shades.
</li><li>
July 5, 2012, by Michael Wetter:<br/>
Moved model from package <code>Buildings.Rooms.BaseClasses</code> to
<code>Buildings.HeatTransfer.Windows</code>, because the overhang and side fin
models are also in this package.
</li>
<li>
May 21, 2012, by Kaustubh Phalak:<br/>
Enabled the model to use overhang and side at the same time.
</li>
<li>
March 5, 2012, by Michael Wetter:<br/>
First implementation.
</li>

</ul>
</html>"));
      end FixedShade;

      package BaseClasses
        "Package with base classes for Buildings.HeatTransfer.Windows"
        extends Modelica.Icons.BasesPackage;

        block AbsorbedRadiation "Absorbed radiation by window"
          extends Buildings.HeatTransfer.Windows.BaseClasses.PartialRadiation;

          Modelica.Blocks.Interfaces.RealInput HRoo(quantity="RadiantEnergyFluenceRate",
              unit="W/m2") "Diffussive radiation from room " annotation (Placement(
                transformation(extent={{-140,-100},{-100,-60}}),iconTransformation(
                  extent={{-130,-91},{-100,-61}})));

          Modelica.Blocks.Interfaces.RealOutput QAbsExtSha_flow(final quantity="Power",
              final unit="W")
            "Absorbed interior and exterior radiation by exterior shading device"
            annotation (Placement(transformation(extent={{100,70},{120,90}}),
                iconTransformation(extent={{100,70},{120,90}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsIntSha_flow(final quantity="Power",
              final unit="W")
            "Absorbed interior and exterior radiation by interior shading device"
            annotation (Placement(transformation(extent={{100,-90},{120,-70}}),
                iconTransformation(extent={{100,-90},{120,-70}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaUns_flow[N](each quantity=
                "Power", each final unit="W")
            "Absorbed interior and exterior radiation by unshaded part of glass"
            annotation (Placement(transformation(extent={{100,30},{120,50}}),
                iconTransformation(extent={{100,30},{120,50}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaSha_flow[N](each quantity=
                "Power", each final unit="W")
            "Absorbed interior and exterior radiation by shaded part of glass"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}}),
                iconTransformation(extent={{100,-50},{120,-30}})));

          output Modelica.SIunits.Power absRad[2, N + 2] "Absorbed interior and exterior radiation.
      (absRad[2,1]: exterior shading device,
      absRad[1,2 to N+1]: glass (unshaded part),
      absRad[2,2 to N+1]: glass (shaded part),
      absRad[2,N+2]: interior shading device)";

        protected
          constant Integer k=1;
          Real x;
          final parameter Integer NDIR=radDat.NDIR;
          final parameter Integer HEM=radDat.HEM;
          constant Integer NoShade=1;
          constant Integer Shade=2;
          constant Integer Interior=1;
          constant Integer Exterior=2;
          final parameter Real coeAbsEx[2, radDat.N, radDat.HEM + 2](each fixed=false);
          final parameter Real coeRefExtPan1[radDat.HEM + 2](each fixed=false)
            "Reflectivity of pane 1";
          final parameter Real coeAbsIn[2, radDat.N](each fixed=false);
          final parameter Real coeAbsDevExtIrrIntSha[radDat.HEM + 2](each fixed=false)
            "Absorptivity of interior shading device for exterior radiation";
          final parameter Real coeAbsDevExtIrrExtSha=1 - radDat.traRefShaDev[1, 1] -
              radDat.traRefShaDev[2, 1]
            "Absorptivity of exterior shading device for exterior radiation";
          final parameter Real coeAbsDevIntIrrIntSha=radDat.devAbsIntIrrIntSha
            "Absorptivity of interior shading device for interior radiation";
          final parameter Real coeAbsDevIntIrrExtSha=1 - radDat.winTraRefIntIrrExtSha[1]
               - radDat.winTraRefIntIrrExtSha[2]
            "Absorptivity of exterior shading device for interior radiation";
          Real tmpNoSha;
          Real tmpSha;
          Real incAng2;

        initial algorithm
          //**************************************************************
          // Assign coefficients.
          // Data dimension changes from Orginal ([1 : HEM]) to New ([2 : HEM+1])
          // with 2 dummy variable for interpolation.
          //**************************************************************
          // Glass
          for i in 1:N loop
            for j in 1:HEM loop
              // Properties for glass without shading
              coeAbsEx[NoShade, i, j + 1] := radDat.absExtIrrNoSha[i, j];
              coeAbsIn[NoShade, i] := radDat.absIntIrrNoSha[i];
              // Properties for glass with shading
              if haveInteriorShade then
                coeAbsEx[Shade, i, j + 1] := radDat.absExtIrrIntSha[i, j];
                coeAbsIn[Shade, i] := radDat.absIntIrrIntSha[i];
              elseif haveExteriorShade then
                coeAbsEx[Shade, i, j + 1] := radDat.absExtIrrExtSha[i, j];
                coeAbsIn[Shade, i] := radDat.absIntIrrExtSha[i];
              else
                // No Shade
                coeAbsEx[Shade, i, j + 1] := 0.0;
                coeAbsIn[Shade, i] := 0.0;
              end if;
            end for;
            // Dummy variables at 1 and HEM+2
            for k in NoShade:Shade loop
              coeAbsEx[k, i, 1] := coeAbsEx[k, i, 2];
              coeAbsEx[k, i, HEM + 2] := coeAbsEx[k, i, HEM + 1];
            end for;
          end for;

          // Glass Pane 1: Reflectivity
          for j in 1:HEM loop
            coeRefExtPan1[j + 1] := radDat.traRef[2, 1, N, j];
          end for;

          // Interior shades
          for j in 1:HEM loop
            coeAbsDevExtIrrIntSha[j + 1] := radDat.devAbsExtIrrIntShaDev[j];
          end for;

          // Dummy variables at 1 and HEM+2
          coeRefExtPan1[1] := coeRefExtPan1[2];
          coeRefExtPan1[HEM + 2] := coeRefExtPan1[HEM + 1];
          coeAbsDevExtIrrIntSha[1] := coeAbsDevExtIrrIntSha[2];
          coeAbsDevExtIrrIntSha[HEM + 2] := coeAbsDevExtIrrIntSha[HEM + 1];

        algorithm
          absRad[NoShade, 1] := 0.0;
          absRad[NoShade, N + 2] := 0.0;
          absRad[Shade, 1] := 0.0;
          absRad[Shade, N + 2] := 0.0;

          //**************************************************************
          // Glass: absorbed diffusive radiation from exterior and interior sources
          //**************************************************************
          for i in 1:N loop
            absRad[NoShade, i + 1] := AWin*(1 - uSha_internal)*(HDif*coeAbsEx[NoShade,
              i, HEM + 1] + HRoo*coeAbsIn[NoShade, i]);
            absRad[Shade, i + 1] := AWin*uSha_internal*(HDif*coeAbsEx[Shade, i, HEM + 1]
               + HRoo*coeAbsIn[Shade, i]);
          end for;

          //**************************************************************
          // Shading device: absorbed radiation from exterior source
          //**************************************************************
          // Exterior Shading Device:
          // direct radiation: 1. direct absorption;
          // diffusive radiation: 1. direct absorption 2. absorption from back reflection
          if haveExteriorShade then
            absRad[Shade, 1] := AWin*uSha_internal*coeAbsDevExtIrrExtSha*(HDif + HDir
               + HDif*radDat.traRefShaDev[1, 1]*radDat.traRef[2, 1, N, HEM]);
            // Interior Shading Device: diffusive radiation from both interior and exterior
          elseif haveInteriorShade then
            absRad[Shade, N + 2] := AWin*uSha_internal*(HDif*radDat.devAbsExtIrrIntShaDev[
              HEM] + HRoo*coeAbsDevIntIrrIntSha);
          end if;

          //**************************************************************
          // Glass, Device: add absorbed direct radiation from exterior sources
          //**************************************************************
          // Use min() instead of if() to avoid event
          incAng2 := min(incAng, 0.5*Modelica.Constants.pi);

          x := 2*(NDIR - 1)*abs(incAng2)/Modelica.Constants.pi
            "x=(index-1)*incAng/(0.5pi), 0<=x<=NDIR";
          x := x + 2;

          for i in 1:N loop
            // Glass without shading: Add absorbed direct radiation
            tmpNoSha :=
              Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation({
              coeAbsEx[NoShade, i, k] for k in 1:(HEM + 2)}, x);
            absRad[NoShade, i + 1] := absRad[NoShade, i + 1] + AWin*HDir*(1 -
              uSha_internal)*tmpNoSha;

            // Glass with shading: add absorbed direct radiation
            tmpSha :=
              Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation({
              coeAbsEx[Shade, i, k] for k in 1:(HEM + 2)}, x);
            absRad[Shade, i + 1] := absRad[Shade, i + 1] + AWin*HDir*uSha_internal*
              tmpSha;
          end for;

          // Interior shading device: add absorbed direct radiation
          if haveInteriorShade then
            tmpSha :=
              Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation({
              coeAbsDevExtIrrIntSha[k] for k in 1:(HEM + 2)}, x);
            absRad[Shade, N + 2] := absRad[Shade, N + 2] + AWin*HDir*uSha_internal*
              tmpSha;
          end if;

          // Exterior shading device: add absorbed reflection of direct radiation from exterior source
          if haveExteriorShade then
            tmpNoSha :=
              Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation({
              coeRefExtPan1[k] for k in 1:(HEM + 2)}, x);
            absRad[Shade, 1] := absRad[Shade, 1] + AWin*HDir*uSha_internal*
              coeAbsDevExtIrrExtSha*tmpNoSha;
          end if;

          // Assign quantities to output connectors
          QAbsExtSha_flow := absRad[2, 1];
          QAbsIntSha_flow := absRad[2, N + 2];
          QAbsGlaUns_flow[:] := absRad[1, 2:N + 1];
          QAbsGlaSha_flow[:] := absRad[2, 2:N + 1];
          annotation (
            Documentation(info="<html>
<p>
The model calculates absorbed solar radiation on the window.
The calculations follow the description in Wetter (2004), Appendix A.4.3.
</p>
<p>
The absorbed radiation by exterior shades includes:
</p>
<ol>
<li>
the directly absorbed exterior radiation: <code>AWin*uSha*(HDir+HDif)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed exterior radiantion from reflection (angular part): <code>AWin*uSha*HDir*tau*rho(IncAng)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed of exterior irradiantion from reflection (diffusive part): <code>AWin*uSha*HDif*tau*rho(HEM)*(1-tau-rho)</code>
</li>
<li>
the absorbed interior radiation is neglected.
</li>
</ol>
<p>
The output is <code>absRad[2, 1]</code>
</p>

<p>
The absorbed radiation by interior shades includes:
</p>
<ol>
<li>
the absorbed exterior radiation (angular part): <code>AWin*uSha*HDir*alpha(IncAng)</code>
</li>
<li>
the absorbed exterior radiation (diffusive part): <code>AWin*uSha*HDif*alpha(HEM)</code>
</li>
<li>
the absorbed interior radiation (diffusive part): <code>AWin*uSha*HRoo*(1-tau-rho)</code>
</li>
</ol>
<p>
The output is <code>absRad[2, N+2]</code>
</p>

<p>
The absorbed radiation by glass includes:
</p>
<ol>
<li>
the absorbed radiation by unshaded part (diffusive part): <code>AWin*(1-uSha)*(HDif*alphaEx(HEM)+HRoo*alphaIn(HEM))</code>
</li>
<li>
the absorbed radiation by unshaded part (angular part from exterior source): <code>AWin*(1-uSha)*HDir*alphaEx(IncAng)</code>
</li>
<li>
the absorbed radiaiton by shaded part (diffusive part): <code>AWin*uSha*(HDif*alphaExSha(HEM)+HRoo*alphaInSha(HEM))</code>
</li>
<li>
the absorbed radiation by shaded part (angular part from exterior source): <code>AWin*uSha*HDir*alphaExSha(IncAng)</code>
</li>
</ol>
<p>
The output is <code>absRad[1, 2:N+1] = Part1 + Part2; absRad[2, 2:N+1] = Part3 + Part4</code>
</p>

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Added missing <code>each</code> keywords in parameter declarations.
</li>
<li>
March 4, 2011, by Wangda Zuo:<br/>
Remove the if-statement and integer function that can trigger events.
</li>
<li>
February 2, 2010, by Michael Wetter:<br/>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
December 15, 2010, by Wangda Zuo:<br/>
Separate transmittance and absorbance.
</li>
<li>
December 12, 2010, by Michael Wetter:<br/>
Replaced record
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
                Text(
                  extent={{26,86},{102,74}},
                  lineColor={0,0,127},
                  textString="QAbsExtSha"),
                Text(
                  extent={{-101,-73},{-54,-82}},
                  lineColor={0,0,127},
                  textString="HRoo"),
                Text(
                  extent={{24,-68},{102,-80}},
                  lineColor={0,0,127},
                  textString="QAbsIntSha"),
                Text(
                  extent={{34,46},{94,32}},
                  lineColor={0,0,127},
                  textString="QAbsGlaUns"),
                Text(
                  extent={{30,-32},{104,-44}},
                  lineColor={0,0,127},
                  textString="QAbsGlaSha")}));
        end AbsorbedRadiation;

        model ExteriorConvectionCoefficient
          "Model for the heat transfer coefficient at the outside of the window"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Area A "Heat transfer area";

          Modelica.Blocks.Interfaces.RealOutput GCon(unit="W/K")
            "Convective thermal conductance"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealInput v(unit="m/s") "Wind speed"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        equation
          GCon = A*(4+4*Buildings.Utilities.Math.Functions.smoothMax(v, -v, 0.1));
          annotation ( Icon(graphics={
                Text(
                  extent={{-92,22},{-50,-22}},
                  lineColor={0,0,127},
                  textString="v"),
                Text(
                  extent={{40,26},{92,-20}},
                  lineColor={0,0,127},
                  textString="GCon")}),
                   Documentation(info="<html>
Model for the convective heat transfer coefficient at the outside of a window.
The computation is according to TARCOG 2006, which specifies the convection
coefficient as
<p align=\"center\" style=\"font-style:italic;\">
  h = 4+4 v
</p>
where <i>v</i> is the wind speed in <i>m/s</i> and
<i>h</i> is the convective heat transfer coefficient in <i>W/(m2*K)</i>.
<br/>
<h4>References</h4>

TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</html>",         revisions="<html>
<ul>
<li>
August 19 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ExteriorConvectionCoefficient;

        model InteriorConvectionCoefficient
          "Model for the heat transfer coefficient at the inside of the window"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Area A "Heat transfer area";

          Modelica.Blocks.Interfaces.RealOutput GCon(unit="W/K")
            "Convective thermal conductance"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          GCon = 4*A;
          annotation ( Icon(graphics={
                Text(
                  extent={{40,26},{92,-20}},
                  lineColor={0,0,127},
                  textString="GCon")}),
                   Documentation(info="<html>
Model for the convective heat transfer coefficient at the room-facing surface of a window.
The computation is according to TARCOG 2006, which specifies the convection
coefficient as
<p align=\"center\" style=\"font-style:italic;\">
  h = 4 W &frasl; (m<sup>2</sup> K).
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</html>",         revisions="<html>
<ul>
<li>
August 19 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end InteriorConvectionCoefficient;

        model CenterOfGlass
          "Model for center of glass of a window construction"
          extends
            Buildings.HeatTransfer.Radiosity.BaseClasses.RadiosityTwoSurfaces;
          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Angle til(displayUnit="deg")
            "Surface tilt (only 90 degrees=vertical is implemented)";

          parameter Buildings.HeatTransfer.Data.GlazingSystems.Generic glaSys
            "Glazing system"
            annotation (HideResult=true, choicesAllMatching=true, Placement(transformation(extent={{60,60},
                    {80,80}})));

          Modelica.Blocks.Interfaces.RealInput u
            "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
                iconTransformation(extent={{-120,70},{-100,90}})));

          Buildings.HeatTransfer.Windows.BaseClasses.GlassLayer[glaSys.nLay] glass(
            each final A=A,
            final x=glaSys.glass.x,
            final k=glaSys.glass.k,
            final absIR_a=glaSys.glass.absIR_a,
            final absIR_b=glaSys.glass.absIR_b,
            final tauIR=glaSys.glass.tauIR,
            each final linearize=linearize) "Window glass layer"
            annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
          Buildings.HeatTransfer.Windows.BaseClasses.GasConvection gas[glaSys.nLay-1](
            each final A=A,
            final gas=glaSys.gas,
            each final til=til,
            each linearize=linearize) "Window gas layer"
            annotation (Placement(transformation(extent={{20,10},{40,30}})));

          // Note that the interior shade is flipped horizontally. Hence, surfaces a and b are exchanged,
          // i.e., surface a faces the room, while surface b faces the window

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glass_a
            "Heat port connected to the outside facing surface of the glass"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glass_b
            "Heat port connected to the room-facing surface of the glass"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));

          parameter Boolean linearize=false
            "Set to true to linearize emissive power";
          Modelica.Blocks.Interfaces.RealInput QAbs_flow[size(glass, 1)](each unit="W", each
              quantity =                                                                              "Power")
            "Solar radiation absorbed by glass" annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-110})));
        equation
          for i in 1:glaSys.nLay-1 loop
            connect(glass[i].port_b, gas[i].port_a)                        annotation (Line(
              points={{5.55112e-16,6.10623e-16},{0,0},{10,0},{10,20},{20,20}},
              color={191,0,0},
              smooth=Smooth.None));
            connect(gas[i].port_b, glass[i+1].port_a)                         annotation (Line(
              points={{40,20},{52,20},{52,36},{-40,36},{-40,0},{-20,0},{-20,6.10623e-16}},
              color={191,0,0},
              smooth=Smooth.None));

            connect(glass[i].JOut_b, glass[i+1].JIn_a)
            annotation (Line(
              points={{1,4},{8,4},{8,-24},{-30,-24},{-30,4},{-21,4}},
              color={0,127,0},
              smooth=Smooth.None));
            connect(glass[i].JIn_b, glass[i+1].JOut_a)
            annotation (Line(
              points={{1,-4},{6,-4},{6,-20},{-28,-20},{-28,-4},{-21,-4}},
              color={0,0,0},
              pattern=LinePattern.None,
              smooth=Smooth.None));

            connect(u, gas[i].u)   annotation (Line(
              points={{-120,80},{-86,80},{-86,44},{-8,44},{-8,28},{19,28}},
              color={0,0,127},
              smooth=Smooth.None));

          end for;

          for i in 1:glaSys.nLay loop
            connect(u, glass[i].u)  annotation (Line(
              points={{-120,80},{-86,80},{-86,44},{-48,44},{-48,8},{-21,8}},
              color={0,0,127},
              smooth=Smooth.None));
          end for;

          connect(glass_b, glass[glaSys.nLay].port_b) annotation (Line(
              points={{100,5.55112e-16},{100,5.55112e-16},{0,0}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(glass_a, glass[1].port_a) annotation (Line(
              points={{-100,5.55112e-16},{-71,5.55112e-16},{-71,6.10623e-16},{-20,
                  6.10623e-16}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(JIn_a, glass[1].JIn_a) annotation (Line(
              points={{-110,40},{-60,40},{-60,4},{-21,4}},
              color={0,0,0},
              pattern=LinePattern.None,
              smooth=Smooth.None));
          connect(glass[1].JOut_a, JOut_a) annotation (Line(
              points={{-21,-4},{-60,-4},{-60,-40},{-110,-40}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(glass[glaSys.nLay].JOut_b, JOut_b) annotation (Line(
              points={{1,4},{80,4},{80,40},{110,40}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(JIn_b, glass[glaSys.nLay].JIn_b) annotation (Line(
              points={{110,-40},{80,-40},{80,-4},{1,-4}},
              color={0,0,0},
              pattern=LinePattern.None,
              smooth=Smooth.None));
          connect(glass.QAbs_flow, QAbs_flow) annotation (Line(
              points={{-10,-11},{-10,-60},{1.11022e-15,-60},{1.11022e-15,-120}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}),       graphics={Text(
                  extent={{-82,100},{-32,86}},
                  lineColor={0,0,255},
                  textString="outside"),
                                       Ellipse(
                  extent={{-108,110},{-88,90}},
                  lineColor={255,255,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Sphere),
                                                 Text(
                  extent={{44,98},{94,84}},
                  lineColor={0,0,255},
                  textString="room-side")}),      Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-90,2},{92,-4}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-56,50},{-44,-52}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-8,50},{4,-52}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{42,50},{54,-52}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),       Text(
                  extent={{-90,86},{-78,74}},
                  lineColor={0,0,127},
                  textString="u")}),
            Documentation(info="<html>
This is a model for the heat transfer through the center of the glass.
The properties of the glazing system is defined by the parameter
<code>glaSys</code>.
The model contains these main component models:
<ul>
<li>
the models <code>extSha</code> and <code>intSha</code>
for the heat balance of the shade, modeled using
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.Shade\">
Buildings.HeatTransfer.Windows.BaseClasses.Shade</a>.
</li>
<li>
an array of models <code>glass</code> for the heat conduction and the
infrared radiative heat balance of the glass layers.
There can be an arbitrary number of glass layers, which are all modeled using
instances of
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.GlassLayer\">
Buildings.HeatTransfer.Windows.BaseClasses.GlassLayer</a>.
</li>
<li>
an array of models <code>gas</code> for the gas layers. There is one model of a
gas layer between each window panes. The gas layers are modeled using instances of
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.GasConvection\">
Buildings.HeatTransfer.Windows.BaseClasses.GasConvection</a>.
</li>
</ul>
Note that this model does <em>not</em> compute heat conduction through the frame and
it does <em>not</em> model the convective heat transfer at the exterior and interior
surface. These models are implemented in
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a>,
<a href=\"modelica://Buildings.HeatTransfer.Windows.ExteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.ExteriorHeatTransfer</a>, and
<a href=\"modelica://Buildings.HeatTransfer.Windows.InteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.InteriorHeatTransfer</a>
</html>",         revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
July 9 2012, by Wangda Zuo:<br/>
Fixed a bug in the parameter assignment of the instance <code>glass</code>.
Previously, the infrared emissivity of surface a was assigned to the surface b.
</li>
<li>
Sep. 3 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end CenterOfGlass;

        model GasConvection
          "Model for heat convection through gas in a window assembly"
          extends Modelica.Thermal.HeatTransfer.Interfaces.Element1D(
             port_a(T(start=293.15)),
             port_b(T(start=293.15)));
          extends Buildings.BaseClasses.BaseIcon;
          parameter Buildings.HeatTransfer.Data.Gases.Generic gas
            "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Area h(min=0) = sqrt(A) "Height of window";

          parameter Modelica.SIunits.Angle til(displayUnit="deg")
            "Surface tilt (only 0, 90 and 180 degrees are implemented)";
          parameter Boolean linearize=false
            "Set to true to linearize emissive power";

          Modelica.Blocks.Interfaces.RealInput u
            "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,50},{-100,90}}),
                iconTransformation(extent={{-120,70},{-100,90}})));

          parameter Modelica.SIunits.Temperature T0 = 293.15
            "Temperature used to compute thermophysical properties";
          Modelica.SIunits.CoefficientOfHeatTransfer hCon(min=0, start=3)
            "Convective heat transfer coefficient";
          Modelica.SIunits.HeatFlux q_flow "Convective heat flux";
          Real Nu(min=0) "Nusselt number";
          Real Ra(min=0) "Rayleigh number";
        protected
          Modelica.SIunits.Temperature T_a
            "Temperature used for thermophysical properties at port_a";
          Modelica.SIunits.Temperature T_b
            "Temperature used for thermophysical properties at port_b";
          Modelica.SIunits.Temperature T_m
            "Temperature used for thermophysical properties";

          Real deltaNu(min=0.01) = 0.1
            "Small value for Nusselt number, used for smoothing";
          Real deltaRa(min=0.01) = 100
            "Small value for Rayleigh number, used for smoothing";
          final parameter Real cosTil=Modelica.Math.cos(til)
            "Cosine of window tilt";
          final parameter Real sinTil=Modelica.Math.sin(til)
            "Sine of window tilt";
          final parameter Boolean isVertical = abs(cosTil) < 10E-10
            "Flag, true if the window is in a wall";
          final parameter Boolean isHorizontal = abs(sinTil) < 10E-10
            "Flag, true if the window is horizontal";
          // Quantities that are only used in linearized model

          parameter Modelica.SIunits.CoefficientOfHeatTransfer hCon0(fixed=false)
            "Convective heat transfer coefficient";
          parameter Real Nu0(fixed=false, min=0) "Nusselt number";
          parameter Real Ra0(fixed=false, min=0) "Rayleigh number";
          parameter Boolean homotopyInitialization = true
            "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
        initial equation
          assert(isVertical or isHorizontal, "Only vertical and horizontal windows are implemented.");

          // Computations that are used in the linearized model only
          Ra0 = Buildings.HeatTransfer.Convection.Functions.HeatFlux.rayleigh(
            x=gas.x,
            rho=Buildings.HeatTransfer.Data.Gases.density(gas=gas, T=T0),
            c_p=Buildings.HeatTransfer.Data.Gases.specificHeatCapacity(gas=gas, T=T0),
            mu=Buildings.HeatTransfer.Data.Gases.dynamicViscosity(gas=gas, T=T0),
            k=Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas=gas, T=T0),
            T_a=T0-5,
            T_b=T0+5,
            Ra_min=100);
          (Nu0, hCon0) = Buildings.HeatTransfer.Windows.BaseClasses.convectionVerticalCavity(
                    gas=gas, Ra=Ra0, T_m=T0, dT=10, h=h, deltaNu=deltaNu, deltaRa=deltaRa);

        equation
          T_a = port_a.T;
          T_b = port_b.T;
          T_m = (port_a.T+port_b.T)/2;
          if linearize then
            Ra=Ra0;
            Nu=Nu0;
            hCon=hCon0;
            q_flow = hCon0 * dT;
          else
            Ra = Buildings.HeatTransfer.Convection.Functions.HeatFlux.rayleigh(
              x=gas.x,
              rho=Buildings.HeatTransfer.Data.Gases.density(gas, T_m),
              c_p=Buildings.HeatTransfer.Data.Gases.specificHeatCapacity(gas, T_m),
              mu=Buildings.HeatTransfer.Data.Gases.dynamicViscosity(gas, T_m),
              k=Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas, T_m),
              T_a=T_a,
              T_b=T_b,
              Ra_min=100);
            if isVertical then
               (Nu, hCon, q_flow) = Buildings.HeatTransfer.Windows.BaseClasses.convectionVerticalCavity(
                      gas=gas, Ra=Ra, T_m=T_m, dT=dT, h=h, deltaNu=deltaNu, deltaRa=deltaRa);
            elseif isHorizontal then
               (Nu, hCon, q_flow) = Buildings.HeatTransfer.Windows.BaseClasses.convectionHorizontalCavity(
                      gas=gas, Ra=Ra, T_m=T_m, dT=dT, til=til, sinTil=sinTil, cosTil=cosTil,
                      h=h, deltaNu=deltaNu, deltaRa=deltaRa);

            else
               Nu = 0;
               hCon=0;
               q_flow=0;
            end if; // isVertical or isHorizontal
          end if; // linearize
          if homotopyInitialization then
            Q_flow = u*A*homotopy(actual=q_flow,
                                  simplified=hCon0*dT);
          else
            Q_flow = u*A*q_flow;
          end if;
          annotation ( Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
               graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,78},{-76,-80}},
                  fillColor={85,170,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-51,42},{-21,20}},
                  lineColor={127,0,0},
                  textString="Q_flow"),
                Line(points={{-68,20},{68,20}}, color={191,0,0}),
                Line(points={{-68,-20},{68,-20}}, color={191,0,0}),
                Line(points={{-56,80},{-56,-80}}, color={0,127,255}),
                Line(points={{-16,80},{-16,-80}},
                                              color={0,127,255}),
                Line(points={{18,80},{18,-80}}, color={0,127,255}),
                Line(points={{54,80},{54,-80}}, color={0,127,255}),
                Line(points={{-56,-80},{-66,-60}}, color={0,127,255}),
                Line(points={{-56,-80},{-46,-60}}, color={0,127,255}),
                Line(points={{-16,-80},{-26,-60}},
                                                color={0,127,255}),
                Line(points={{-16,-80},{-6,-60}},
                                                color={0,127,255}),
                Line(points={{18,-80},{8,-60}},  color={0,127,255}),
                Line(points={{18,-80},{28,-60}}, color={0,127,255}),
                Line(points={{54,-80},{44,-60}}, color={0,127,255}),
                Line(points={{54,-80},{64,-60}}, color={0,127,255}),
                Line(points={{48,-30},{68,-20}}, color={191,0,0}),
                Line(points={{48,-10},{68,-20}}, color={191,0,0}),
                Line(points={{48,10},{68,20}}, color={191,0,0}),
                Line(points={{48,30},{68,20}}, color={191,0,0}),
                Rectangle(
                  extent={{76,80},{90,-78}},
                  fillColor={85,170,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{-100,86},{-86,76}},
                  lineColor={0,0,127},
                  textString="u")}),
            Documentation(info="<html>
Model for convective heat tranfer in a single layer of window gas.
Currently, the model only implements equations for vertical windows
and for horizontal windows.
The computation is according to TARCOG 2006,
except that this implementation computes the convection coefficient
as a function that is differentiable in the temperatures.
<p>
To use this model, set the parameter <code>til</code>
to a value defined in
<a href=\"modelica://Buildings.HeatTransfer.Types.Tilt\">
Buildings.HeatTransfer.Types.Tilt</a>.
</p>
<br/>

<p>
If the parameter <code>linearize</code> is set to <code>true</code>,
then all equations are linearized.
</p>
<h4>References</h4>

TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</html>",         revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Removed duplicate <code>initial equation</code> section.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 18 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end GasConvection;

        model GlassLayer "Model for a glass layer of a window assembly"
          extends
            Buildings.HeatTransfer.Radiosity.BaseClasses.RadiosityTwoSurfaces;
          extends
            Buildings.HeatTransfer.Radiosity.BaseClasses.ParametersTwoSurfaces(
            final rhoIR_a=1-absIR_a-tauIR,
            final rhoIR_b=1-absIR_b-tauIR);
          parameter Modelica.SIunits.Length x "Material thickness";
          parameter Modelica.SIunits.ThermalConductivity k
            "Thermal conductivity";
          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Emissivity absIR_a
            "Infrared absorptivity of surface a (usually room-facing surface)";
          parameter Modelica.SIunits.Emissivity absIR_b
            "Infrared absorptivity of surface b (usually outside-facing surface)";
          parameter Modelica.SIunits.TransmissionCoefficient tauIR
            "Infrared transmittance of glass";

          Modelica.Blocks.Interfaces.RealInput u
            "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,50},{-100,90}}),
                iconTransformation(extent={{-120,70},{-100,90}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a(T(start=293.15))
            "Heat port at surface a"
            annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b(T(start=293.15))
            "Heat port at surface b"
            annotation (Placement(transformation(extent={{90,-10},{
                    110,10}})));
          Modelica.Blocks.Interfaces.RealInput QAbs_flow(unit="W", quantity="Power")
            "Solar radiation absorbed by glass" annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}),iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-110})));
          parameter Boolean linearize=false
            "Set to true to linearize emissive power";
          parameter Boolean homotopyInitialization = true
            "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
        protected
         Real T4_a(min=1E8, unit="K4", start=293.15^4, nominal=1E10)
            "4th power of temperature at surface a";
         Real T4_b(min=1E8, unit="K4", start=293.15^4, nominal=1E10)
            "4th power of temperature at surface b";
         Modelica.SIunits.HeatFlowRate E_a(min=0, nominal=1E2)
            "Emissive power of surface a";
         Modelica.SIunits.HeatFlowRate E_b(min=0, nominal=1E2)
            "Emissive power of surface b";
         final parameter Modelica.SIunits.ThermalResistance R = x/2/k/A
            "Thermal resistance from surface of glass to center of glass";
        equation
          // Heat balance of surface node
          // These equations are from Window 6 Technical report, (2.1-14) to (2.1-17)
          0 = port_a.Q_flow + port_b.Q_flow + QAbs_flow + JIn_a  + JIn_b - JOut_a - JOut_b;
          u * (port_b.T-port_a.T) = 2*R * (-port_a.Q_flow-QAbs_flow/2-JIn_a+JOut_a);
          // Radiosity balance
          if linearize then
            T4_a = 4*T03*port_a.T - 3*T04;
            T4_b = 4*T03*port_b.T - 3*T04;
          else
            if homotopyInitialization then
              T4_a = homotopy(actual=port_a.T^4, simplified=4*T03*port_a.T - 3*T04);
              T4_b = homotopy(actual=port_b.T^4, simplified=4*T03*port_b.T - 3*T04);
            else
              T4_a = port_a.T^4;
              T4_b = port_b.T^4;
            end if;
          end if;
          // Emissive power
          E_a = u * A * absIR_a * Modelica.Constants.sigma * T4_a;
          E_b = u * A * absIR_b * Modelica.Constants.sigma * T4_b;
          // Radiosities that are outgoing from the surface, which are
          // equal to the infrared absorptivity plus the reflected incoming
          // radiosity plus the radiosity that is transmitted from the
          // other surface.
          JOut_a = E_a + rhoIR_a * JIn_a + tauIR * JIn_b;
          JOut_b = E_b + rhoIR_b * JIn_b + tauIR * JIn_a;
          annotation (    Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,2},{92,-4}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-4,2},{4,-100}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{8,-70},{60,-98}},
                  lineColor={0,0,127},
                  textString="QAbs"),
                Text(
                  extent={{-96,88},{-64,70}},
                  lineColor={0,0,127},
                  textString="u")}),
            Documentation(info="<html>
Model of a single layer of window glass. The input port <code>QAbs_flow</code>
needs to be connected to the solar radiation that is absorbed
by the glass pane.
The model computes the heat conduction between the two glass surfaces.
The heat flow <code>QAbs_flow</code> is added at the center of the glass.
The model also computes the infrared radiative heat balance using an instance
of the model
<a href=\"Buildings.HeatTransfer.Radiosity.WindowPane\">
Buildings.HeatTransfer.Radiosity.WindowPane</a>.
<br/>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Removed nominal value for heat ports as the default is already
<i>300</i> Kelvin.
</li>
<li>
October 15, 2014, by Michael Wetter:<br/>
Changed type of <code>tauIR</code> from
<code>Modelica.SIunits.Emissivity</code> to
<code>Modelica.SIunits.TransmissionCoefficient</code>.
This avoids a type error in OpenModelica.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
March 20, 2012 by Wangda Zuo:<br/>
Fixed bug for heat flow reported by Pierre Tittelein and fixed bug for temperature linearization.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 18 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end GlassLayer;

        block Overhang
          "For a window with an overhang, outputs the fraction of the area that is sun exposed"
          extends Modelica.Blocks.Icons.Block;
          extends Buildings.Rooms.BaseClasses.Overhang;

          Modelica.Blocks.Interfaces.RealInput verAzi(quantity="Angle", unit="rad", displayUnit="deg")
            "Wall solar azimuth angle (angle between projection of sun's rays and normal to vertical surface)"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));

           Modelica.Blocks.Interfaces.RealInput alt(
             quantity="Angle",
             unit="rad",
             displayUnit="deg") "Altitude angle"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

          Modelica.Blocks.Interfaces.RealOutput fraSun(final min=0,
                                                       final max=1,
                                                       final unit="1")
            "Fraction of window area exposed to the sun"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          parameter Modelica.SIunits.Angle lat "Latitude";

          parameter Modelica.SIunits.Angle azi(displayUnit="deg")
            "Surface azimuth; azi= -90 degree East; azi= 0 degree South";

        // Window dimensions
          parameter Modelica.SIunits.Length hWin "Window height"
            annotation(Dialog(tab="General",group="Window"));
          parameter Modelica.SIunits.Length wWin "Window width"
            annotation(Dialog(tab="General",group="Window"));

          Buildings.BoundaryConditions.WeatherData.Bus weaBus
           annotation (Placement(transformation(extent={{-112,-10},{-92,10}})));

        protected
          constant Modelica.SIunits.Angle delSolAzi = 0.005
            "Half-width of transition interval between left and right formulation for overhang";

          final parameter Modelica.SIunits.Area AWin= hWin*wWin "Window area";
          parameter Modelica.SIunits.Length tmpH[4](each fixed=false)
            "Height rectangular sections used for superposition";
          Modelica.SIunits.Length w
            "Either wL or wR, depending on the sun relative to the wall azimuth";
          Modelica.SIunits.Length tmpW[4]
            "Width of rectangular sections used for superpositions";
          Modelica.SIunits.Length del_L = wWin/100
            "Fraction of window dimension over which min-max functions are smoothened";
          Modelica.SIunits.Length x1
            "Horizontal distance between window side edge and shadow corner";
          Modelica.SIunits.Length x2[4]
            "Horizontal distance between window side edge and point where shadow line and window lower edge intersects";
          Modelica.SIunits.Length y1
            "Vertical distance between overhang and shadow lower edge";
          Modelica.SIunits.Length y2[4]
            "Window height (vertical distance corresponding to x2)";
          Real shdwTrnglRtio "Ratio of y1 and x1";
          Modelica.SIunits.Area area[4]
            "Shaded areas of the sections used in superposition";
          Modelica.SIunits.Area shdArea "Shaded area calculated from equations";
          Modelica.SIunits.Area crShdArea "Final value for shaded area";
          Modelica.SIunits.Area crShdArea1
            "Corrected for the sun behind the surface/wall";
          Modelica.SIunits.Area crShdArea2
            "Corrected for the sun below horizon";

          Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth solAzi(lat=lat)
            "Solar azimuth"
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));

        initial algorithm
          assert(wL >= 0,  "Overhang must cover complete window
    Received overhang width on left hand side, wL = "         + String(wL));
          assert(wR >= 0,  "Overhang must cover complete window
    Received overhang width on right hand side, wR = "         + String(wR));

          for i in 1:4 loop
            tmpH[i] := gap + mod((i - 1), 2)*hWin;
          end for;

        equation
          // if dep=0, then the equation
          //   y1*Modelica.Math.cos(verAzi) = dep*Modelica.Math.tan(alt);
          // is singular. Hence, we treat this special case with an
          // if-then construct.
          // This also increases computing efficiency in
          // Buildings.HeatTransfer.Windows.FixedShade in case the window has no overhang.

          if haveOverhang then
            //Temporary height and widths are for the areas below the overhang
            //These areas are used in superposition
            w = Buildings.Utilities.Math.Functions.spliceFunction(
                    pos=wL,
                    neg=wR,
                    x=solAzi.solAzi-azi,
                    deltax=delSolAzi);
            tmpW[1] = w + wWin;
            tmpW[2] = w;
            tmpW[3] = w;
            tmpW[4] = w + wWin;
            y1*Modelica.Math.cos(verAzi) = dep*Modelica.Math.tan(alt);
            x1 = dep*Modelica.Math.tan(verAzi);
            shdwTrnglRtio*x1 = y1;
            for i in 1:4 loop
              y2[i] = tmpH[i];
              // For the equation below, Dymola generated the following code in MixedAirFreeResponse.
              // This led to a division by zero as y1 crosses zero. The problem occured in an
              // FMU simulation. Therefore, we guard against division by zero when computing
              // x2[i].
              //  roo.bouConExtWin.sha[1].ove.x2[1] := roo.bouConExtWin.sha[1].ove.x1*
              //  roo.bouConExtWin.sha[1].ove.tmpH[1]/roo.bouConExtWin.sha[1].ove.y1;
              // x2[i]*y1 = x1*tmpH[i];

              x2[i] = x1*tmpH[i]/Buildings.Utilities.Math.Functions.smoothMax(
                x1=y1, x2=1E-8*hWin, deltaX=1E-9*hWin);
              area[i] = Buildings.Utilities.Math.Functions.smoothMin(
                x1=y1,
                x2=y2[i],
                  deltaX=del_L)*tmpW[i] - (Buildings.Utilities.Math.Functions.smoothMin(
                y1,
                tmpH[i],
                del_L)*Buildings.Utilities.Math.Functions.smoothMin(
                x1=x2[i],
                x2=y1,
                deltaX=del_L)/2) + Buildings.Utilities.Math.Functions.smoothMax(
                x1=shdwTrnglRtio*(Buildings.Utilities.Math.Functions.smoothMin(
                  x1=x1,
                  x2=x2[i],
                  deltaX=del_L) - tmpW[i]),
                x2=0,
                deltaX=del_L)*Buildings.Utilities.Math.Functions.smoothMax(
                x1=(Buildings.Utilities.Math.Functions.smoothMin(
                  x1=x1,
                  x2=x2[i],
                  deltaX=del_L) - tmpW[i]),
                x2=0,
                deltaX=del_L)/2;
            end for;
            shdArea = area[4] + area[3] - area[2] - area[1];
          // correction case: Sun not in front of the wall
            crShdArea1 = Buildings.Utilities.Math.Functions.spliceFunction(
              pos=shdArea,
              neg=AWin,
              x=(Modelica.Constants.pi/2)-verAzi,
              deltax=0.01);
          // correction case: Sun not above horizon
            crShdArea2 = Buildings.Utilities.Math.Functions.spliceFunction(
              pos=shdArea,
              neg=AWin,
              x=alt,
              deltax=0.01);
            crShdArea=Buildings.Utilities.Math.Functions.smoothMax(x1=crShdArea1,
                                                                   x2=crShdArea2,
                                                                   deltaX=0.01);
            fraSun = Buildings.Utilities.Math.Functions.smoothMin(
                x1=Buildings.Utilities.Math.Functions.smoothMax(x1=1-crShdArea/AWin,x2=0,deltaX=0.01),
                x2=1.0,
                deltaX=0.01);
          else
            w = 0;
            tmpW=fill(0.0, 4);
            y1 = 0;
            x1 = 0;
            shdwTrnglRtio = 0;
            for i in 1:4 loop
              y2[i] = 0;
              x2[i] = 0;
              area[i] = 0;
            end for;
            shdArea = 0;
            crShdArea1 = 0;
            crShdArea2 = 0;
            crShdArea  = 0;
            fraSun     = 0;
           end if;

          connect(weaBus.solTim, solAzi.solTim) annotation (Line(
              points={{-102,5.55112e-16},{-88,5.55112e-16},{-88,-6},{-62,-6}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.solZen, solAzi.zen) annotation (Line(
              points={{-102,5.55112e-16},{-79,5.55112e-16},{-79,6},{-62,6}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.solDec, solAzi.decAng) annotation (Line(
              points={{-102,5.55112e-16},{-92,5.55112e-16},{-92,1.22125e-15},{-82,
                  1.22125e-15},{-82,6.66134e-16},{-62,6.66134e-16}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));

          annotation ( Icon(graphics={Bitmap(extent={{-92,92},{92,-92}},
        fileName="modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/Overhang.png")}),
        defaultComponentName="overhang",
        Documentation(info="<html>
<p>
For a window with an overhang, this block outputs the fraction of
the area that is exposed to the sun.
This models can also be used for doors with an overhang.
</p>
<p>
Input to this block are the
wall solar azimuth angle and the altitude angle of the sun.
These angles can be calculated using blocks from the package
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses</a>.
</p>
<p>
The overhang can be asymmetrical (i.e. <code>wR &ne; wL</code>)
about the vertical centerline
of the window.
The overhang must completely cover the window (i.e.,
<code>wL &ge; 0</code> and
<code>wR &ge; 0</code>).
<code>wL</code> and <code>wR</code> are measured from the left and right edge of the window.
</p>
<p>
The surface azimuth <code>azi</code> is as defined in
<a href=\"modelica://Buildings.HeatTransfer.Types.Azimuth\">
Buildings.HeatTransfer.Types.Azimuth</a>.
</p>
<h4>Implementation</h4>
<p>
The method of super position is used to calculate the window shaded area.
The area below the overhang is divided as shown in the figure.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/OverhangSuperPosition.png\" />
</p>
<p>
Dimensional variables used in code for the rectangle <i>DEGI, AEGH, CFGI</i> and <i>BFGH</i>
are shown in the figure below:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/OverhangVariables.png\" />
</p>
<p>
The rectangles <i>DEGI, AEGH, CFGI</i> and <i>BFGH</i> have the same geometric configuration
with respect to the overhang.
Thus, the same algorithm can be used to calculate the shaded portion in these areas.
A single equation in the <code>for</code> loop improves the total calculation time,
as compared to <code>if-then-else</code>
conditions, considering the various shapes of the shaded portions.
To find the shaded area in window <i>ABCD</i>, the shaded portion of <i>AEGD</i> and <i>CFGI</i>
should be subtracted from that of <i>DEGI</i> and <i>BFGH</i>.
This shaded area of the window is then divided by the total window area
to calculate the shaded fraction of the window.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 28, 2014, by Michael Wetter:<br/>
Reformulated <code>shdwTrnglRtio*x1 = y1</code> to avoid a division by
zero if the model is exported as an FMU.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/234\">#234</a>.
</li>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed definitions of <code>wL</code> and <code>wR</code> to be
measured from the corner of the window instead of the centerline.
This allows changing the window width without having to adjust the
overhang parameters.
</li>
<li>
July 5, 2012, by Michael Wetter:<br/>
Revised implementation to avoid state events when horizontal projection
of the sun beam is perpendicular to window.
</li>
<li>
May 7, 2012, by Kaustubh Phalak:<br/>
Modified for use of asymmetrical overhang.
</li>
<li>
Feb 23, 2012, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Overhang;

        model ShadeConvection
          "Model for convective heat balance of a layer that may or may not have a shade"

          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Boolean thisSideHasShade
            "Set to true if this side of the window has a shade";

          parameter Real k(min=0, max=1)=1
            "Coefficient used to scale convection between shade and glass";

          Modelica.Blocks.Interfaces.RealInput Gc(unit="W/K")
            "Signal representing the convective thermal conductance"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                origin={-120,30}), iconTransformation(extent={{-10,-10},{10,10}},
                  origin={-110,40})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a air
            "Port that connects to the air (room or outside)"        annotation (Placement(transformation(extent={{-110,
                    -10},{-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glass
            "Heat port that connects to shaded part of glass"
            annotation (Placement(transformation(extent={{84,-10},{104,10}}),
                iconTransformation(extent={{84,-10},{104,10}})));
         Modelica.Blocks.Interfaces.RealInput QRadAbs_flow(unit="W")
            "Total net radiation that is absorbed by the shade (positive if absorbed)"
             annotation (Placement(transformation(extent={{10,-10},{-10,10}},
                               rotation=270,
                origin={-60,-110}),         iconTransformation(extent={{10,-10},{-10,10}},
                rotation=270,
                origin={-60,-110})));

          Modelica.Blocks.Interfaces.RealOutput TSha(quantity="ThermodynamicTemperature",
              unit="K") "Shade temperature"
            annotation (Placement(transformation(
                origin={58,-120},
                extent={{20,-20},{-20,20}},
                rotation=90), iconTransformation(
                extent={{10,-10},{-10,10}},
                rotation=90,
                origin={60,-110})));
        equation
          if thisSideHasShade then
            // Convective heat balance of shade.
            // The term 2*Gc is to combine the parallel convective heat transfer resistances,
            // see figure in info section.
         //   2*(air.T-TSha) = k*(glass.T-TSha);
            // Convective heat flow at air node
            air.Q_flow   = Gc*(2*(air.T-TSha) + (air.T-glass.T));
            // Convective heat flow at glass node
            glass.Q_flow = Gc*((glass.T-air.T)+k*(glass.T-TSha));
            air.Q_flow + glass.Q_flow + QRadAbs_flow = 0;
          else
            air.Q_flow   = Gc*(air.T-glass.T);
            air.Q_flow + glass.Q_flow = 0;
            TSha = (air.T+glass.T)/2;
          end if;

          annotation (    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                 graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                                                Text(
                extent={{-100,132},{100,102}},
                textString="%name",
                lineColor={0,0,255}),
                Polygon(
                  points={{-20,54},{-20,46},{20,58},{20,66},{-20,54}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,14},{-20,6},{20,18},{20,26},{-20,14}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,34},{-20,26},{20,38},{20,46},{-20,34}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-26},{-20,-34},{20,-22},{20,-14},{-20,-26}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-6},{-20,-14},{20,-2},{20,6},{-20,-6}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-66},{-20,-74},{20,-62},{20,-54},{-20,-66}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-46},{-20,-54},{20,-42},{20,-34},{-20,-46}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-2,90},{2,-80}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-40,94},{40,80}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-100,52},{-66,34}},
                  lineColor={0,0,127},
                  textString="Gc"),
                Rectangle(
                  extent={{88,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-68,-80},{-34,-98}},
                  lineColor={0,0,127},
                  textString="QAbsNet"),
                Text(
                  extent={{42,-82},{76,-100}},
                  lineColor={0,0,127},
                  textString="T")}),
            Documentation(info="<html>
<p>
Model for the convective heat balance
of a shade that is in the outside or the room-side of a window.
</p>
<p>
The convective heat balance is based on the model described by Wright (2008), which can
be shown as a convective heat resistance model as follows:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/convection.png\" border=\"1\"/>
</p>
<p>
Wright (2008) reports that if the shading layer is far enough from the window,
the boundary layers associated with each surface will not interfere with
each other. In this case, it is reasonable to consider each surface on an
individual basis by setting the convective heat transfer coefficient shown in grey to zero,
and setting the black depicted convective heat transfer coefficients
to <i>h=4 W/m<sup>2</sup> K</i>.
In the here implemented model, the grey depicted convective heat transfer coefficient
is set set to <i>h' = k &nbsp; h</i>, where <i>0 &le; k &le; 1</i> is a parameter.
</p>
<h4>References</h4>
<ul>
<li>
Jon L. Wright.<br/>
Calculating Center-Glass Performance Indices
of Glazing Systems with Shading Devices.<br/>
<i>ASHRAE Transactions</i>, SL-08-020. 2008.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
June 11, 2013, by Michael Wetter:<br/>
Redesigned model to separate convection from radiation, which is
required for the implementation of a CFD model.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
February 3, by Michael Wetter:<br/>
Corrected bug in start value of radiosity port and in heat balance of shade.
</li>
<li>
January 28 2011, by Michael Wetter:<br/>
Fixed computation of convective heat balance between air, shade and glass.
</li>
<li>
November 3 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ShadeConvection;

        model ShadeRadiation
          "Model for infrared radiative heat balance of a layer that may or may not have a shade"

          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Emissivity absIR_air
            "Infrared absorptivity of surface that faces air";
          parameter Modelica.SIunits.Emissivity absIR_glass
            "Infrared absorptivity of surface that faces glass";
          parameter Modelica.SIunits.TransmissionCoefficient tauIR_air
            "Infrared transmissivity of shade for radiation coming from the exterior or the room";
          parameter Modelica.SIunits.TransmissionCoefficient tauIR_glass
            "Infrared transmissivity of shade for radiation coming from the glass";
          parameter Boolean thisSideHasShade
            "Set to true if this side of the window has a shade";
          final parameter Modelica.SIunits.ReflectionCoefficient rhoIR_air=1-absIR_air-tauIR_air
            "Infrared reflectivity of surface that faces air";
          final parameter Modelica.SIunits.ReflectionCoefficient rhoIR_glass=1-absIR_glass-tauIR_glass
            "Infrared reflectivity of surface that faces glass";
          parameter Boolean linearize = false
            "Set to true to linearize emissive power"
          annotation (Evaluate=true);
          parameter Boolean homotopyInitialization = true
            "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));

          parameter Modelica.SIunits.Temperature T0=293.15
            "Temperature used to linearize radiative heat transfer"
            annotation (Dialog(enable=linearize));

          Modelica.Blocks.Interfaces.RealInput u
            "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
                iconTransformation(extent={{-120,70},{-100,90}})));

          Modelica.Blocks.Interfaces.RealInput QSolAbs_flow(unit="W", quantity="Power")
            "Solar radiation absorbed by shade"
            annotation (Placement(transformation(
                origin={0,-120},
                extent={{-20,-20},{20,20}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-110})));

          Interfaces.RadiosityInflow JIn_air(start=A*0.8*Modelica.Constants.sigma*293.15^4)
            "Incoming radiosity at the air-side surface of the shade"
            annotation (Placement(transformation(extent={{-120,-50},{-100,-30}})));
          Interfaces.RadiosityInflow JIn_glass(start=A*0.8*Modelica.Constants.sigma*293.15^4)
            "Incoming radiosity at the glass-side surface of the shade"
            annotation (Placement(transformation(extent={{120,-90},{100,-70}})));
          Interfaces.RadiosityOutflow JOut_air
            "Outgoing radiosity at the air-side surface of the shade"
            annotation (Placement(transformation(extent={{-100,-90},{-120,-70}})));
          Interfaces.RadiosityOutflow JOut_glass
            "Outgoing radiosity at the glass-side surface of the shade"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));

         Modelica.Blocks.Interfaces.RealOutput QRadAbs_flow(unit="W")
            "Total net radiation that is absorbed by the shade (positive if absorbed)"
             annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                               rotation=270,
                origin={-50,-110}),         iconTransformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-50,-110})));

          Modelica.Blocks.Interfaces.RealInput TSha(quantity="ThermodynamicTemperature",
              unit="K",
              start=293.15) if
                 thisSideHasShade "Shade temperature"
            annotation (Placement(transformation(
                origin={60,-120},
                extent={{-20,-20},{20,20}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,-110})));

        protected
           Modelica.Blocks.Interfaces.RealInput TSha_internal(quantity="ThermodynamicTemperature",
              unit="K",
              start=293.15) "Internal connector for shade temperature";

         final parameter Real T03(min=0, final unit="K3")=T0^3
            "3rd power of temperature T0";
         Real T4(min=1E8, start=293.15^4, nominal=1E10, final unit="K4")
            "4th power of temperature";
         Modelica.SIunits.RadiantPower E_air
            "Emissive power of surface that faces air";
         Modelica.SIunits.RadiantPower E_glass
            "Emissive power of surface that faces glass";
        equation
          connect(TSha_internal, TSha);
          if thisSideHasShade then
          // Radiosities that are outgoing from the surface, which are
          // equal to the infrared absorptivity plus the reflected incoming
          // radiosity plus the radiosity that is transmitted from the
          // other surface.
            if linearize then
              T4 = T03 * TSha_internal;
            else
              if homotopyInitialization then
                T4 = homotopy(actual=(TSha_internal)^4, simplified=T03 * TSha_internal);
              else
                T4 = TSha_internal^4;
              end if;
            end if;

            E_air   = u * A * absIR_air   * Modelica.Constants.sigma * T4;
            E_glass = u * A * absIR_glass * Modelica.Constants.sigma * T4;
            // Radiosity outgoing from shade towards air side and glass side
            JOut_air   = E_air   + tauIR_glass * JIn_glass + rhoIR_air*JIn_air;
            JOut_glass = E_glass + tauIR_air   * JIn_air   + rhoIR_glass*JIn_glass;
            // Radiative heat balance of shade.
            QSolAbs_flow + absIR_air*JIn_air + absIR_glass*JIn_glass
              = E_air+E_glass+QRadAbs_flow;
          else
            QRadAbs_flow = 0;
            T4 = T03 * T0;
            E_air = 0;
            E_glass = 0;
            JOut_air = JIn_glass;
            JOut_glass = JIn_air;
            TSha_internal = T0;
          end if;

          annotation (    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                 graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                                                Text(
                extent={{-100,132},{100,102}},
                textString="%name",
                lineColor={0,0,255}),
                Polygon(
                  points={{-20,54},{-20,46},{20,58},{20,66},{-20,54}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,14},{-20,6},{20,18},{20,26},{-20,14}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,34},{-20,26},{20,38},{20,46},{-20,34}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-26},{-20,-34},{20,-22},{20,-14},{-20,-26}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-6},{-20,-14},{20,-2},{20,6},{-20,-6}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-66},{-20,-74},{20,-62},{20,-54},{-20,-66}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-46},{-20,-54},{20,-42},{20,-34},{-20,-46}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-18,-82},{16,-100}},
                  lineColor={0,0,127},
                  textString="QAbs"),
                Rectangle(
                  extent={{-2,90},{2,-80}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-40,94},{40,80}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-102,90},{-68,72}},
                  lineColor={0,0,127},
                  textString="u"),
                Rectangle(
                  extent={{88,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{42,-82},{76,-100}},
                  lineColor={0,0,127},
                  textString="T"),
                Text(
                  extent={{-68,-80},{-34,-98}},
                  lineColor={0,0,127},
                  textString="QAbsNet")}),
            Documentation(info="<html>
<p>
Model for the infrared radiative heat balance
of a shade that is at the outside or the room-side of a window.
The model also includes the absorbed solar radiation.
</p>
<p>
The input port <code>QAbs_flow</code> needs to be connected to the solar radiation
that is absorbed by the shade.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
June 11, 2013, by Michael Wetter:<br/>
Redesigned model to separate convection from radiation, which is
required for the implementation of a CFD model.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
February 3, by Michael Wetter:<br/>
Corrected bug in start value of radiosity port and in heat balance of shade.
</li>
<li>
January 28 2011, by Michael Wetter:<br/>
Fixed computation of convective heat balance between air, shade and glass.
</li>
<li>
November 3 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ShadeRadiation;

        partial model ShadeInterface_weatherBus
          "Base class for models of window shade and overhangs"
          extends Modelica.Blocks.Icons.Block;

          Buildings.BoundaryConditions.WeatherData.Bus weaBus
            "Weather data bus"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

          Modelica.Blocks.Interfaces.RealInput incAng(quantity="Angle",
                                                      unit="rad",
                                                      displayUnit="rad")
            "Solar incidence angle"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

          Modelica.Blocks.Interfaces.RealInput HDirTilUns(
                                 quantity="RadiantEnergyFluenceRate",
                                 unit="W/m2")
            "Direct solar irradiation on tilted, unshaded surface"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));

          Modelica.Blocks.Interfaces.RealOutput HDirTil(
                                 quantity="RadiantEnergyFluenceRate",
                                 unit="W/m2")
            "Direct solar irradiation on tilted, shaded surface"
            annotation (Placement(transformation(extent={{100,50},{120,70}})));
          Modelica.Blocks.Interfaces.RealOutput fraSun(final min=0,
                                                       final max=1,
                                                       final unit="1")
            "Fraction of the area that is unshaded"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          annotation (Documentation(info="<html>
<p>
Partial model to implement overhang and side fin model with weather bus as a connector.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ShadeInterface_weatherBus;

        block ShadingSignal
          "Converts the shading signal to be strictly bigger than 0 and smaller than 1"
          extends Modelica.Blocks.Interfaces.SO;
          parameter Boolean haveShade "Set to true if a shade is present"
            annotation (Evaluate=true);
          Modelica.Blocks.Interfaces.RealInput u if haveShade
            "Shading control signal, 0: unshaded; 1: fully shaded"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}}), iconTransformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput yCom "1-u"
            annotation (Placement(transformation(extent={{100,-70},{120,-50}}), iconTransformation(extent={{100,-70},{120,-50}})));
        protected
          constant Real y0 = 1E-6
            "Smallest allowed value for y if a shade is present";
          constant Real k = 1-2*y0 "Gain for shading signal";
          Modelica.Blocks.Interfaces.RealInput u_in_internal
            "Needed to connect to conditional connector";
        equation
          connect(u, u_in_internal);
          if not haveShade then
            u_in_internal = 0;
          end if;
          if haveShade then
            y = y0 + k *  u_in_internal;
            yCom = 1-y;
          else
            y = 0;
            yCom = 1;
          end if;
          annotation ( Icon(graphics={
                Text(
                  extent={{-92,22},{-50,-22}},
                  lineColor={0,0,127},
                  textString="u"),
                Text(
                  extent={{48,22},{90,-22}},
                  lineColor={0,0,127},
                  textString="u'"),
                Text(
                  extent={{-14,-40},{92,-80}},
                  lineColor={0,0,127},
                  textString="1-u'")}),
                   Documentation(info="<html>
This model changes the shading control signal to avoid a singularity
in the window model if the input signal is zero or one.
Since the window heat balance multiplies the area of the window by <code>u</code>
or by <code>1-u</code> (if a shade is present), the heat balance can be singular
for <code>u=0</code> or for <code>u=1</code>.
This model avoids this singularity by slightly changing the control signal.
</html>",         revisions="<html>
<ul>
<li>
October 28 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ShadingSignal;

        block SideFins
          "For a window with side fins, outputs the fraction of the area that is sun exposed"
          extends Modelica.Blocks.Icons.Block;
          extends Buildings.Rooms.BaseClasses.SideFins;
          Modelica.Blocks.Interfaces.RealInput alt(quantity="Angle",
                                                   unit="rad",
                                                   displayUnit="deg")
            "Solar altitude angle (angle between sun ray and horizontal surface)"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput verAzi(quantity="Angle",
                                                      unit="rad",
                                                      displayUnit="deg")
            "Angle between projection of sun's rays and normal to vertical surface"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealOutput fraSun(final min=0,
                                                       final max=1,
                                                       final unit="1")
            "Fraction of window area exposed to the sun"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        // Window dimensions
          parameter Modelica.SIunits.Length hWin "Window height"
            annotation(Dialog(tab="General",group="Window"));
          parameter Modelica.SIunits.Length wWin "Window width"
            annotation(Dialog(tab="General",group="Window"));
        // Other calculation variables
        protected
          final parameter Modelica.SIunits.Length tmpH[4]=
                          {h+hWin, h, h+hWin, h}
            "Height of rectangular sections used for superposition";
          final parameter Modelica.SIunits.Length tmpW[4]=
                          {gap + wWin,gap + wWin,gap, gap}
            "Width of rectangular sections used for superpositions; c1,c2 etc";
          final parameter Modelica.SIunits.Length deltaL=wWin/100
            "Fraction of window dimension over which min-max functions are smoothened";
          final parameter Modelica.SIunits.Area AWin=hWin*wWin "Window area";
          Modelica.SIunits.Length x1[4]
            "Horizontal distance between side fin and point where shadow line and window lower edge intersects";
          Modelica.SIunits.Length x2
            "Horizontal distance between side fin and shadow corner";
          Modelica.SIunits.Length x3[4] "Window width";
          Modelica.SIunits.Length y1[4] "Window height";
          Modelica.SIunits.Length y2
            "Vertical distance between window upper edge and shadow corner";
          Modelica.SIunits.Length y3[4]
            "Vertical distance between window upper edge and point where shadow line and window side edge intersects";
          Modelica.SIunits.Area area[4]
            "Shaded areas of the sections used in superposition";
          Modelica.SIunits.Area shdArea "Shaded area";
          Modelica.SIunits.Area crShdArea "Final value of shaded area";
          Modelica.SIunits.Area crShdArea1
            "Shaded area, corrected for the sun behind the surface/wall";
          Modelica.SIunits.Area crShdArea2
            "Shaded area, corrected for the sun below horizon";
          Modelica.SIunits.Length minX[4];
          Modelica.SIunits.Length minY[4];
          Modelica.SIunits.Length minX2X3[4];
          Modelica.SIunits.Length minY2Y3[4];
          Real delta=1e-6 "Small number to avoid division by zero";
          Real tanLambda
            "Tangent of angle between horizontal and sun ray projection on vertical wall";
          Real verAzi_t;
          Real lambda_t;
          Real verAzi_c;
          Real alt_t;
        initial algorithm
          assert(h >= 0, "Sidefin parameter 'h' must be at least zero.
  It is measured from the upper edge of the window to the top of the side fin.
  Received h = "         + String(h));
        equation
          // This if-then construct below increases computing efficiency in
          // Buildings.HeatTransfer.Windows.FixedShade in case the window has no overhang.
          if haveSideFins then
          //avoiding division by zero
            lambda_t = Buildings.Utilities.Math.Functions.smoothMax(
              x1=tanLambda,
              x2=delta,
              deltaX=delta/10);
            verAzi_t = Buildings.Utilities.Math.Functions.smoothMax(
              x1=Modelica.Math.tan(verAzi),
              x2=delta,
              deltaX=delta/10);
            verAzi_c = Buildings.Utilities.Math.Functions.smoothMax(
              x1=Modelica.Math.cos(verAzi),
              x2=delta,
              deltaX=delta/10);
            alt_t = Buildings.Utilities.Math.Functions.smoothMax(
              x1=Modelica.Math.tan(alt),
              x2=delta,
              deltaX=delta/10);
            tanLambda = alt_t / verAzi_t;
            y2 = dep*alt_t/verAzi_c;
            x2 = dep*verAzi_t;
            for i in 1:4 loop
              x1[i] = tmpH[i]/lambda_t;
              x3[i] = tmpW[i];
              y1[i] = tmpH[i];
              y3[i] = tmpW[i]*lambda_t;
              minX2X3[i] = Buildings.Utilities.Math.Functions.smoothMin(
                x1=x2,
                x2=x3[i],
                deltaX=deltaL);
              minX[i] = Buildings.Utilities.Math.Functions.smoothMin(
                x1=x1[i],
                x2=minX2X3[i],
                deltaX=deltaL);
              minY2Y3[i] = Buildings.Utilities.Math.Functions.smoothMin(
                x1=y2,
                x2=y3[i],
                deltaX=deltaL);
              minY[i] = Buildings.Utilities.Math.Functions.smoothMin(
                x1=y1[i],
                x2=minY2Y3[i],
                deltaX=deltaL);
              area[i] = tmpH[i]*minX[i] - minX[i]*minY[i]/2;
            end for;
          //by superposition
            shdArea = area[1] + area[4] - area[2] - area[3];
            // The corrections below ensure that the shaded area is 1 if the
            // sun is below the horizon or behind the wall.
            // This correction is not required (because the direct solar irradiation
            // will be zero in this case), but it leads to more realistic time series
            // of this model.
          //correction case: Sun not in front of the wall
            crShdArea1 = Buildings.Utilities.Math.Functions.spliceFunction(
               pos=shdArea,
               neg=AWin,
               x=(Modelica.Constants.pi/2)-verAzi,
               deltax=0.01);
          //correction case: Sun below horizon
            crShdArea2 = Buildings.Utilities.Math.Functions.spliceFunction(
               pos=shdArea,
               neg=AWin,
               x=alt,
               deltax=0.01);
            crShdArea=Buildings.Utilities.Math.Functions.smoothMax(
               x1=crShdArea1,
               x2=crShdArea2,
               deltaX=0.0001*AWin);
            fraSun = 1-crShdArea/AWin;
          else
            lambda_t = 0;
            verAzi_t = 0;
            verAzi_c = 0;
            alt_t =    0;
            tanLambda = 0;
            y2 = 0;
            x2 = 0;
            x1 = fill(0.0, 4);
            x3 = fill(0.0, 4);
            y1 = fill(0.0, 4);
            y3 = fill(0.0, 4);
            minX2X3 = fill(0.0, 4);
            minX = fill(0.0, 4);
            minY2Y3 = fill(0.0, 4);
            minY = fill(0.0, 4);
            area = fill(0.0, 4);
            shdArea = 0;
            crShdArea1 = 0;
            crShdArea2 = 0;
            crShdArea  = 0;
            fraSun     = 0;
          end if;
          annotation ( Icon(graphics={Bitmap(extent={{-92,92},{92,-92}},
                    fileName="modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/SideFins.png")}),
        defaultComponentName="fin",
        Documentation(info="<html>
<p>
For a window with side fins, this block outputs the fraction of
the area that is exposed to the sun.
This models can also be used for doors with side fins.
</p>
<p>
Input to this block are the
wall solar azimuth angle and the altitude angle of the sun.
These angles can be calculated using blocks from the package
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses</a>.
</p>

<h4>Limitations</h4>
<p>
The model assumes that
</p>
<ul>
<li>
the side fins are placed symmetrically to the left and right of the window,
</li>
<li>
the top of the side fins must be at an equal or greater height than the window, and
</li>
<li>
the bottom of the side fins must be at an equal or lower height than the
bottom of the window.
</li>
</ul>

<h4>Implementation</h4>
<p>
The method of super position is used to calculate the shaded area of the window.
The area besides the side fin is divided as shown in the figure below.
</p>
<p align=\"center\">
<img alt=\"imaghe\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/SideFinsSuperPosition.png\" />
</p>

<p>
Variables used in the code for the rectangle <i>AEGI, BEGH, DFGI</i> and <i>CFGH</i> are shown in figure below.
</p>
<p align=\"center\">
<img alt=\"imaghe\" src=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/SideFinsVariables.png\" />
</p>

<p>
The rectangles <i>AEGI, BEGH, DFGI</i> and <i>CFGH</i>  have the same geometric configuration
with respect to the side fin.
Thus, the same algorithm is used to calculate the shaded portion in these areas.
A single equation in the <code>for</code> loop improves the total calculation time,
as compared to <code>if-then-else</code>
conditions, considering the various shapes of the shaded portions.
To find the shaded area in the window <i>ABCD</i>, the shaded portion of
<i>BEGH</i> and <i>DFGI</i> is subtracted from <i>AEGI</i> and <i>CFGH</i>.
This shaded area of the window is then divided by the total window area
to calculate the shaded fraction of the window.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed definitions of side fin height <code>h</code> to be
measured from the top of the window.
This allows changing the window height without having to adjust the
side fin parameters.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak:<br/>
First implementation.
</li>
</ul>
</html>"));
        end SideFins;

        partial model PartialWindowBoundaryCondition
          "Partial model for heat convection or radiation between a possibly shaded window that can be outside or inside the room"
          parameter Modelica.SIunits.Area A
            "Heat transfer area of frame and window";
          parameter Real fFra
            "Fraction of window frame divided by total window area";
          final parameter Modelica.SIunits.Area AFra = fFra * A "Frame area";
          final parameter Modelica.SIunits.Area AGla = A-AFra "Glass area";

          parameter Boolean haveExteriorShade
            "Set to true if window has exterior shade (at surface a)"
            annotation (Dialog(group="Shading"));
          parameter Boolean haveInteriorShade
            "Set to true if window has interior shade (at surface b)"
            annotation (Dialog(group="Shading"));

          final parameter Boolean haveShade = haveExteriorShade or haveInteriorShade
            "Set to true if window system has a shade"
            annotation (Dialog(group="Shading"), Evaluate=true);
          parameter Boolean thisSideHasShade
            "Set to true if this side of the model has a shade"
            annotation (Dialog(group="Shading"), Evaluate=true);

          Modelica.Blocks.Interfaces.RealInput uSha if haveShade
            "Input connector, used to scale the surface area to take into account an operable shading device, 0: unshaded; 1: fully shaded"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
                iconTransformation(extent={{-116,72},{-100,88}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a air
            "Port that connects to the air (room or outside)"        annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaUns
            "Heat port that connects to unshaded part of glass"
              annotation (Placement(transformation(extent={{90,10},{110,30}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaSha if haveShade
            "Heat port that connects to shaded part of glass"
            annotation (Placement(transformation(extent={{90,-30},{110,-10}})));

          Modelica.Thermal.HeatTransfer.Components.Convection conWinUns
            "Convection from unshaded part of window to outside or room air"
            annotation (Placement(transformation(extent={{60,0},{40,20}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a frame
            "Heat port at window frame"  annotation (Placement(transformation(extent={{60,-110},
                    {80,-90}})));
          Modelica.Thermal.HeatTransfer.Components.Convection conFra
            "Convective heat transfer between air and frame"
            annotation (Placement(transformation(extent={{50,-98},{30,-78}})));

        protected
          Modelica.Blocks.Math.Product proUns
            "Product for unshaded part of window"
            annotation (Placement(transformation(extent={{20,70},{40,90}})));

          Modelica.Blocks.Math.Product proSha if haveShade
            "Product for shaded part of window"
            annotation (Placement(transformation(extent={{-50,20},{-30,40}})));

          ShadingSignal shaSig(final haveShade=haveShade)
            "Conversion for shading signal"
            annotation (Placement(transformation(extent={{-90,70},{-70,90}})));
        initial equation
          assert(( thisSideHasShade and haveShade)  or (not thisSideHasShade),
            "Parameters \"thisSideHasShade\" and \"haveShade\" are not consistent. Check parameters");

        equation
          connect(conWinUns.fluid, air)
                                     annotation (Line(
              points={{40,10},{-80,10},{-80,5.55112e-16},{-100,5.55112e-16}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(conFra.fluid, air) annotation (Line(
              points={{30,-88},{-80,-88},{-80,5.55112e-16},{-100,5.55112e-16}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(conFra.solid, frame) annotation (Line(
              points={{50,-88},{70,-88},{70,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(glaUns, conWinUns.solid) annotation (Line(
              points={{100,20},{76,20},{76,10},{60,10}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(proUns.y, conWinUns.Gc) annotation (Line(
              points={{41,80},{50,80},{50,20}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(uSha, shaSig.u)
                               annotation (Line(
              points={{-120,80},{-92,80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(proSha.u2, shaSig.y) annotation (Line(
              points={{-52,24},{-60,24},{-60,80},{-69,80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(shaSig.yCom, proUns.u1) annotation (Line(
              points={{-69,74},{-50,74},{-50,86},{18,86}},
              color={0,0,127},
              smooth=Smooth.None));

            annotation (Dialog(group="Shading"),
            Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,2},{84,-2}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{-94,88},{-86,74}},
                  lineColor={0,0,127},
                  textString="u"),              Text(
                extent={{-160,144},{140,104}},
                textString="%name",
                lineColor={0,0,255}),
                Polygon(
                  points={{-20,48},{-20,40},{20,52},{20,60},{-20,48}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,8},{-20,0},{20,12},{20,20},{-20,8}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,28},{-20,20},{20,32},{20,40},{-20,28}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-32},{-20,-40},{20,-28},{20,-20},{-20,-32}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-12},{-20,-20},{20,-8},{20,0},{-20,-12}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-72},{-20,-80},{20,-68},{20,-60},{-20,-72}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-52},{-20,-60},{20,-48},{20,-40},{-20,-52}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-2,94},{2,-86}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{56,72},{84,-74}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.Dash),
                Rectangle(
                  extent={{56,-74},{84,-90}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-20,86},{84,72}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Partial model for boundary conditions for convection and radiation for a window surface with or without shade,
that is outside or inside the room.
</p>
<p>
This allows using the model as a base class for windows with inside shade, outside shade, or no shade.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialWindowBoundaryCondition;

        partial block PartialRadiation
          "Partial model for variables and data used in radiation calculation"
          extends Modelica.Blocks.Icons.Block;
          extends Buildings.HeatTransfer.Windows.BaseClasses.RadiationBaseData;

          ////////////////// Parameters that are not used by RadiationData
          parameter Boolean haveExteriorShade
            "Set to true if window has an exterior shade";
          parameter Boolean haveInteriorShade
            "Set to true if window has an interior shade";
          parameter Modelica.SIunits.Area AWin "Area of window";

          ////////////////// Derived parameters
          final parameter Boolean haveShade=haveExteriorShade or haveInteriorShade
            "Set to true if window has a shade" annotation (Evaluate=true);
          final parameter
            Buildings.HeatTransfer.Windows.BaseClasses.RadiationData
            radDat(
            final N=N,
            final tauGlaSol=tauGlaSol,
            final rhoGlaSol_a=rhoGlaSol_a,
            final rhoGlaSol_b=rhoGlaSol_b,
            final xGla=xGla,
            final tauShaSol_a=tauShaSol_a,
            final tauShaSol_b=tauShaSol_b,
            final rhoShaSol_a=rhoShaSol_a,
            final rhoShaSol_b=rhoShaSol_b)
            "Optical properties of window for different irradiation angles" annotation (
             Placement(transformation(extent={{60,20},{80,40}})));
          Modelica.Blocks.Interfaces.RealInput uSha(min=0, max=1) if haveShade
            "Control signal for shading (0: unshaded; 1: fully shaded)" annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}),iconTransformation(
                extent={{-16,-16},{16,16}},
                rotation=90,
                origin={-2,-116})));
          Modelica.Blocks.Interfaces.RealInput HDif(quantity="RadiantEnergyFluenceRate",
              unit="W/m2") "Diffussive solar radiation" annotation (Placement(
                transformation(extent={{-140,60},{-100,100}}),iconTransformation(extent=
                   {{-130,65},{-100,95}})));
          Modelica.Blocks.Interfaces.RealInput incAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Incident angle" annotation (Placement(transformation(
                  extent={{-140,-20},{-100,20}}), iconTransformation(extent={{-130,-25},
                    {-100,5}})));
          Modelica.Blocks.Interfaces.RealInput HDir(quantity="RadiantEnergyFluenceRate",
              unit="W/m2") "Direct solar radiation" annotation (Placement(
                transformation(extent={{-140,20},{-100,60}}),iconTransformation(extent=
                    {{-130,25},{-100,55}})));

        protected
          Modelica.Blocks.Interfaces.RealInput uSha_internal(min=0, max=1)
            "Control signal for shading (0: unshaded; 1: fully shaded)";
        initial equation
          /* Current model assumes that the window only has either an interior or exterior shade.
     Warn user if it has an interior and exterior shade.
     Allowing both shades at the same time would require rewriting part of the model. */
          assert(not (haveExteriorShade and haveInteriorShade),
            "Window radiation model does not support an exterior and interior shade at the same time.");
        equation
          // Connect statement for conditionally removed connector uSha
          connect(uSha, uSha_internal);
          if (not haveShade) then
            uSha_internal = 0;
          end if;
          annotation (
            Documentation(info="<html>
The model calculates solar absorbance on the window.
The calculations follow the description in Wetter (2004), Appendix A.4.3.

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Add glass thickness as a parameter for radDat. It is needed by the claculation of property for uncoated glass.
</li>
<li>
February 2, 2010, by Michael Wetter:<br/>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
December 16, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
                Text(
                  extent={{-92,0},{-62,-20}},
                  lineColor={0,0,127},
                  textString="incAng"),
                Text(
                  extent={{-94,84},{-70,70}},
                  lineColor={0,0,127},
                  textString="HDif"),
                Text(
                  extent={{-96,42},{-62,30}},
                  lineColor={0,0,127},
                  textString="HDir"),
                Text(
                  extent={{-32,-82},{22,-94}},
                  lineColor={0,0,127},
                  textString="uSha"),
                Polygon(
                  points={{-46,66},{-46,-10},{-6,-50},{-6,22},{-46,66}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{18,64},{18,-12},{58,-52},{58,20},{18,64}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-28,2},{-18,10},{-8,0},{2,10},{12,0},{22,10},{32,-2},{40,4},
                      {34,4},{38,-2},{40,4},{38,4}},
                  color={255,128,0},
                  smooth=Smooth.None),
                Polygon(
                  points={{38,-2},{34,4},{40,4},{38,-2}},
                  lineColor={255,128,0},
                  smooth=Smooth.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{38,-4},{46,-14},{58,-4},{66,-14},{66,-14},{76,-4},{86,-16},{
                      94,-10},{88,-10},{92,-16},{94,-10},{92,-10}},
                  color={255,128,0},
                  smooth=Smooth.None),
                Polygon(
                  points={{92,-16},{88,-10},{94,-10},{92,-16}},
                  lineColor={255,128,0},
                  smooth=Smooth.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-26,8},{-30,14},{-24,14},{-26,8}},
                  lineColor={255,128,0},
                  smooth=Smooth.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-80,20},{-72,10},{-60,20},{-52,10},{-52,10},{-42,20},{-32,8},
                      {-24,14},{-30,14},{-26,8},{-24,14},{-26,14}},
                  color={255,128,0},
                  smooth=Smooth.None)}));
        end PartialRadiation;

        block TransmittedRadiation "Transmitted radiation through window"
          extends Buildings.HeatTransfer.Windows.BaseClasses.PartialRadiation;
          Modelica.Blocks.Interfaces.RealOutput QTra_flow(final quantity="Power",
              final unit="W")
            "Transmitted exterior radiation through the window. (1: no shade; 2: shade)"
            annotation (Placement(transformation(extent={{100,-10},{120,10}}),
                iconTransformation(extent={{100,-10},{120,10}})));
          final parameter Real traCoeRoo(fixed=false)
            "Transmitivity of the window glass for interior radiation without shading";

          output Modelica.SIunits.Power QTraUns_flow
            "Transmitted solar radiation through unshaded part of window";
          output Modelica.SIunits.Power QTraSha_flow
            "Transmitted solar radiation through shaded part of window";

        protected
          Integer k=1;
          Real x;
          final parameter Integer NDIR=radDat.NDIR;
          final parameter Integer HEM=radDat.HEM;
          constant Integer NoShade=1;
          constant Integer Shade=2;
          constant Integer Interior=1;
          constant Integer Exterior=2;
          final parameter Real coeTraWinExtIrr[2, radDat.HEM + 2](fixed=false);
          Real tmpNoSha;
          Real tmpSha;
          Real incAng2;

        initial algorithm
          //**************************************************************
          // Assign coefficients.
          // Data dimension from Orginal ([1 : HEM]) to New ([2 : HEM+1])
          // with 2 dummy variable for interpolation.
          //**************************************************************
          // Glass
          for j in 1:HEM loop
            // Properties for glass without shading
            coeTraWinExtIrr[NoShade, j + 1] := radDat.traRef[1, 1, N, j];
            // Properties for glass with shading
            if haveInteriorShade then
              coeTraWinExtIrr[Shade, j + 1] := radDat.winTraExtIrrIntSha[j];
            elseif haveExteriorShade then
              coeTraWinExtIrr[Shade, j + 1] := radDat.winTraExtIrrExtSha[j];
            else
              // No Shade
              coeTraWinExtIrr[Shade, j + 1] := 0.0;
            end if;
          end for;
          // Dummy variables at 1 and HEM+2
          for k in NoShade:Shade loop
            coeTraWinExtIrr[k, 1] := coeTraWinExtIrr[k, 2];
            coeTraWinExtIrr[k, HEM + 2] := coeTraWinExtIrr[k, HEM + 1];
          end for;

          //**************************************************************
          // Glass: transmissivity for interior irradiation
          //**************************************************************
          traCoeRoo := radDat.traRef[1, N, 1, HEM];

        algorithm
          QTraUns_flow := AWin*HDif*(1 - uSha_internal)*coeTraWinExtIrr[NoShade, HEM +
            1];
          QTraSha_flow := AWin*HDif*uSha_internal*coeTraWinExtIrr[Shade, HEM + 1];

          //**************************************************************
          // Glass, Device: add absorbed radiation (angular part) from exterior sources
          //**************************************************************
          // Use min() instead of if() to avoid event
          incAng2 := min(incAng, 0.5*Modelica.Constants.pi);
          x := 2*(NDIR - 1)*abs(incAng2)/Modelica.Constants.pi
            "x=(index-1)*incAng/(0.5pi), 0<=x<=NDIR-1";
          x := x + 2;

          // Window unshaded parts: add transmitted radiation for angular radiation
          tmpNoSha :=
            Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation({
            coeTraWinExtIrr[NoShade, k] for k in 1:(HEM + 2)}, x);
          QTraUns_flow := QTraUns_flow + AWin*HDir*(1 - uSha_internal)*tmpNoSha;

          // Window shaded parts: add transmitted radiation for angular radiation
          tmpSha := Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation(
            {coeTraWinExtIrr[Shade, k] for k in 1:(HEM + 2)}, x);
          QTraSha_flow := QTraSha_flow + AWin*HDir*uSha_internal*tmpSha;

          // Assign quantities to output connectors
          QTra_flow := QTraUns_flow + QTraSha_flow;
          annotation (
            Documentation(info="<html>
The model calculates solar radiation through the window.
The calculations follow the description in Wetter (2004), Appendix A.4.3.
<br/>

The transmitted exterior radiation for window system includes:<br/>
<ol>
<li>
the transmitted diffusive radiation on unshaded part: <code>AWin*(1-uSha)*HDif*tau(HEM)</code>
</li>
<li>
the transmitted direct radiation on no shade part: <code>AWin*(1-uSha)*HDir*tau(IncAng)</code>
</li>
<li>
the transmitted diffusive radiation on shaded part: <code>AWin*uSha*HDif*tauSha(HEM)</code>
</li>
<li>
the transmitted direct radiation on shaded part: <code>AWin*uSha*HDir*tauSha(IncAng);</code>
</li>
</ol>
The output is <code>QTra_flow = Part1 + Part2 + Part3 + Part4</code>

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
March 4, 2011, by Wangda Zuo:<br/>
Remove the if-statement and integer function that can trigger events.
</li>
<li>
February 2, 2010, by Michael Wetter:<br/>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
December 15, 2010, by Wangda Zuo:<br/>
Separate transmittance and absorbance models from the window radiation model.
</li>
<li>
December 12, 2010, by Michael Wetter:<br/>
Replaced record
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={Text(
                  extent={{-32,-80},{22,-96}},
                  lineColor={0,0,127},
                  textString="uSha"), Text(
                  extent={{44,8},{110,-6}},
                  lineColor={0,0,127},
                  textString="QTra")}));
        end TransmittedRadiation;

        block WindowRadiation "Calculation radiation for window"

          extends Buildings.HeatTransfer.Windows.BaseClasses.PartialRadiation;

          Modelica.Blocks.Interfaces.RealInput HRoo(quantity="RadiantEnergyFluenceRate",
              unit="W/m2") "Diffussive radiation from room " annotation (Placement(
                transformation(extent={{-140,-100},{-100,-60}}),iconTransformation(
                  extent={{-130,-91},{-100,-61}})));
          Modelica.Blocks.Interfaces.RealOutput QTra_flow(final quantity="Power",
              final unit="W")
            "Transmitted exterior radiation through the window. (1: no shade; 2: shade)"
            annotation (Placement(transformation(extent={{100,-90},{120,-70}}),
                iconTransformation(extent={{100,-90},{120,-70}})));

          Modelica.Blocks.Interfaces.RealOutput QAbsExtSha_flow(final quantity="Power",
              final unit="W")
            "Absorbed interior and exterior radiation by exterior shading device"
            annotation (Placement(transformation(extent={{100,80},{120,100}}),
                iconTransformation(extent={{100,80},{120,100}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsIntSha_flow(final quantity="Power",
              final unit="W")
            "Absorbed interior and exterior radiation by interior shading device"
            annotation (Placement(transformation(extent={{100,-40},{120,-20}}),
                iconTransformation(extent={{100,-40},{120,-20}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaUns_flow[N](each quantity=
                "Power", each final unit="W")
            "Absorbed interior and exterior radiation by unshaded part of glass"
            annotation (Placement(transformation(extent={{100,40},{120,60}}),
                iconTransformation(extent={{100,40},{120,60}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaSha_flow[N](each quantity=
                "Power", each final unit="W")
            "Absorbed interior and exterior radiation by shaded part of glass"
            annotation (Placement(transformation(extent={{100,0},{120,20}}),
                iconTransformation(extent={{100,0},{120,20}})));

          Buildings.HeatTransfer.Windows.BaseClasses.TransmittedRadiation tra(
            final N=N,
            final tauGlaSol=tauGlaSol,
            final rhoGlaSol_a=rhoGlaSol_a,
            final rhoGlaSol_b=rhoGlaSol_b,
            final xGla=xGla,
            final tauShaSol_a=tauShaSol_a,
            final rhoShaSol_a=rhoShaSol_a,
            final rhoShaSol_b=rhoShaSol_b,
            final haveExteriorShade=haveExteriorShade,
            final haveInteriorShade=haveInteriorShade,
            final AWin=AWin,
            final tauShaSol_b=tauShaSol_b)
            annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
          Buildings.HeatTransfer.Windows.BaseClasses.AbsorbedRadiation abs(
            final N=N,
            final tauGlaSol=tauGlaSol,
            final rhoGlaSol_a=rhoGlaSol_a,
            final rhoGlaSol_b=rhoGlaSol_b,
            final xGla=xGla,
            final tauShaSol_a=tauShaSol_a,
            final tauShaSol_b=tauShaSol_b,
            final rhoShaSol_a=rhoShaSol_a,
            final rhoShaSol_b=rhoShaSol_b,
            final haveExteriorShade=haveExteriorShade,
            final haveInteriorShade=haveInteriorShade,
            final AWin=AWin)
            annotation (Placement(transformation(extent={{-40,-40},{-20,-20}})));
        protected
          final parameter Boolean noShade=not (haveExteriorShade or haveInteriorShade)
            "Flag, true if the window has a shade";
        equation
          if noShade then
            assert(uSha_internal < 1E-6,
              "Window has no shade, but control signal is non-zero.\n" +
              "  Received uSha_internal = " + String(uSha_internal));
          end if;
          connect(HDif, tra.HDif) annotation (Line(
              points={{-120,80},{-80,80},{-80,58},{-41.5,58}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDif, abs.HDif) annotation (Line(
              points={{-120,80},{-80,80},{-80,-22},{-41.5,-22}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDir, tra.HDir) annotation (Line(
              points={{-120,40},{-74,40},{-74,54},{-41.5,54}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDir, abs.HDir) annotation (Line(
              points={{-120,40},{-74,40},{-74,-26},{-41.5,-26}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(incAng, tra.incAng) annotation (Line(
              points={{-120,1.11022e-15},{-68,1.11022e-15},{-68,49},{-41.5,49}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(incAng, abs.incAng) annotation (Line(
              points={{-120,1.11022e-15},{-68,1.11022e-15},{-68,-31},{-41.5,-31}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HRoo, abs.HRoo) annotation (Line(
              points={{-120,-80},{-54,-80},{-54,-37.6},{-41.5,-37.6}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(tra.uSha, uSha) annotation (Line(
              points={{-30.2,38.4},{-30.2,24},{1.11022e-15,24},{1.11022e-15,-120}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.uSha, uSha) annotation (Line(
              points={{-30.2,-41.6},{-30.2,-48},{1.11022e-15,-48},{1.11022e-15,-120}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(tra.QTra_flow, QTra_flow) annotation (Line(
              points={{-19,50},{12,50},{12,-80},{110,-80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.QAbsIntSha_flow, QAbsIntSha_flow) annotation (Line(
              points={{-19,-38},{80,-38},{80,-30},{110,-30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.QAbsGlaSha_flow, QAbsGlaSha_flow) annotation (Line(
              points={{-19,-34},{72,-34},{72,10},{110,10}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.QAbsGlaUns_flow, QAbsGlaUns_flow) annotation (Line(
              points={{-19,-26},{52,-26},{52,50},{110,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.QAbsExtSha_flow, QAbsExtSha_flow) annotation (Line(
              points={{-19,-22},{36,-22},{36,90},{110,90}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Documentation(info="<html>
<p>
The model calculates solar radiation through the window.
The calculations follow the description in Wetter (2004), Appendix A.4.3.
</p>
<p>
The absorbed radiation by exterior shades includes:
</p>
<ol>
<li>
the directly absorbed exterior radiation: <code>AWin*uSha*(HDir+HDif)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed exterior radiantion from reflection (angular part): <code>AWin*uSha*HDir*tau*rho(IncAng)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed of exterior irradiantion from reflection (diffusive part): <code>AWin*uSha*HDif*tau*rho(HEM)*(1-tau-rho)</code>
</li>
<li>
the absorbed interior radiation is neglected.
</li>
</ol>
<p>
The output is <code>absRad[2, 1]</code>
</p>

<p>
The absorbed radiation by interior shades includes:</p>
<ol>
<li>
the absorbed exterior radiation (angular part): <code>AWin*uSha*HDir*alpha(IncAng)</code>
</li>
<li>
the absorbed exterior radiation (diffusive part): <code>AWin*uSha*HDif*alpha(HEM)</code>
</li>
<li>
the absorbed interior radiation (diffusive part): <code>AWin*uSha*HRoo*(1-tau-rho)</code>
</li>
</ol>
<p>
The output is <code>absRad[2, N+2]</code></p>

<p>
The absorbed radiation by glass includes:</p>
<ol>
<li>
the absorbed radiation by unshaded part (diffusive part): <code>AWin*(1-uSha)*(HDif*alphaEx(HEM)+HRoo*alphaIn(HEM))</code>
</li>
<li>
the absorbed radiation by unshaded part (angualr part from exterior source): <code>AWin*(1-uSha)*HDir*alphaEx(IncAng)</code>
</li>
<li>
the absorbed radiaiton by shaded part (diffusive part): <code>AWin*uSha*(HDif*alphaExSha(HEM)+HRoo*alphaInSha(HEM))</code>
</li>
<li>
the absorbed radiation by shaded part (angular part from exterior source): <code>AWin*uSha*HDir*alphaExSha(IncAng)</code>
</li>
</ol>
<p>
The output is <code>absRad[1, 2:N+1] = Part1 + Part2; absRad[2, 2:N+1] = Part3 + Part4</code></p>

<p>
The transmitted exterior radiation for window system includes:</p>
<ol>
<li>
the transmitted diffusive radiation on unshaded part: <code>AWin*(1-uSha)*HDif*tau(HEM)</code>
</li>
<li>
the transmitted direct radiation on no shade part: <code>AWin*(1-uSha)*HDir*tau(IncAng)</code>
</li>
<li>
the transmitted diffusive radiation on shaded part: <code>AWin*uSha*HDif*tauSha(HEM)</code>
</li>
<li>
the transmitted direct radiation on shaded part: <code>AWin*uSha*HDir*tauSha(IncAng);</code>
</li>
</ol>
<p>The output is <code>QTra_flow = Part1 + Part2 + Part3 + Part4</code></p>

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Add glass thickness as a parameter for tra and abs. It is needed by the claculation of property for uncoated glass.
</li>
<li>
February 2, 2010, by Michael Wetter:<br/>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
January 4, 2011, by Michael Wetter:<br/>
Added assert statement to check that <code>uSha=0</code> if no shade is present.
This is needed to avoid wrong results in the room model.
</li>
<li>
December 15, 2010, by Wangda Zuo:<br/>
Revise the model by separating transmittance and absorbance.
</li>
<li>
December 12, 2010, by Michael Wetter:<br/>
Replaced record
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
                Text(
                  extent={{0,86},{90,72}},
                  lineColor={0,0,127},
                  textString="QAbsExtSha"),
                Text(
                  extent={{-32,-80},{22,-96}},
                  lineColor={0,0,127},
                  textString="uSha"),
                Text(
                  extent={{-4,-22},{92,-36}},
                  lineColor={0,0,127},
                  textString="QAbsIntSha"),
                Text(
                  extent={{2,58},{94,44}},
                  lineColor={0,0,127},
                  textString="QAbsGlaUns"),
                Text(
                  extent={{-2,20},{92,6}},
                  lineColor={0,0,127},
                  textString="QAbsGlaSha"),
                Text(
                  extent={{18,-78},{92,-94}},
                  lineColor={0,0,127},
                  textString="QTra"),
                Text(
                  extent={{-110,-64},{-26,-86}},
                  lineColor={0,0,127},
                  textString="HRoo")}));
        end WindowRadiation;

        partial record RadiationBaseData
          "Basic parameters for window radiation calculation"

          parameter Integer N(min=1) "Number of glass layers"
            annotation (Dialog(group="Glass"));
          parameter Modelica.SIunits.Length xGla[N] "Thickness of glass"
          annotation (Dialog(group="Glass"));
          parameter Modelica.SIunits.TransmissionCoefficient tauGlaSol[N]
            "Solar transmissivity of glass" annotation (Dialog(group="Glass"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoGlaSol_a[N]
            "Solar reflectivity of glass at surface a (facing outside)"
            annotation (Dialog(group="Glass"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoGlaSol_b[N]
            "Solar reflectivity of glass at surface b (facing room-side)"
            annotation (Dialog(group="Glass"));

          parameter Modelica.SIunits.TransmissionCoefficient tauShaSol_a
            "Solar transmissivity of shade for irradiation from air-side"
            annotation (Dialog(group="Shade"));
          parameter Modelica.SIunits.TransmissionCoefficient tauShaSol_b
            "Solar transmissivity of shade for irradiation from glass-side"
            annotation (Dialog(group="Shade"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoShaSol_a
            "Solar reflectivity of shade for irradiation from air-side"
            annotation (Dialog(group="Shade"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoShaSol_b
            "Solar reflectivity of shade for irradiation from glass-side"
            annotation (Dialog(group="Shade"));

          annotation (Documentation(info="<html>
Record that defines basic parameters for the window radiation calculation.
</html>",         revisions="<html>
<ul>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Add glass thickness as a parameter. It is needed by the claculation of property for uncoated glass.
</li>
<li>
December 16, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end RadiationBaseData;

        record RadiationData "Radiation data of a window"
          extends Modelica.Icons.Record;
          extends Buildings.HeatTransfer.Windows.BaseClasses.RadiationBaseData;
          final parameter Real glass[3, N]={tauGlaSol,rhoGlaSol_a,rhoGlaSol_b}
            "Glass solar transmissivity, solar reflectivity at surface a and b, at normal incident angle";
          final parameter Real traRefShaDev[2, 2]={{tauShaSol_a,tauShaSol_b},{
              rhoShaSol_a,rhoShaSol_b}} "Shading device property";
          final parameter Integer NDIR=10 "Number of incident angles";
          final parameter Integer HEM=NDIR + 1
            "Index of hemispherical integration";
          final parameter Modelica.SIunits.Angle psi[NDIR]=
              Buildings.HeatTransfer.Windows.Functions.getAngle(NDIR)
            "Incident angles used for solar radiation calculation";
          final parameter Real layer[3, N, HEM]=
              Buildings.HeatTransfer.Windows.Functions.glassProperty(
              N=N,
              HEM=HEM,
              glass=glass,
              xGla=xGla,
              psi=psi) "Angular and hemispherical transmissivity, front (outside-facing) and back (room facing) reflectivity
      of each glass pane";
          final parameter Real traRef[3, N, N, HEM]=
              Buildings.HeatTransfer.Windows.Functions.getGlassTR(
              N=N,
              HEM=HEM,
              layer=layer) "Angular and hemispherical transmissivity, front (outside-facing) and back (room facing) reflectivity
      between glass panes for exterior or interior irradiation without shading";
          final parameter Real absExtIrrNoSha[N, HEM]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationNoShading(
              traRef=traRef,
              N=N,
              HEM=HEM) "Angular and hemispherical absorptivity of each glass pane
      for exterior irradiation without shading";
          final parameter Real absIntIrrNoSha[N]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsInteriorIrradiationNoShading(
              traRef=traRef,
              N=N,
              HEM=HEM) "Hemispherical absorptivity of each glass pane
      for interior irradiation without shading";
          final parameter Real winTraExtIrrExtSha[HEM]=
              Buildings.HeatTransfer.Windows.Functions.winTExteriorIrradiatrionExteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              HEM=HEM) "Angular and hemispherical transmissivity of a window system (glass + exterior shading device)
     for exterior irradiation";
          final parameter Real absExtIrrExtSha[N, HEM]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationExteriorShading(
              absExtIrrNoSha=absExtIrrNoSha,
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              HEM=HEM) "Angular and hemispherical absorptivity of each glass pane
      for exterior irradiation with exterior shading";
          final parameter Real winTraExtIrrIntSha[HEM]=
              Buildings.HeatTransfer.Windows.Functions.winTExteriorIrradiationInteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              HEM=HEM) "Angular and hemispherical transmissivity of a window system (glass and interior shading device)
      for exterior irradiation";
          final parameter Real absExtIrrIntSha[N, HEM]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationInteriorShading(
              absExtIrrNoSha=absExtIrrNoSha,
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              HEM=HEM) "Angular and hemispherical absorptivity of each glass layer
     for exterior irradiation with interior shading";
          final parameter Real devAbsExtIrrIntShaDev[HEM]=
              Buildings.HeatTransfer.Windows.Functions.devAbsExteriorIrradiationInteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              HEM=HEM) "Angular and hemispherical absorptivity of an interior shading device
      for exterior irradiation";
          final parameter Real winTraRefIntIrrExtSha[3]=
              Buildings.HeatTransfer.Windows.Functions.winTRInteriorIrradiationExteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              HEM=HEM) "Hemisperical transmissivity and reflectivity of a window system (glass and exterior shadig device)
      for interior irradiation. traRefIntIrrExtSha[1]: transmissivity,
      traRefIntIrrExtSha[2]: Back reflectivity; traRefIntIrrExtSha[3]: dummy value";
          final parameter Real absIntIrrExtSha[N]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsInteriorIrradiationExteriorShading(
              absIntIrrNoSha=absIntIrrNoSha,
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              HEM=HEM) "Hemispherical absorptivity of each glass pane
      for interior irradiation with exterior shading";
          final parameter Real absIntIrrIntSha[N]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsInteriorIrradiationInteriorShading(
              absIntIrrNoSha=absIntIrrNoSha,
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              HEM=HEM) "Hemispherical absorptivity of each glass pane
      for interior irradiation with interior shading";
          final parameter Real winTraRefIntIrrIntSha[3]=
              Buildings.HeatTransfer.Windows.Functions.winTRInteriorIrradiationInteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              HEM=HEM) "Hemisperical transmissivity and back reflectivity of a window system (glass and interior shadig device)
      for interior irradiation";
          final parameter Real devAbsIntIrrIntSha=
              Buildings.HeatTransfer.Windows.Functions.devAbsInteriorIrradiationInteriorShading(
              traRef=traRef,
              traRefShaDev=traRefShaDev,
              N=N,
              HEM=HEM)
            "Hemiperical absorptivity of an interior shading device for interior irradiation";
          annotation (Documentation(info="<html>
Record that computes the solar radiation data for a glazing system.
</html>",         revisions="<html>
<ul>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Add glass thickness as a parameter for glassProperty(). It is needed by the calculation of property for uncoated glass.
</li>
<li>
December 12, 2010, by Michael Wetter:<br/>
Replaced record
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end RadiationData;

        function convectionVerticalCavity "Free convection in vertical cavity"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Rayleigh number";
          input Modelica.SIunits.Temperature T_m
            "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
            "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Area h(min=0) = 1.5 "Height of window";
          input Real deltaNu(min=0.01) = 0.1
            "Small value for Nusselt number, used for smoothing";
          input Real deltaRa(min=0.01) = 1E3
            "Small value for Rayleigh number, used for smoothing";
          output Real Nu(min=0) "Nusselt number";
          output Modelica.SIunits.CoefficientOfHeatTransfer hCon(min=0)
            "Convective heat transfer coefficient";
          output Modelica.SIunits.HeatFlux q_flow "Convective heat flux";
        protected
          Real Nu_1(min=0) "Nusselt number";
          Real Nu_2(min=0) "Nusselt number";
        algorithm

          Nu_1 :=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=0.0673838*Ra^(1/3),
            neg=Buildings.Utilities.Math.Functions.spliceFunction(
              pos=0.028154*Ra^(0.4134),
              neg=1 + 1.7596678E-10*Ra^(2.2984755),
              x=Ra - 1E4,
              deltax=deltaRa),
            x=Ra - 5E4,
            deltax=deltaRa);
          /*
  if ( Ra <= 1E4) then
    Nu_1 = 1 + 1.7596678E-10*Ra^(2.2984755);
  elseif ( Ra <= 5E4) then
    Nu_1 = 0.028154*Ra^(0.4134);
  else
    Nu_1 = 0.0673838*Ra^(1/3);
  end if;
  */
          Nu_2 :=0.242*(Ra/(h/gas.x))^(0.272);
          Nu :=Buildings.Utilities.Math.Functions.smoothMax(
            x1=Nu_1,
            x2=Nu_2,
            deltaX=deltaNu);
          hCon :=Nu*Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas=gas, T=T_m)/gas.x;
          q_flow :=hCon*dT;
            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for convective heat transfer in vertical window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the convection coefficient
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end convectionVerticalCavity;

        function convectionHorizontalCavity
          "Free convection in horizontal cavity"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Rayleigh number";
          input Modelica.SIunits.Temperature T_m
            "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
            "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Angle til "Window tilt";
          input Real sinTil "Sine of window tilt";
          input Real cosTil "Cosine of the window tilt";
          input Modelica.SIunits.Area h(min=0) = 1.5 "Height of window";
          input Real deltaNu(min=0.01) = 0.1
            "Small value for Nusselt number, used for smoothing";
          input Real deltaRa(min=0.01) = 1E3
            "Small value for Rayleigh number, used for smoothing";
          output Real Nu(min=0) "Nusselt number";
          output Modelica.SIunits.CoefficientOfHeatTransfer hCon(min=0)
            "Convective heat transfer coefficient";
          output Modelica.SIunits.HeatFlux q_flow "Convective heat flux";
        protected
          Real Nu_1(min=0) "Nusselt number";
          Real Nu_2(min=0) "Nusselt number";
          constant Real dx=0.1 "Half-width of interval used for smoothing";
        algorithm
          if cosTil > 0 then
          Nu :=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityReduced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              h=h,
              sinTil=sinTil,
              deltaNu=deltaNu,
              deltaRa=deltaRa),
            neg=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityEnhanced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              til=til,
              cosTil=abs(cosTil)),
            x=dT+dx,
            deltax=dx);
          else
            Nu :=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityEnhanced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              til=til,
              cosTil=abs(cosTil)),
            neg=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityReduced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              h=h,
              sinTil=sinTil,
              deltaNu=deltaNu,
              deltaRa=deltaRa),
            x=dT-dx,
            deltax=dx);
          end if;
          hCon :=Nu*Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas, T_m)/gas.x;
          q_flow :=hCon*dT;
            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for convective heat transfer in horizontal window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the convection coefficient
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end convectionHorizontalCavity;

        function nusseltHorizontalCavityEnhanced
          "Nusselt number for horizontal cavity, bottom surface warmer than top surface"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Rayleigh number";
          input Modelica.SIunits.Temperature T_m
            "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
            "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Angle til "Window tilt";
          input Real cosTil(min=0) "Cosine of the window tilt";
          output Real Nu(min=0) "Nusselt number";
        protected
          Real k1 "Auxiliary variable";
          Real k2 "Auxiliary variable";
          Real k11 "Auxiliary variable";
          Real k22 "Auxiliary variable";
        algorithm
          // Windows inclined from 0 to 60 deg (eqn. 3.1-42 to 3.1-43)
          k1 :=1 - 1708/Ra/cosTil;
          k2 :=(Ra*cosTil/5830)^(1/3) - 1;
          k11 :=(k1 + Buildings.Utilities.Math.Functions.smoothMax(
            x1=k1,
            x2=-k1,
            deltaX=1E-1))/2;
          k22 :=(k2 + Buildings.Utilities.Math.Functions.smoothMax(
            x1=k2,
            x2=-k2,
            deltaX=1E-1))/2;
          Nu :=1 + 1.44*k11*(1 - 1708*abs(Modelica.Math.sin(1.8*til*180/Modelica.Constants.pi))
            ^(1.6)/Ra/cosTil) + k22;
            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for Nusselt number in horizontal window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the Nusselt number
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end nusseltHorizontalCavityEnhanced;

        function nusseltHorizontalCavityReduced
          "Nusselt number for horizontal cavity, bottom surface colder than top surface"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Rayleigh number";
          input Modelica.SIunits.Temperature T_m
            "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
            "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Area h(min=0) = 1.5 "Height of window";
          input Real sinTil "Sine of window tilt";
          input Real deltaNu(min=0.01) = 0.1
            "Small value for Nusselt number, used for smoothing";
          input Real deltaRa(min=0.01) = 1E3
            "Small value for Rayleigh number, used for smoothing";
          output Real Nu(min=0) "Nusselt number";
        protected
          Real NuVer(min=0) "Nusselt number for vertical window";
        algorithm
          NuVer :=Buildings.HeatTransfer.Windows.BaseClasses.convectionVerticalCavity(
            gas=gas,
            Ra=Ra,
            T_m=T_m,
            dT=dT,
            h=h,
            deltaNu=deltaNu,
            deltaRa=deltaRa);
          Nu :=1 + (NuVer - 1)*sinTil;

            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for Nusselt number in horizontal window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the Nusselt number
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end nusseltHorizontalCavityReduced;

        function smoothInterpolation
          "Get interpolated data without triggering events"
          input Real y[:] "Data array";
          input Real x "x value";
          output Real val "Return value";

        protected
          Integer k1;
          Integer k2;
          Real y1d;
          Real y2d;
        algorithm
          k1 := integer(x);
          k2 := k1 + 1;

          y1d := (y[k1 + 1] - y[k1 - 1])/2;
          y2d := (y[k2 + 1] - y[k2 - 1])/2;
          val := Modelica.Fluid.Utilities.cubicHermite(
            x,
            k1,
            k2,
            y[k1],
            y[k2],
            y1d,
            y2d);

          annotation (
            smoothOrder=1,
            Inline=true,
            Documentation(info="<html>
<p>
Function to interpolate within a data array without triggerring events.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 4, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothInterpolation;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Windows\">Buildings.HeatTransfer.Windows</a>.
</p>
</html>"));
      end BaseClasses;

      package Functions "Functions used in window radiation model"
        extends Modelica.Icons.Package;

        function devAbsExteriorIrradiationInteriorShading
          "Angular and hemispherical absorptance of a shading device for exterior irradiation with interior shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absExtIrrIntShaDev[HEM](each min=0, each max=1)
            "Absorptance of a shading device for exterior irradiation with interior shading";

        algorithm
          for iD in 1:HEM loop
            absExtIrrIntShaDev[iD] := traRef[TRA, 1, N, iD]*(1 - traIntShaDev -
              refIntShaDev)/(1 - refIntShaDev*traRef[Rb, N, 1, HEM])
              "Equation (A.4.91)";
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular and hemispherical absorptance of a shading device for exterior irradiation with interior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end devAbsExteriorIrradiationInteriorShading;

        function devAbsInteriorIrradiationInteriorShading
          "Hemiperical absorptance of a shading device for interior irradiation with interior shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absIntIrrIntShaDev(min=0, max=1)
            "Hemiperical absorbtance of a shading device for interior irradiation with interior shading";
        protected
          constant Real rRho=traRef[3, N, 1, HEM]*refIntShaDev
            "Part of equation (A.4.103)";
          constant Real rTau=traRef[3, N, 1, HEM]*traIntShaDev
            "Part of equation (A.4.103)";
          constant Real c=traIntShaDev*(1 - rRho/(1 - rRho)) "Equation (4.99)";

        algorithm
          absIntIrrIntShaDev := (1 - traIntShaDev - refIntShaDev)*(1 + rTau/(1 - rRho))
            "Equation (4.103)";

          annotation (Documentation(info="<html>
<p>
This function computes the hemiperical absorbtance of a shading device for interior irradiation with interior shading.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end devAbsInteriorIrradiationInteriorShading;

        function getAngle "Generate incident angles"
          input Integer NDIR "Number of incident angles";
          output Modelica.SIunits.Angle psi[NDIR] "Array of incident angles";

        protected
          constant Real deltaX=0.5*Modelica.Constants.pi/(NDIR - 1);

        algorithm
          for i in 1:NDIR loop
            psi[i] := (i - 1)*deltaX;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes discrete incident angles for the window radiation calculation. The range is from 0 to 90 degree.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getAngle;

        function getGlassTR "Transmittance and reflectance of glass"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;

          input Real layer[3, N, HEM] "Property of glass pane";
          output Real traRef[3, N, N, HEM](each min=0, each max=1)
            "Glass transmittance, front and back reflectance";

        protected
          Real traRefIntIrr[3, N, N, HEM](each min=0, each max=1)
            "temporary array for glass transmittance, front and back reflectance for interior irradiation";

        algorithm
          traRef :=
            Buildings.HeatTransfer.Windows.Functions.glassTRExteriorIrradiationNoShading(
            N,
            HEM,
            layer) "property for exterior irradiation";
          traRefIntIrr :=
            Buildings.HeatTransfer.Windows.Functions.glassTRInteriorIrradiationNoShading(
            N,
            HEM,
            layer) "property for interior irradiation";

          // Copy the property for interior irradiation to glass property
          for k in TRA:Rb loop
            for i in 1:N - 1 loop
              for j in i + 1:N loop
                for iD in 1:HEM loop
                  traRef[k, N + 1 - i, N + 1 - j, iD] := traRefIntIrr[k, N + 1 - i, N
                     + 1 - j, iD];
                end for;
              end for;
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation of the transmittance and reflectance of each glass pane.
It accounts for the transmittance and reflectance among different panes.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
For instance, <code>traRef[TRA, 1, N, iD]</code> means transmittance between layer <code>1</code> to <code>N</code> for exterior irradiation and
<code>traRef[TRA, N, 1, iD]</code> means the transmittance for interior irradiation.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getGlassTR;

        function glassAbsExteriorIrradiationExteriorShading
          "Angular and hemispherical absorptance of each glass pane for exterior irradiation with exterior shading"
          input Real absExtIrrNoSha[N, HEM](each min=0, each max=1)
            "Angular and hemispherical absorptance of each glass pane for exterior irradiation without shading";
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absExtIrrExtSha[N, HEM](each min=0, each max=1)
            "Angular and hemispherical absorptance of each glass pane for exterior irradiation with exterior shading";

        protected
          Real c "Intermediate variable";

        algorithm
          for iD in 1:HEM loop
            c := traExtShaDev*(1 + traRef[Ra, 1, N, iD]*refExtShaDev/(1 - traRef[Ra, 1,
              N, HEM]*refExtShaDev));
            for i in 1:N loop
              absExtIrrExtSha[i, iD] := c*absExtIrrNoSha[i, iD];
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes angular and hemispherical absorptance of each glass pane for exterior irradiation with exterior shading.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsExteriorIrradiationExteriorShading;

        function glassAbsExteriorIrradiationInteriorShading
          "Angular and hemispherical absorptance of each glass pane for exterior irradiation with interior shading"
          input Real absExtIrrNoSha[N, HEM](each min=0, each max=1)
            "Absorptance for exterior irradiation without shading";
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;
          output Real absExtIrrNoShaIntSha[N, HEM](each min=0, each max=1)
            "Angular and hemispherical absorptance of each glass pane for exterior irradiation with interior shading";

        protected
          Real fac;
          Real absFro "Front (outside-facing) absorptance";
          Real absBac "Back (room-facing) absorptance";
          Integer i "Index of glass pane";

        algorithm
          for iD in 1:HEM loop
            i := 1;
            fac := traRef[TRA, 1, N, iD]*refIntShaDev/(1 - traRef[Rb, N, 1, HEM]*
              refIntShaDev) "Equation (A.4.90)";
            absBac := 1 - traRef[TRA, i, i, iD] - traRef[Rb, i, i, iD]
              "Equation (A.4.81b)";

            if N >= 2 then
              absExtIrrNoShaIntSha[i, iD] := absExtIrrNoSha[i, iD] + fac*traRef[TRA, N,
                i + 1, HEM]*absBac "Equation (A.4.90)";

              for i in 2:N - 1 loop
                fac := traRef[TRA, 1, N, iD]*refIntShaDev/(1 - traRef[Rb, N, 1, HEM]*
                  refIntShaDev) "Equation (A.4.90)";
                absFro := 1 - traRef[TRA, i, i, iD] - traRef[Ra, i, i, iD]
                  "Equaiton (A.4.81a)";
                absBac := 1 - traRef[TRA, i, i, iD] - traRef[Rb, i, i, iD]
                  "Equation (A.4.81b)";
                absExtIrrNoShaIntSha[i, iD] := absExtIrrNoSha[i, iD] + fac*(traRef[TRA,
                  N, i, HEM]*traRef[Rb, i - 1, 1, HEM]*absFro + traRef[TRA, N, i + 1,
                  HEM]*absBac) "Equation (A.4.90)";
              end for;

              i := N;
              fac := traRef[TRA, 1, N, iD]*refIntShaDev/(1 - traRef[Rb, N, 1, HEM]*
                refIntShaDev) "Equation (A.4.90)";
              absFro := 1 - traRef[TRA, i, i, iD] - traRef[Ra, i, i, iD]
                "Equaiton (A.4.81a)";
              absBac := 1 - traRef[TRA, i, i, iD] - traRef[Rb, i, i, iD]
                "Equation (A.4.81b)";
              absExtIrrNoShaIntSha[i, iD] := absExtIrrNoSha[i, iD] + fac*(traRef[TRA, N,
                i, HEM]*traRef[Rb, i - 1, 1, HEM]*absFro + absBac)
                "Equation (A.4.90)";

            else
              absExtIrrNoShaIntSha[i, iD] := absExtIrrNoSha[i, iD] + fac*absBac
                "Equation (A.4.90)";
            end if;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes angular and hemispherical absorptance of each glass pane for exterior irradiation with interior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsExteriorIrradiationInteriorShading;

        function glassAbsExteriorIrradiationNoShading
          "Angular and hemispherical absorptance of each glass pane for exterior irradiation without shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowRadiation;
          output Real[N, HEM] abs(each min=0, each max=1) "Angular and hemispherical absorptance of each glass pane for exterior irradiation without shading.
     Indices: abs[1 to N : ] -> pane 1 to N;
     abs[ : 1 to HEM] -> angular (1:HEM-1) and hemispherical (HEM)";

        protected
          Real af "Front (outside-facing side) absorptance of a pane";
          Real ab "Back (room-facing side) absorptance of a pane";
          Real deno1 "Denominantor";
          Real deno2 "Denominantor";
          Integer j;
          constant Real SMALL=Modelica.Constants.small "Small value";

        algorithm
          if N == 1 then
            j := 1;
            for iD in 1:HEM loop
              abs[j, iD] := 1 - traRef[TRA, j, j, iD] - traRef[Ra, j, j, iD]
                "Equation (A.4.79)";
            end for;
          else
            for iD in 1:HEM loop
              j := 1;
              af := 1 - traRef[TRA, j, j, iD] - traRef[Ra, j, j, iD]
                "Equation (A.4.81a)";
              ab := 1 - traRef[TRA, j, j, iD] - traRef[Rb, j, j, iD]
                "Equation (A.4.81b)";
              deno2 := 1 - traRef[Rb, j, 1, iD]*traRef[Ra, j + 1, N, iD];
              if deno2 < SMALL then
                abs[j, iD] := 0;
              else
                abs[j, iD] := af + ab*traRef[TRA, 1, j, iD]*traRef[Ra, j + 1, N, iD]/
                  deno2 "Equation (A.4.82) and (A.4.83b)";
              end if;

              for j in 2:N - 1 loop
                af := 1 - traRef[TRA, j, j, iD] - traRef[Ra, j, j, iD]
                  "Equation (A.4.81a)";
                ab := 1 - traRef[TRA, j, j, iD] - traRef[Rb, j, j, iD]
                  "Equation (A.4.81b)";
                deno1 := 1 - traRef[Ra, j, N, iD]*traRef[Rb, j - 1, 1, iD];
                deno2 := 1 - traRef[Rb, j, 1, iD]*traRef[Ra, j + 1, N, iD];
                if deno1 < SMALL or deno2 < SMALL then
                  abs[j, iD] := 0;
                else
                  abs[j, iD] := af*traRef[TRA, 1, j - 1, iD]/deno1 + ab*traRef[TRA, 1,
                    j, iD]*traRef[Ra, j + 1, N, iD]/deno2 "Equation (A.4.83b)";
                end if;
              end for;

              j := N;
              af := 1 - traRef[TRA, j, j, iD] - traRef[Ra, j, j, iD]
                "Equation (A.4.81a)";
              deno1 := 1 - traRef[Ra, j, N, iD]*traRef[Rb, j - 1, 1, iD];
              if deno1 < SMALL then
                abs[j, iD] := 0;
              else
                abs[j, iD] := af*traRef[TRA, 1, j - 1, iD]/deno1;
              end if;
            end for;
          end if;

          annotation (Documentation(info="<html>
<p>
This function computes specular and hemispherical absorptance of each glass pane for exterior irradiation without shading.
It counts the transmittance and reflectance among different panes.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsExteriorIrradiationNoShading;

        function glassAbsInteriorIrradiationExteriorShading
          "Hemispherical absorptance of each glass pane for interior irradiation with exterior shading"
          input Real absIntIrrNoSha[N]
            "Absorptance for interior irradiation without shading";
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absIntIrrExtSha[N](each min=0, each max=1)
            "Hemispherical absorptance of each glass pane for interior irradiation with exterior shading";

        protected
          Real fac;
          Real absFro "Front absorptance";
          Real absBac "Back absorptance";
          Integer i "Pane index";

        algorithm
          fac := traRef[TRA, N, 1, HEM]*refExtShaDev/(1 - traRef[Ra, 1, N, HEM]*
            refExtShaDev);

          i := 1;
          absFro := 1 - traRef[TRA, i, i, HEM] - traRef[Ra, i, i, HEM]
            "Equaiton (A.4.81a)";
          absBac := 1 - traRef[TRA, i, i, HEM] - traRef[Rb, i, i, HEM]
            "Equation (A.4.81b)";

          if N >= 2 then
            absIntIrrExtSha[i] := absIntIrrNoSha[i] + fac*absFro + fac*traRef[TRA, 1, i,
              HEM]*traRef[Ra, i + 1, N, HEM]*absBac "Equation (A.4.94)";

            for i in 2:N - 1 loop
              absFro := 1 - traRef[TRA, i, i, HEM] - traRef[Ra, i, i, HEM]
                "Equaiton (A.4.81a)";
              absBac := 1 - traRef[TRA, i, i, HEM] - traRef[Rb, i, i, HEM]
                "Equation (A.4.81b)";
              absIntIrrExtSha[i] := absIntIrrNoSha[i] + fac*traRef[TRA, 1, i - 1, HEM]*
                absFro + fac*traRef[TRA, 1, i, HEM]*traRef[Ra, i + 1, N, HEM]*absBac
                "Equation (A.4.94)";
            end for;

            i := N;
            absFro := 1 - traRef[TRA, i, i, HEM] - traRef[Ra, i, i, HEM]
              "Equaiton (A.4.81a)";
            absIntIrrExtSha[i] := absIntIrrNoSha[i] + fac*traRef[TRA, 1, i - 1, HEM]*
              absFro "Equation (A.4.94)";
          else
            absIntIrrExtSha[i] := absIntIrrNoSha[i] + fac*absFro
              "Equation (A.4.94)";
          end if;
          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical absorptance of each glass pane for interior irradiation with exterior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsInteriorIrradiationExteriorShading;

        function glassAbsInteriorIrradiationInteriorShading
          "Hemispherical absorptance of each glass pane for interior irradiation with interior shading"
          input Real absIntIrrNoSha[N](each min=0, each max=1)
            "Hemispherical absorptance wfor interior irradiation without interior shading";
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absIntIrrIntSha[N](each min=0, each max=1)
            "Hemispherical absorbtance of each glass pane for interior irradiation with interior shading";

        protected
          constant Real rRho=traRef[Rb, N, 1, HEM]*refIntShaDev
            "Part of Equation (4.99)";
          constant Real c=traIntShaDev*(1 + rRho/(1 - rRho)) "Equation (4.99)";

        algorithm
          for i in 1:N loop
            absIntIrrIntSha[i] := c*absIntIrrNoSha[i] "Equation (A4.100a)";
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical absorbtance of each glass pane for interior irradiation with interior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsInteriorIrradiationInteriorShading;

        function glassAbsInteriorIrradiationNoShading
          "Hemispherical absorptance of each glass pane for interior irradiation without shading"

          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowRadiation;

          output Real[N] absIntIrrNoSha(each min=0, each max=1)
            "Hemispherical absorptance of each glass layer for interior irradiation without shading";

        protected
          Real dTraRef[3, N, N, HEM](each min=0, each max=1)
            "Dummy transmittance and reflectance with exterior irradiation without shading";
          Real dAbs[N, HEM](each min=0, each max=1)
            "Dummy absorptance with exterior irradiation and no shading";

        algorithm
          // Reverse the data srtucture for exterior irradiation and no shading
          for i in 1:N loop
            for j in 1:N loop
              for iD in 1:HEM loop
                dTraRef[TRA, i, j, iD] := traRef[TRA, N + 1 - i, N + 1 - j, iD];
                dTraRef[Ra, i, j, iD] := traRef[Rb, N + 1 - i, N + 1 - j, iD];
                dTraRef[Rb, i, j, iD] := traRef[Ra, N + 1 - i, N + 1 - j, iD];
              end for;
            end for;
          end for;

          dAbs :=
            Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationNoShading(
            dTraRef,
            N,
            HEM) "Dummmy absorptance with exterior irradiation";

          // Only output hemispherical absorptance. Need to change order for interior irradiation.
          for i in 1:N loop
            absIntIrrNoSha[i] := dAbs[N + 1 - i, HEM];
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical absorptance of each glass pane for interior irradiation without no shading.
The angular irradiation is not considered since the interior irradiation (from the room) is assumed to be diffusive.
It is a reverse of the function
<a href=\"modelica://Buildings.HeatTransfer.Windows.Functions.glassAbsInterirorIrradiationNoShading\">
Buildings.HeatTransfer.Windows.Functions.glassAbsInterirorIrradiationNoShading</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 7, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsInteriorIrradiationNoShading;

        function glassProperty
          "Compute angular variation and hemispherical integration of the transmittance and reflectance for each glass pane without shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
          input Real glass[3, N] "Propertry of each glass pane";
          input Real xGla[N] "Thickness of each glass pane";
          input Modelica.SIunits.Angle psi[HEM - 1] "Incident angles";

          output Real layer[3, N, HEM]
            "Transmittance, front and back reflectance";

        protected
          parameter Real tol=0.005
            "Tolerance for difference between front and back reflectance to decide a glass is uncoated or coated";
          Real oneLay[3, HEM]
            "Temporary storage for glass property of one pane";
          Real oneGla[3];

        algorithm
          // Compute specular value for angle 0 to 90 degree (psi[1] to psi[N]) and panes from 1 to N
          for i in 1:N loop
            // Copy data to temporary place
            for j in 1:3 loop
              oneGla[j] := glass[j, i];
            end for;

            //uncoated galss
            if (abs(glass[Ra, i] - glass[Rb, i]) < tol) then
              oneLay := Buildings.HeatTransfer.Windows.Functions.glassPropertyUncoated(
                HEM,
                oneGla,
                xGla[i],
                psi);

            else
              //coated glass
              oneLay := Buildings.HeatTransfer.Windows.Functions.glassPropertyCoated(
                HEM,
                oneGla,
                psi);
            end if;

            for j in 1:3 loop
              for k in 1:HEM loop
                layer[j, i, k] := oneLay[j, k];
              end for;
            end for;
          end for;
          annotation (Documentation(info="<html>
<p>
This function computes the angular variation and the hemispherical integration of the transmittance and reflectance for each glass pane.
There are two schemes for the calculation. One is for coated glass and the other is for uncoated glass.
The function checks the difference between front and back reflectances.
If the difference is less than the tolerance (0.005), it uses the formula for uncoated glass.
Otherwise, the formula for coated glass will be used.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Calculate the property using formula for coated (existing) and uncoated glass (newly added).
</li>
<li>
August 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassProperty;

        function glassPropertyCoated
          "Compute angular variation and hemispherical integration of the transmittance and reflectance for a coated glass pane without shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialSingleGlassRadiation;
          input Real glass[3] "Propertry of one glass pane";
          input Modelica.SIunits.Angle psi[HEM - 1] "Incident angles";

          output Real layer[3, HEM] "Transmittance, front and back reflectance";

        protected
          constant Real a[4, 5]={{-0.0015,3.355,-3.840,1.460,0.0288},{0.999,-0.563,
              2.043,-2.532,1.054},{-0.002,2.813,-2.341,-0.05725,0.599},{0.997,-1.868,
              6.513,-7.862,3.225}} "Coeffcients in Table A.2";

          Integer NDIR "Number of incident angles";

          Real psi_c "cos(psi), psi is incident angle";
          Real psi_cs "cos(psi)*sin(psi)";
          Real angT "Angular variation of transmittance";
          Real angR "Angular variation of reflectance";
          Real f[3, HEM-1]
            "Temporary variables for integration in hemispherical transmittance and reflectance";
          Real deltaX;

          Integer id1 "Index of coefficients for transmittance";
          Integer id2 "Index of coefficients for reflectance";

        algorithm
          NDIR:=HEM - 1;
          deltaX := 0.5*Modelica.Constants.pi/(NDIR - 1);
          // Compute specular value for angle 0 to 90 degree (psi[1] to psi[N])
            for k in TRA:Rb loop
              layer[k, 1] := glass[k]
              "Copy the data at 0 degree (normal incidence)";
            end for;

            for j in 2:HEM-2 loop
              psi_c := Modelica.Math.cos(psi[j]);
               if layer[TRA, 1] > 0.645 then
                id1 := 1;
                id2 := 2;
              else
                id1 := 3;
                id2 := 4;
              end if;
              angT := a[id1, 1] + psi_c*(a[id1, 2] + psi_c*(a[id1, 3] + psi_c*(a[id1, 4]
                 + psi_c*a[id1, 5]))) "Equation (A.4.68a)";
              angR := a[id2, 1] + psi_c*(a[id2, 2] + psi_c*(a[id2, 3] + psi_c*(a[id2, 4]
                 + psi_c*a[id2, 5]))) - angT "Equation (A.4.68b)";
              layer[TRA, j] := layer[TRA, 1]*angT "Equation (A4.69a)";
              layer[Ra, j] := layer[Ra, 1]*(1 - angR) + angR
              "Equation (A4.69b)";
              layer[Rb, j] := layer[Rb, 1]*(1 - angR) + angR
              "Equation (A4.69b)";

            end for;

            layer[TRA, NDIR] := 0;
            layer[Ra, NDIR] := 1.0;
            layer[Rb, NDIR] := 1.0;

          // Computer hemispherical value: HEM.
            for j in 1:HEM-1 loop
              psi_cs := Modelica.Math.cos(psi[j])*Modelica.Math.sin(psi[j]);
              for k in TRA:Rb loop
                f[k, j] := 2*layer[k, j]*psi_cs;
              end for;
            end for;

            for k in TRA:Rb loop
              layer[k, HEM] :=
                Buildings.Utilities.Math.Functions.trapezoidalIntegration(
                NDIR,
                f[k, :],
                deltaX) "Equation (A.4.70a) and (A.4.70b)";
            end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation and the hemispherical integration of the transmittance and reflectance for one coated glass pane.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed use of <code>NDIR</code> for OpenModelica.
</li>
<li>
December 09, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassPropertyCoated;

        function glassPropertyUncoated
          "Compute angular variation and hemispherical integration of the transmittance and reflectance for a uncoated glass pane without shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialSingleGlassRadiation;

          input Real glass[3] "Propertry of one glass pane";
          input Modelica.SIunits.Length x "Thickness";
          input Modelica.SIunits.Angle psi[HEM - 1] "Incident angles";
          output Real layer[3, HEM] "Transmittance, front and back reflectance";

        protected
          Integer NDIR "Number of incident angles";
          Real psi_c "cos(psi), psi is incident angle in air";
          Real psi1_c "cos(psi1), psi1 is incident angle in glass";
          Real angT "Angular variation of transmittance";
          Real angR "Angular variation of reflectance";
          Real f[3, HEM-1]
            "Temporary variables for integration in hemispherical transmittance and reflectance";
          Real beta "Temporary coefficient defined in (7.2.1i)";
          Real rho0
            "Spectral reflectivity at incident angle of 0 degree at the interface";
          Real rho "Spectral reflectivity at the interface";
          Real rho1;
          Real rho2;
          Real tau "Spectral transmissivity at the interface";
          Real tau1;
          Real tau2;
          Real angT1;
          Real angT2;
          Real angR1;
          Real angR2;
          Real tmp;
          Real alpha "Spectral absorption coefficient defined in (7.2.1e)";
          Real n
            "Ratio of spectral index of refraction of glass to the index of refraction of air";
          Real psi1 "The angle od incident angle in glass";
          Real deltaX;

        algorithm
          // Check the data
          assert(glass[TRA] >= 0,
            "Glass property is not correct with solar transmittance less than 0");
          assert(glass[Ra] >= 0,
            "Glass property is not correct with solar reflectance less than 0");
          assert(glass[TRA] + glass[Ra] <= 1,
            "Glass property is not correct since the summation of solar reflectance and transmittance is larger than 1");

          NDIR := HEM-1;
          deltaX := 0.5*Modelica.Constants.pi/(NDIR-1);
          // Compute specular value for angle 0 to 90 degree (psi[1] to psi[N])
          for k in TRA:Rb loop
            layer[k, 1] := glass[k]
              "Copy the data at 0 degree (normal incidence)";
          end for;

          beta := glass[TRA]^2 - glass[Ra]^2 + 2*glass[Ra] + 1 "(2)";

          tmp := beta^2 - 4*(2 - glass[Ra])*glass[Ra] "part of (1)";
          assert(tmp >= 0,
            "Glass property is wrong. It is not possible to calculate the spectral reflectivity at 0 degree for uncoated glass.");

          rho0 := 0.5*(beta - sqrt(tmp))/(2 - glass[Ra]) "(1)";
          assert(rho0 >= 0,
            "Glass property is wrong. The spectral reflectivity at 0 degree for uncoated glass is less than zero.");

          tmp := (glass[Ra] - rho0)/(rho0*glass[TRA]) "part of (3)";
          assert(tmp > 0,
            "Glass property is wrong. It is not possible to calculate the spectral extinction coefficient for uncoated glass.");

          alpha := -log(tmp)/x "(3)";
          tmp := sqrt(rho0);
          assert(tmp <> 1,
            "Glass property is wrong. It is not possible to calculate the spectral index of refraction for uncoated glass.");
          n := (1 + tmp)/(1 - tmp) "(4)";

          for j in 2:HEM-2 loop
            psi1 := asin(sin(psi[j])/n) "(5)";
            psi_c := cos(psi[j]);
            psi1_c := cos(psi1);

            rho1 := ((n*psi_c - psi1_c)/(n*psi_c + psi1_c))^2 "(6)";
            rho2 := ((n*psi1_c - psi_c)/(n*psi1_c + psi_c))^2 "(7)";

            tau1 := 1 - rho1 "(8)";
            tau2 := 1 - rho2 "(9)";

            tmp := exp(-alpha*x/psi1_c);

            angT1 := tau1^2*tmp/(1 - rho1^2*tmp^2) "(10)";
            angR1 := rho1*(1 + angT1*tmp) "(13)";
            angT2 := tau2^2*tmp/(1 - rho2^2*tmp^2) "(11)";
            angR2 := rho2*(1 + angT2*tmp) "(14)";

            layer[TRA, j] := 0.5*(angT1 + angT2) "Tansmittance in (12)";
            layer[Ra, j] := 0.5*(angR1 + angR2) "Front reflectance (15)";
            layer[Rb, j] := layer[Ra, j] "Back reflectance in (15)";
          end for;

          // When incident angle is equal to 90 degree
          layer[TRA, NDIR] := 0 "(16)";
          layer[Ra, NDIR] := 1.0 "(16)";
          layer[Rb, NDIR] := 1.0 "(16)";

          // Computer hemispherical value: HEM.
          for j in 1:HEM-1 loop
            for k in TRA:Rb loop
              f[k, j] := 2*layer[k, j]*Modelica.Math.cos(psi[j])*Modelica.Math.sin(psi[
                j]);
            end for;
          end for;

          for k in TRA:Rb loop
            layer[k, HEM] := Buildings.Utilities.Math.Functions.trapezoidalIntegration(
              NDIR,
              f[k, :],
              deltaX)
              "Equation (A.4.70a) and (A.4.70b) in M. Wetter 's Thesis or (7.3) in Finlayson 1993.";
          end for
        annotation (Documentation(info="<html>
<p>
This function computes the angular variation and the hemispherical integration of the transmittance and reflectance for one uncoated glass pane.
The equations are mainly based on Finlayson et al. (1990) and Fuler et al. (1991) with some modifications.
</p>
<h4>Implementation</h4>
<p>
Step 1: Compute the reflectivity at normal incidence
</p>
<table summary=\"summary\">
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
   &rho;(0) = {&beta; &minus; sqrt[&beta;<sup>2</sup> &minus; 4(2 &minus; R(0))R(0)]}
      &frasl;
   [2(2&minus;R(0))],
</p></td>
<td>(1)</td>
</tr>
</table>
where
<table summary=\"summary\">
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
  &beta; = T(0)<sup>2</sup> &minus; R(0)<sup>2</sup> + 2R(0) + 1.
</p></td>
<td>(2)</td>
</tr>
</table>

<p>
Step 2: Compute the spectral absorption coefficient &alpha; and spectral index of refraction n
</p>
<table summary=\"summary\">
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
  &alpha; = 4 &pi; &kappa;<sub>&lambda;</sub> &frasl;  &lambda;
  = - ln[(R(0) &minus; &rho;(0)) &frasl; (&rho;(0)T(0))] &frasl; d,
</p></td>
<td>(3)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
  n = (1 + sqrt(&rho;(0)) &frasl;
        (1 &minus; sqrt(&rho;(0))).
</p></td>
<td>(4)</td>
</tr>
</table>

<p>
Step 3: For each angle of incidence measured in air &phi; (0 &lt; &phi; &lt; 90)
</p>
<table summary=\"summary\">
<tr>
<td> a. Compute the angle of incidence measured in glass &phi;'</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
  &phi;' = asin(sin&phi; &frasl;  n).
</p></td>
<td>(5)</td>
</tr>
<tr>
<td> b. Compute spectral reflectivities at surface</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
&rho;<sub>1</sub>(&phi;)=[(n cos&phi; &minus; cos&phi;') &frasl;
(n cos&phi; + cos&phi;')] <sup>2</sup>,
</p></td>
<td>(6)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
&rho;<sub>2</sub>(&phi;)=[(n cos&phi;' &minus; cos&phi;) &frasl;
(n cos&phi;' + cos&phi;)] <sup>2</sup>.
</p></td>
<td>(7)</td>
</tr>
<tr>
<td>c. Compute spectral tansmissivities at surface</td>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
&tau;<sub>1</sub>(&phi;)= 1 &minus; &rho;<sub>1</sub>(&phi;),
</p></td>
<td>(8)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
&tau;<sub>2</sub>(&phi;)= 1 &minus; &rho;<sub>2</sub>(&phi;).
</p></td>
<td>(9)</td>
</tr>
<tr>
<td>d. Compute spectral tansmittance of the glass</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
T<sub>1</sub>(&phi;)= &tau;<sub>1</sub>(&phi;)<sup>2</sup> exp(-&alpha; d/cos&phi;') &frasl;
(1 &minus; &rho;<sub>1</sub>(&phi;)<sup>2</sup> exp(-2&alpha; d/cos&phi;')),
</p></td>
<td>(10)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
T<sub>2</sub>(&phi;)= &tau;<sub>2</sub>(&phi;)<sup>2</sup> exp(-&alpha; d/cos&phi;') &frasl;
(1 &minus; &rho;<sub>2</sub>(&phi;)<sup>2</sup> exp(-2&alpha; d/cos&phi;')),
</p></td>
<td>(11)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
T(&phi;)= (T<sub>1</sub>(&phi;) + T<sub>2</sub>(&phi;)) / 2.
</p></td>
<td>(12)</td>
</tr>
<tr>
<td>e. Compute spectral reflectance of the glass</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
R<sub>1</sub>(&phi;)= &rho;<sub>1</sub>(&phi;)(1+ T<sub>1</sub>(&phi;)exp(-&alpha; d/cos&phi;')),
</p></td>
<td>(13)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
R<sub>2</sub>(&phi;)= &rho;<sub>2</sub>(&phi;)(1+ T<sub>2</sub>(&phi;)exp(-&alpha; d/cos&phi;')),
</p></td>
<td>(14)</td>
</tr>
<tr>
<td><p align=\"center\" style=\"font-style:italic;\">
R(&phi;)= (R<sub>1</sub>(&phi;) + R<sub>2</sub>(&phi;)) / 2.
</p></td>
<td>(15)</td>
</tr>
</table>
<p>
Step 4: T(90)=0, R(90)=1. (16)

<h4>Limitations</h4>
WINDOW program calculates the angular property for each wave length based on the spectral data.
It uses different <code>R<sub>&lambda;</sub>(0)</code> and <code>T<sub>&lambda;</sub>(0)</code> for each wave length.
Then it integrates the properties over the wave length to get averaged property of <code>R(0)</code> and <code>T(0)</code>.
<p>
The current window model in the Buildings library uses averaged <code>R(0)</code> and <code>T(0)</code> directly.
It can generate the same results as WINDOW for a single pane window and multi-pane window with the same glass.
However, the results may be slightly different for multi-pane window with different glasses.
The reason is that different glasses may have different angular properties for the same wave length.
To precisely calculate the angular properties of the entire window system, one has to calculate the property for each wave length and integrate them as WINDOW does.
For more details, see the paper of Nouidui et al. (2012).

<h4>References</h4>
<p>
Finlayson, E. U., D. K. Arasteh, C. Huizenga, M.D. Rubin, M.S. Reily. 1993. WINDOW 4.0: Documentation of Calcualtion Precedures. <i>Technical Report LBL-33943</i>. Lawrence Berkeley National Laboratory.
</p>
<p>
Fuler, Reto A., Angular dependence of optical properties of homogeneous glasses, <i>ASHRAE Transaction</i>, V.97 Part 2, 1991.
</p>
<p>
Thierry Stephane Nouidui, Michael Wetter, and Wangda Zuo.
<a href=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/2012-simBuild-windowValidation.pdf\">
Validation of the window model of the Modelica Buildings library.</a>
<i>Proc. of the 5th SimBuild Conference</i>, Madison, WI, USA, August 2012.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed use of <code>NDIR</code> for OpenModelica.
</li>
<li>
August 06, 2012, by Wangda Zuo:<br/>
Improved the documentation for implementation and added comments for model limitations.
</li>
<li>
December 09, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));

        end glassPropertyUncoated;

        function glassTRExteriorIrradiationNoShading
          "Transmittance and reflectance of glass panes for exterior irradiation without shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
          input Real layer[3, N, HEM] "Angular data of glass pane";
          output Real traRef[3, N, N, HEM](each min=0, each max=1)
            "Transmittance and reflectance of each glass pane for exterior irradiation without shading";

        protected
          Real aij "Temporary variable";
          constant Real SMALL=Modelica.Constants.small "Small value";

        algorithm
          // Property for single pane of glass or the first pane of multiple panes glass
          for iD in 1:HEM loop
            for k in TRA:Rb loop
              traRef[k, 1, 1, iD] := layer[k, 1, iD] "Equation (A.4.71)";
            end for;
          end for;

          // Property for multiple panes glass
          if N > 1 then
            for iD in 1:HEM loop
              for i in 1:N - 1 loop
                for j in i + 1:N loop
                  for k in TRA:Rb loop
                    traRef[k, j, j, iD] := layer[k, j, iD];
                  end for;

                  aij := 1 - traRef[Ra, j, j, iD]*traRef[Rb, j - 1, i, iD]
                    "Equation (A.4.77)";
                  assert(aij > -SMALL,
                    "Glass transmittance and reflectance data was not correct.\n");
                  if aij < SMALL then
                    traRef[TRA, i, j, iD] := 0;
                    traRef[Ra, i, j, iD] := 1;
                    traRef[Rb, j, i, iD] := 1;
                  else
                    aij := 1/aij;
                    traRef[TRA, i, j, iD] := aij*traRef[TRA, i, j - 1, iD]*traRef[TRA,
                      j, j, iD] "Equation (A.4.78a)";
                    traRef[Ra, i, j, iD] := traRef[Ra, i, j - 1, iD] + aij*traRef[TRA,
                      i, j - 1, iD]*traRef[TRA, i, j - 1, iD]*traRef[Ra, j, j, iD]
                      "Equation (A.4.78b)";
                    traRef[Rb, j, i, iD] := traRef[Rb, j, j, iD] + aij*traRef[TRA, j, j,
                      iD]*traRef[TRA, j, j, iD]*traRef[Rb, j - 1, i, iD]
                      "Equation (A.4.78c)";
                  end if;
                end for;
              end for;
            end for;
          end if;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation of the transmittance and reflectance of each glass pane for exteior irradiation without shading.
It accounts for the transmittance and reflectance among different panes.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassTRExteriorIrradiationNoShading;

        function glassTRInteriorIrradiationNoShading
          "Transmittance and reflectance of each glass pane for interior irradiation without shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
          input Real layer[3, N, HEM] "Angular data of glass pane";
          output Real traRef[3, N, N, HEM](each min=0, each max=1)
            "Glass transmittance, front and back reflectance";

        protected
          Real dLayer[3, N, HEM]
            "Dummy glass property with Pane 1 facing inside and Pane N facing outside";
          Real dTraRef[3, N, N, HEM]
            "Dummy transmittance and reflectance for exterior irradiation";

        algorithm
          // Copy the dummy glass property
          for iD in 1:HEM loop
            for j in 1:N loop
              dLayer[TRA, j, iD] := layer[TRA, N + 1 - j, iD];
              dLayer[Ra, j, iD] := layer[Rb, N + 1 - j, iD]
                "swap the front and back reflectance";
              dLayer[Rb, j, iD] := layer[Ra, N + 1 - j, iD]
                "swap the front and back reflectance";
            end for;
          end for;

          // Calculate transmittance and reflectance of dummy glass for exterior irradiation without shading
          dTraRef :=
            Buildings.HeatTransfer.Windows.Functions.glassTRExteriorIrradiationNoShading(
            N,
            HEM,
            dLayer);

          // Convert the dummy data to real glass
          for iD in 1:HEM loop
            for i in 1:N - 1 loop
              for j in i + 1:N loop
                traRef[TRA, N + 1 - i, N + 1 - j, iD] := dTraRef[TRA, i, j, iD];
                traRef[Ra, N + 1 - i, N + 1 - j, iD] := dTraRef[Rb, i, j, iD]
                  "swap the front and back reflectance";
                traRef[Rb, N + 1 - i, N + 1 - j, iD] := dTraRef[Ra, i, j, iD]
                  "swap the front and back reflectance";
              end for;
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation of the transmittance and reflectance of each glass pane for interior irradiation without shading.
It accounts for the transmittance and reflectance among different panes.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end glassTRInteriorIrradiationNoShading;

        function winTExteriorIrradiationInteriorShading
          "Angular and hemispherical transmittance of a window system (glass and shading device) for exterior irradiation with interior shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real traExtIrrIntSha[HEM](each min=0, each max=1)
            "Angular and hemispherical transmittance of a window system (glass and shading device) forh exterior irradiation with interior shading";

        algorithm
          for iD in 1:HEM loop
            traExtIrrIntSha[iD] := traRef[TRA, 1, N, iD]*traIntShaDev/(1 - refIntShaDev
              *traRef[Rb, N, 1, HEM]) "Equation (A.4.92)";
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular and hemispherical transmittance of a window system (glass and shading device) for exterior irradiation with interior shading.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end winTExteriorIrradiationInteriorShading;

        function winTExteriorIrradiatrionExteriorShading
          "Angular and hemispherical transmittance of a window system (glass + shading device) for exterior irradiation with exterior shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;
          output Real traExtIrrExtSha[HEM](each min=0, each max=1)
            "Angular and hemispherical transmittance of a window system (glass + shading device) for exterior irradiation with exterior shading";

        protected
          Real c;

        algorithm
          for iD in 1:HEM loop
            c := traExtShaDev*(1 + traRef[Ra, 1, N, iD]*refExtShaDev/(1 - traRef[Ra, 1,
              N, HEM]*refExtShaDev)) "Equation (A.4.88a)";
            traExtIrrExtSha[iD] := c*traRef[TRA, 1, N, iD] "Equation (A.4.88c)";
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular and hemispherical transmittance of a window system (glass + shading device) for exterior irradiation with exterior shading.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end winTExteriorIrradiatrionExteriorShading;

        function winTRInteriorIrradiationExteriorShading
          "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with exterior shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;
          output Real traRefIntIrrExtSha[3](each min=0, each max=1)
            "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with exterior shading";
        algorithm
          traRefIntIrrExtSha[TRA] := traRef[TRA, N, 1, HEM]*traExtShaDev/(1 -
            refExtShaDev*traRef[Ra, 1, N, HEM]) "Equation (A.4.95)";
          traRefIntIrrExtSha[Rb] := traRef[Rb, N, 1, HEM] + traRef[TRA, N, 1, HEM]*
            refExtShaDev*traRef[1, 1, N, HEM]/(1 - traRef[Ra, 1, N, HEM]*refExtShaDev)
            "Equation (A.4.97)";
          traRefIntIrrExtSha[Ra] := 0 "Dummy value";
          annotation (Documentation(info="<html>
This function computes hemispherical transmittance and back reflectance of a window for interior irradiation with exterior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
The variables are<br/>
<pre>
traRefIntIrrExtSha[1]: Transmittance;
traRefIntIrrExtSha[2]: Back reflectance;
traRefIntIrrExtSha[3]: Dummy value
</pre>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end winTRInteriorIrradiationExteriorShading;

        function winTRInteriorIrradiationInteriorShading
          "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with interior shading"
          extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real traRefIntIrrIntSha[3](each min=0, each max=1)
            "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with interior shading";

        protected
          constant Real rRho=traRef[Rb, N, 1, HEM]*refIntShaDev
            "Part of Equation (A.4.99)";
          constant Real rTau=traRef[Rb, N, 1, HEM]*traIntShaDev
            "Part of Equation (A.4.105)";
          constant Real c=traIntShaDev*(1 + rRho/(1 - rRho))
            "Equation (A.4.99)";

        algorithm
          traRefIntIrrIntSha[TRA] := c*traRef[TRA, N, 1, HEM]
            "Equation (A.4.100b)";
          traRefIntIrrIntSha[Rb] := refIntShaDev + c*rTau "Equation (A.4.105)";
          traRefIntIrrIntSha[Ra] := 0 "Dummy value";

          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with interior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end winTRInteriorIrradiationInteriorShading;

        package BaseClasses
          "Package with base classes for Buildings.HeatTransfer.Windows.Functions"
          extends Modelica.Icons.BasesPackage;

          partial function partialSingleGlassRadiation
            "Partial function for single glass radiation property"

            input Integer HEM "Index of hemispherical integration";
          protected
            constant Integer TRA=1 "Index of Transmittance";
            constant Integer Ra=2
              "Index of front reflectance (outside facing side)";
            constant Integer Rb=3
              "Index of back reflectance (room-facing side)";

            annotation (preferredView="info",
            Documentation(info="<html>
This is a partial function that is used to implement the radiation functions for windows. It defines basic constants.
</html>",           revisions="<html>
<ul>
<li>
September 16 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
          end partialSingleGlassRadiation;

          partial function partialGlassRadiation
            "Partial function for glass radiation property"

            input Integer N(min=1) "Number of glass layers";
            extends
              Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialSingleGlassRadiation;
            annotation (preferredView="info", Documentation(info="<html>
This is a partial function that is used to implement the radiation functions for windows. It defines basic input variables and constants.
</html>",           revisions="<html>
<ul>
<li>
December 19 2011, by Wangda Zuo:<br/>
Separate part of defintions to particalSingleGlassRadiation.mo.
</li>
</ul>
<ul>
<li>
September 16 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
          end partialGlassRadiation;

          partial function partialWindowRadiation
            "Partial function for window radiation property"
            input Real traRef[3, N, N, HEM](each min=0, each max=0)
              "Transmittance and reflectance with exterior irradiation and no shading";
            extends
              Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;

            annotation (preferredView="info",
            Documentation(info="<html>
This is a partial function that is used to implement the radiation functions for windows. It defines basic input variables and constants.
</html>",           revisions="<html>
<ul>
<li>
September 16 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
          end partialWindowRadiation;

          partial function partialWindowShadingRadiation
            "Partial function for window radiation property with shading device"
            input Real traRef[3, N, N, HEM](each min=0, each max=1)
              "Transmittance and reflectance with exterior irradiation and no shading";
            input Real traRefShaDev[2, 2](each min=0, each max=1)
              "Transmittance and reflectance of shading device";
            extends
              Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
          protected
            Real traExtShaDev=traRefShaDev[1, 1]
              "Transmittance of the exterior shading device";
            Real refExtShaDev=traRefShaDev[2, 1]
              "Reflectance of the exterior shading device";
            Real traIntShaDev=traRefShaDev[1, 2]
              "Transmittance of the interior shading device";
            Real refIntShaDev=traRefShaDev[2, 2]
              "Reflectance of the interior shading device";
            annotation (preferredView="info",
            Documentation(info="<html>
This is a partial function that is used to implement the radiation functions for windows. It defines basic input variables and parameters.
</html>",           revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Corrected wrong <code>max</code> value for <code>traRef</code> and
<code>traRefShaDev</code>.
</li>
<li>
September 16 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
          end partialWindowShadingRadiation;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Windows.Functions\">Buildings.HeatTransfer.Windows.Functions</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions that are used to compute
heat transfer in the window model.
</p>
</html>"));
      end Functions;
      annotation (
    preferredView="info", Documentation(info="<html>
<p>
This package contains models for heat transfer in windows.
</p>
</html>"));
    end Windows;

    package Data "Data for heat transfer models"
        extends Modelica.Icons.MaterialPropertiesPackage;

      package Gases
        "Package with thermophysical properties for window fill gases"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of fill gas for windows"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.Length x "Gas layer thickness";
            parameter Modelica.SIunits.ThermalConductivity a_k
            "Constant coefficient for thermal conductivity";
            parameter Real b_k(unit="W/(m.K2)")
            "Temperature dependent coefficient for thermal conductivity";
            parameter Modelica.SIunits.DynamicViscosity a_mu
            "Constant coefficient for dynamic viscosity";
            parameter Real b_mu(unit="N.s/(m2.K)")
            "Temperature dependent coefficient for dynamic viscosity";
            parameter Modelica.SIunits.SpecificHeatCapacity a_c
            "Constant coefficient for specific heat capacity";
            parameter Real b_c(unit="J/(kg.K2)")
            "Temperature dependent coefficient for specific heat capacity";

            parameter Modelica.SIunits.MolarMass MM
            "Molar mass (of mixture or single fluid)";

            parameter Modelica.SIunits.Pressure P0 = 101325 "Normal pressure";

          annotation (defaultComponentName="gas", Documentation(info=
                         "<html>
Generic record for thermophysical properties for window
gas fills.
The implementation is according to
<a href=\"http://www.iso.org/iso/catalogue_detail.htm?csnumber=26425\">ISO 15099:2003,
Thermal performance of windows, doors and shading devices -- Detailed calculations</a>.
</html>",
        revisions="<html>
<ul>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed <code>P0</code> from a <code>constant</code> to a
<code>parameter</code> to avoid a compilation error in
OpenModelica.
</li>
<li>
August 18 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record Air = Generic(a_k= 2.873E-3, b_k= 7.760E-5,
                             a_mu=3.723E-6, b_mu=4.940E-8,
                             a_c=1002.737,  b_c= 1.2324E-2,
                             MM=28.97E-3) "Thermophysical properties for air";

       function thermalConductivity
          "Function to compute the thermal conductivity of gases"
        input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.ThermalConductivity k "Thermal conductivity";
       algorithm
        k := gas.a_k + gas.b_k*T;
       end thermalConductivity;

      function density "Function to compute the mass density"
        input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.Density rho "Mass density";
      algorithm
          rho := gas.P0*gas.MM/Modelica.Constants.R/T;
      end density;

      function dynamicViscosity
          "Function to compute the dynamic viscosity for gases"
        input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.DynamicViscosity mu "Dynamic viscosity";
      algorithm
          mu := gas.a_mu + gas.b_mu*T;
      end dynamicViscosity;

      function specificHeatCapacity
          "Function to compute the specific heat capacity for gases"
        input Buildings.HeatTransfer.Data.Gases.Generic gas
            "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.SpecificHeatCapacity c_p
            "Specific heat capacity";
      algorithm
        c_p := gas.a_c + gas.b_c*T;
      end specificHeatCapacity;
        annotation (Documentation(info="<html>
Package with records for thermophysical properties for window
gas fills.
The implementation is according to
<a href=\"http://www.iso.org/iso/catalogue_detail.htm?csnumber=26425\">ISO 15099:2003,
Thermal performance of windows, doors and shading devices -- Detailed calculations</a>.
</html>",
        revisions="<html>
<ul>
<li>
August 18 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Gases;

      package Glasses "Package with thermophysical properties for window glas"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of window glass"
            extends Modelica.Icons.Record;
         parameter Modelica.SIunits.Length x=0.003 "Thickness";
         parameter Modelica.SIunits.ThermalConductivity k=1
            "Thermal conductivity";
         parameter Modelica.SIunits.TransmissionCoefficient tauSol = 0.6
            "Solar transmittance";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_a = 0.075
            "Solar reflectance of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_b = 0.075
            "Solar reflectance of surface b (usually room-facing surface)";
         parameter Modelica.SIunits.TransmissionCoefficient tauIR = 0
            "Infrared transmissivity of glass";
         parameter Modelica.SIunits.Emissivity absIR_a = 0.84
            "Infrared absorptivity of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.Emissivity absIR_b = 0.84
            "Infrared absorptivity of surface b (usually room-facing surface)";
          annotation (defaultComponentName="gla", Documentation(info=
                         "<html>
<p>
This record implements thermophysical properties for window glas.
</p>
<p>
The table below compares the data of this record with the variables used in the WINDOW 6 output file.
</p>
Note that
<ul>
<li>the surface <code>a</code> is usually the outside-facing surface, and the surface
<code>b</code> is usually the room-facing surface.
</li>
<li>by the term <i>solar</i>, we mean the whole solar spectrum.
Data in the solar spectrum are used for computing solar heat gains.
</li>
<li>by the term <i>infrared</i> (or <i>infrared</i>), we mean the infrared spectrum.
Data in the infrared spectrum are used for thermal radiation that is emitted by surfaces that are
around room or ambient temperature.
</li>
<li>WINDOW 6 uses spectral data in the calculation of optical properties of window systems,
whereas the model in this library uses averages over the whole solar or infrared spectrum.
</li>
</ul>

<table summary=\"summary\" border=\"1\">
<thead>
 <tr>
   <th>Buildings library variable name</th>
   <th>WINDOW 6 variable name</th>
 </tr>
</thead>
<tbody>
<tr>
  <td>tauSol</td>  <td>Tsol</td>
</tr>
<tr>
  <td>rhoSol_a</td>  <td>Rsol1</td>
</tr>
<tr>
  <td>rhoSol_b</td>  <td>Rsol2</td>
</tr>
<tr>
  <td>tauIR</td>  <td>Tir</td>
</tr>
<tr>
  <td>absIR_a</td>  <td>Emis1</td>
</tr>
<tr>
  <td>absIR_b</td>  <td>Emis2</td>
</tr>
</tbody>
</table>

</html>",
        revisions="<html>
<ul>
<li>
December 09, 2011, by Wangda Zuo:<br/>
Compare the variable names with those in Window 6 and correct the variable names <i>Emis1</i> and <i>Emis2</i> in documentation.
</li>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record ID102 =   Buildings.HeatTransfer.Data.Glasses.Generic (
            x=0.003,
            k=1.0,
            tauSol=0.834,
            rhoSol_a=0.075,
            rhoSol_b=0.075,
            tauIR=0,
            absIR_a=0.84,
            absIR_b=0.84) "Generic Clear Glass 3.048mm. Manufacturer: Generic.";
        annotation(preferredView="info",
                  Documentation(info="<html>
<p>
This package implements thermophysical properties for window glas.
</p>
<p>
Since the infrared transmissivity is part of the Window 5 data and since
it depends on the glass thickness, the glass thickness is a parameter
that is set for all glass layers.
This configuration is different from the records fo gas properties,
which do not yet set the value for the thickness of the gas gap.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Glasses;

      package Shades "Package with thermophysical properties for window shades"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of window shades"
            extends Modelica.Icons.Record;
         parameter Modelica.SIunits.TransmissionCoefficient tauSol_a=0.1
            "Solar transmissivity of shade surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.TransmissionCoefficient tauSol_b=0.1
            "Solar transmissivity of shade surface b (surface that faces the glass)";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_a=0.8
            "Solar reflection coefficient of shade surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_b=0.8
            "Solar reflection coefficient of shade surface b (surface that faces the glass)";
         parameter Modelica.SIunits.Emissivity absIR_a=0.84
            "Infrared absorptivity of surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.Emissivity absIR_b=0.84
            "Infrared absorptivity of surface b (surface that faces the glass)";
         parameter Modelica.SIunits.TransmissionCoefficient tauIR_a=0
            "Infrared transmissivity of surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.TransmissionCoefficient tauIR_b=0
            "Infrared transmissivity of surface b (surface that faces the glass)";

          annotation (defaultComponentName="sha", Documentation(info=
                                     "<html>
Records that implements thermophysical properties for window shades.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;
      annotation (Documentation(info="<html>
Package with records that implement thermophysical properties for window shades.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),         preferredView="info",
                  Documentation(info="<html>
This package implements thermophysical properties for window shades.
</html>"));
      end Shades;

      package GlazingSystems
        "Package with thermophysical properties for glazing systems"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of glazing systems"
            extends Modelica.Icons.Record;
          parameter Integer nLay(min=1, fixed=true) "Number of glass layers"
            annotation (Evaluate=true);
          parameter Boolean haveExteriorShade = false
            "Set to true if window has an exterior shade (at surface a)"
            annotation (Evaluate=true);
          parameter Boolean haveInteriorShade = false
            "Set to true if window has an interior shade (at surface b)"
            annotation (Evaluate=true);

          parameter Glasses.Generic glass[nLay]
            "Layer by layer declaration of glass layers, starting from outside to room-side"
            annotation (choicesAllMatching=true, Placement(transformation(extent={{60,60},{80,80}})));
          parameter Gases.Generic gas[nLay-1]
            "Layer by layer declaration of glass layers, starting from outside to room-side"
            annotation (choicesAllMatching=true, Placement(transformation(extent={{60,20},
                    {80,40}})));
          parameter Shades.Generic shade "Shade"
            annotation (choicesAllMatching=true,
            Dialog(enable=haveInteriorShade or haveExteriorShade));
          parameter Modelica.SIunits.CoefficientOfHeatTransfer UFra
            "U-value of frame";
          parameter Modelica.SIunits.Emissivity absIRFra=0.8
            "Infrared absorptivity of window frame";
          parameter Modelica.SIunits.Emissivity absSolFra=0.5
            "Solar absorptivity of window frame";
          final parameter Boolean haveShade = haveInteriorShade or haveExteriorShade
            "Parameter that is true if the construction has a shade";

          annotation (defaultComponentName="glaSys", Documentation(info=
                         "<html>
Generic record that implements thermophysical properties for glazing systems.
</html>",
        revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
July 15, 2013, by Michael Wetter:<br/>
Removed parameter <code>windowHasShade</code> which is redundant with <code>haveShade</code>.
</li>
<li>
Sep. 3 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record SingleClear3 =
            Buildings.HeatTransfer.Data.GlazingSystems.Generic (
               glass={Glasses.ID102()},
               UFra=3,
               final nLay=1) "Single pane, clear glass 3mm";
      annotation (preferredView="info",
      Documentation(info="<html>
Package with generic records that implement thermophysical properties for glazing systems.
</html>",
        revisions="<html>
<ul>
<li>
May 15, 2013, by Michael Wetter:<br/>
In <a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems.DoubleClearAir13Clear\">
Buildings.HeatTransfer.Data.GlazingSystems.DoubleClearAir13Clear</a>,
corrected the glass layer thickness, which was <i>5.7</i> mm instead of
<i>3</i> mm, as the documentation states.
</li>
<li>
Sep. 3 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end GlazingSystems;

      package Solids
        "Package with solid material, characterized by thermal conductance, density and specific heat capacity"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of solids with heat storage"
            extends Buildings.HeatTransfer.Data.BaseClasses.Material(final R=x/k,
                                                                     final TSol=293.15,
                                                                     final TLiq=293.15,
                                                                     final LHea=0,
                                                                     final phasechange=false);
          annotation (defaultComponentName="mat", Documentation(info=
           "<html>
<p>
Generic record for solid materials.
The material is characterized by its
thermal conductivity, mass density and specific
heat capacity.
</p>
</html>",       revisions=
                "<html>
<ul>
<li>
September 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record Brick = Buildings.HeatTransfer.Data.Solids.Generic (
            k=0.89,
            d=1920,
            c=790) "Brick (k=0.89)";
        annotation (
      Documentation(
      info="<html>
<p>
Package with records for solid materials.
The material is characterized by its
thermal conductivity, mass density and specific
heat capacity.
</p>
<p>
These material records automatically compute the spatial grid
that is used to compute transient heat conduction.
In building materials, the thermal diffusivity of adjacent layer materials can differ by an order of magnitude. If the spatial grid generation were not to account for the material properties, then the time rate of change of the different temperature nodes would be significantly different from each other.
Therefore, records in the packages
<a href=\"Buildings.HeatTransfer.Data.Solids\">
Buildings.HeatTransfer.Data.Solids</a>
and
<a href=\"Buildings.HeatTransfer.Data.SolidsPCM\">
Buildings.HeatTransfer.Data.SolidsPCM</a>
generate the spatial grid so that under the assumption of equal heat transfer, each node temperature has a similar time rate of change.
</p>
<p>
The computation is as follows:
</p>
<p>
From dimensionless analysis, one can obtain a characteristic time, called the <em>Fourier</em> number, as
</p>
<p align=\"center\" style=\"font-style:italic;\">
Fo = &alpha; t &frasl; L<sup>2</sup>
</p>
<p>
where <i>&alpha;</i> denotes the thermal diffusivity, <i>t</i> denotes time and <i>L</i> denotes the characteristic length.
We like to generate the spatial grid so that the ratio
<i>t &frasl; Fo</i>
is equal to an arbitrary constant
<i>&Pi;</i>, which we define as
</p>
<p align=\"center\" style=\"font-style:italic;\">
&Pi; = ( t &frasl; Fo )<sup>1/2</sup>
</p>

<p>and hence</p>

<p align=\"center\" style=\"font-style:italic;\">
&Pi; = L &frasl; &radic; &alpha;.
</p>

<p>
Now, let <i>x</i>
denote the thickness of the material layer.
Then, we compute the time constant of the material layer as
</p>
<p align=\"center\" style=\"font-style:italic;\">
&Pi;<sub>x</sub> = x &frasl; &radic; &alpha;,
</p>
<p>
and we compute the estimated number of elements <i>N' &isin; &#8477;</i>
for the material layer as</p>

<p align=\"center\" style=\"font-style:italic;\">
N' = N<sub>ref</sub> &Pi;<sub>x</sub> &frasl; &Pi;<sub>ref</sub>
</p>

<p>
where <i>&Pi;<sub>ref</sub> &isin; &#8469;</i> is a user-specified number of elements
for a reference material, which is equal to the parameter
<code>nStaRef</code>, and defined as a concrete construction with thickness
<i>L<sub>ref</sub> = 0.20</i> meter and thermal diffusivity
<i>&alpha;<sub>ref</sub> = 3.64E-7</i> m<sup>2</sup>/s.
Hence,
<i>&Pi;<sub>ref</sub> = L<sub>ref</sub>/ &radic; &alpha;<sub>ref</sub> = 331.4</i>
&radic;s.
</p>

<p>
Next, we define the number of elements for the material layer as
<p align=\"center\" style=\"font-style:italic;\">
<i>N<sub>x</sub> = &lceil;  N' &rceil;</i>
</p>

<p>
where the notation <i>&lceil; &#8901; &rceil;</i> is defined, for
<i>s &isin; &#8477;</i>, as
<p align=\"center\" style=\"font-style:italic;\">
&lceil; s &rceil; = min{ k &isin; &#8484; | k &ge; s }.
</p>
<p>
Finally, we divide the material layer in compartments of length
<i>&Delta; = x &frasl; N<sub>x</sub></i>.
</p>

</html>",
      revisions="<html>
<ul>
<li>
September 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Solids;

      package OpaqueConstructions
        "Package with opaque constructions for floors, walls, etc."
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of opaque constructions"

         parameter Integer nLay(min=1) "Number of layers";

          parameter Buildings.HeatTransfer.Data.BaseClasses.Material material[nLay]
            "Layer by layer declaration of material, starting from outside to room-side"
            annotation (choicesAllMatching=true, Evaluate=false, Placement(transformation(extent={{60,60},{80,80}})));
         final parameter Real R(unit="m2.K/W")=sum(material[i].R for i in 1:nLay)
            "Thermal resistance per unit area";

         parameter Modelica.SIunits.Emissivity absIR_a=0.9
            "Infrared absorptivity of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.Emissivity absIR_b=0.9
            "Infrared absorptivity of surface b (usually room-facing surface)";
         parameter Modelica.SIunits.Emissivity absSol_a=0.5
            "Solar absorptivity of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.Emissivity absSol_b=0.5
            "Solar absorptivity of surface b (usually room-facing surface)";
         parameter Buildings.HeatTransfer.Types.SurfaceRoughness roughness_a=
            Buildings.HeatTransfer.Types.SurfaceRoughness.Medium
            "Exterior surface roughness";

          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,50},{100,-100}},
                  lineColor={0,0,255},
                  fillColor={255,255,85},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-54,42},{-36,-92}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Forward),
                Rectangle(
                  extent={{4,42},{54,-92}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.CrossDiag),
                Text(
                  extent={{-127,113},{127,53}},
                  textString="%name",
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{-36,42},{4,-92}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Backward)}),
            defaultComponentName="opaCon",
            Documentation(info="<html>
Generic record with material definitions for constructions
with one or more layers of material.
By convention, <code>layer[1]</code> is facing the outside, and the last
layer is facing the room-side.
This is the same convention as is used in EnergyPlus and in Window 6.

<p>
The parameters <code>absIR_a</code> and <code>absIR_b</code>
are used to compute infrared heat radiation (in the infrared spectrum).
The parameters <code>absSol_a</code> and <code>absSol_b</code>
are used to compute solar heat radiation (in the solar spectrum).
</p>
<p>
The parameter <code>roughness_a</code> is used if the convective heat transfer
coefficient of the exterior surface is computed based on the wind-speed, wind-direction
and temperature difference. See
<a href=\"modelica://Buildings.HeatTransfer.Convection.Exterior\">
Buildings.HeatTransfer.Convection.Exterior</a>.
</p>
</html>",
        revisions=
        "<html>
<ul>
<li>
July 1, 2013, by Michael Wetter:<br/>
Changed the annotation of the instance <code>material</code>
from
<code>Evaluate=true</code> to <code>Evaluate=false</code>.
This is required to allow changing the material properties after compilation.
Note, however, that the number of state variables in
<a href=\"modelica://Buildings.HeatTransfer.Data.BaseClasses.Material\">
Buildings.HeatTransfer.Data.BaseClasses.Material</a>
are only computed when the model is translated, because
the number of state variables is fixed at compilation time.
</li>
<li>
March 13, 2013, by Michael Wetter:<br/>
Replaced <code>Buildings.HeatTransfer.Data.Solids.Generic</code>
with
<code>Buildings.HeatTransfer.Data.OpaqueConstructions.Generic</code>
to allow use of phase change material.
</li>
<li>
November 16, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

        end Generic;

        record Brick120 =
            Buildings.HeatTransfer.Data.OpaqueConstructions.Generic (
              material={Solids.Brick(x=0.12)},
              final nLay=1) "Construction with 120mm brick";
        annotation (preferredView="info",
      Documentation(info="<html>
<p>
Package with material definitions for constructions
with one or more layers of material.
By convention, <code>layer[1]</code> is facing the outside, and the last
layer is facing the room-side.
This is the same convention as is used in EnergyPlus and in Window 6.
</p>
<p>
The parameters <code>absIR_a</code> and <code>absIR_b</code>
are used to compute infrared heat radiation (in the infrared spectrum).
The parameters <code>absSol_a</code> and <code>absSol_b</code>
are used to compute solar heat radiation (in the solar spectrum).
</p>

</html>",
      revisions="<html>
<ul>
<li>
November 16, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end OpaqueConstructions;

      package OpaqueSurfaces
        "Package with thermophysical properties for opaque surfaces"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of opaque surfaces"
            extends Modelica.Icons.Record;
         parameter Modelica.SIunits.Area A "Area";
         parameter Modelica.SIunits.Angle til
            "Surface tilt (0: ceiling, pi/2: wall, pi: floor";
         parameter Modelica.SIunits.Emissivity absIR=0.84
            "Infrared absorptivity";
         parameter Modelica.SIunits.Emissivity absSol=0.84 "Solar absorptivity";
         final parameter Boolean isFloor=til > 2.74889125 and til < 3.53428875
            "Flag, true if construction is a floor" annotation (Evaluate=true);

          annotation (defaultComponentName="opaSur", Documentation(info=
                         "<html>
<p>
This record implements thermophysical properties for opaque surfaces.
</p>
<p>
The parameter <code>absIR</code>
is used to compute infrared heat radiation (in the infrared spectrum).
The parameter <code>absSol</code>
is used to compute solar heat radiation (in the solar spectrum).
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 16, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generic;
        annotation (
      preferredView="info",
      Documentation(info="<html>
<p>
Package with records for opaque surfaces.
</p>
<p>
The parameter <code>absIR</code>
is used to compute infrared heat radiation (in the infrared spectrum).
The parameter <code>absSol</code>
is used to compute solar heat radiation (in the solar spectrum).
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 16, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end OpaqueSurfaces;

      package BaseClasses "Base classes for package Data"
        extends Modelica.Icons.BasesPackage;

        record Material "Thermal properties of materials w/o storage"
          extends Modelica.Icons.Record;
          parameter Modelica.SIunits.Length x "Material thickness";
          parameter Modelica.SIunits.ThermalConductivity k
            "Thermal conductivity";
          parameter Modelica.SIunits.SpecificHeatCapacity c
            "Specific heat capacity";
          parameter Modelica.SIunits.Density d "Mass density";
          parameter Real R(unit="m2.K/W")
            "Thermal resistance of a unit area of material";
          parameter Integer nStaRef(min=0) = 3
            "Number of state variables in a reference material of 0.2 m concrete";
          parameter Integer nSta(min=1)=max(1, integer(ceil(nStaReal)))
            "Actual number of state variables in material"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean steadyState= (c == 0 or d == 0)
            "Flag, if true, then material is computed using steady-state heat conduction"
            annotation(Evaluate=true);
          parameter Real piRef=331.4
            "Ratio x/sqrt(alpha) for reference material of 0.2 m concrete"
            annotation (Dialog(tab="Advanced"));
          parameter Real piMat=if steadyState then piRef else x*sqrt(c*d)/sqrt(k)
            "Ratio x/sqrt(alpha)"
            annotation(Dialog(tab="Advanced"));
          parameter Real nStaReal(min=0) = nStaRef*piMat/piRef
            "Number of states as a real number"
            annotation (Dialog(tab="Advanced"));

          parameter Modelica.SIunits.Temperature TSol
            "Solidus temperature, used only for PCM."
            annotation (Dialog(group="Properties for phase change material"));
          parameter Modelica.SIunits.Temperature TLiq
            "Liquidus temperature, used only for PCM"
            annotation (Dialog(group="Properties for phase change material"));
          parameter Modelica.SIunits.SpecificInternalEnergy LHea
            "Latent heat of phase change"
            annotation (Dialog(group="Properties for phase change material"));

          constant Boolean ensureMonotonicity = false
            "Set to true to force derivatives dT/du to be monotone";

          constant Boolean phasechange = false
            "Flag, true if the material is a phase change material"
                annotation (Dialog(group="Properties for phase change material"));

          annotation (preferredView="info",
          Documentation(info="<html>
Base record for materials that declares the thermal properties.
<br/>
<p>
The specific heat capacity can be zero, in which case the material
will be modeled as a thermal resistor that does not store energy.
</p>
<p>
Note that the thermal resistance is in units of
<i>m<sup>2</sup> K &frasl; W</i> and not <i>K &frasl; W</i>
because this record does not have the surface area as a parameter.
The surface area
will be defined in the model of the construction that uses this material.
This allows use of the same material in walls, floors
and ceilings of different surface area.
</p>
</html>",
        revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
June 3 2010, by Michael Wetter:<br/>
Implemented adaptive computation of number of states based on a reference construction of <i>0.2 m</i> concrete.
</li>
<li>
March 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Icon(graphics={
                Text(
                  extent={{-94,44},{-16,12}},
                  lineColor={0,0,0},
                  textString="x=%x"),
                Text(
                  extent={{8,40},{86,8}},
                  lineColor={0,0,0},
                  textString="k=%k"),
                Text(
                  extent={{-90,-58},{-12,-90}},
                  lineColor={0,0,0},
                  textString="R=%R"),
                Text(
                  extent={{-92,-10},{-14,-42}},
                  lineColor={0,0,0},
                  textString="U=%U"),
                Rectangle(
                  visible=(c == 0),
                  extent={{0,0},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,170,170},
                  fillPattern=FillPattern.Solid),
                Line(points={{-100,-50},{100,-50}}, color={0,0,0}),
                Text(
                  visible=not (c == 0),
                  extent={{8,-8},{86,-40}},
                  lineColor={0,0,0},
                  textString="d=%d"),
                Text(
                  visible=not (c == 0),
                  extent={{10,-56},{88,-88}},
                  lineColor={0,0,0},
                  textString="c=%c")}));
        end Material;
      end BaseClasses;
      annotation (Documentation(info="<html>
Package with thermal properties of solid materials.
</html>"));
    end Data;

    package Types "Package with type definitions"

      type SurfaceRoughness = enumeration(
          VeryRough "Very rough",
          Rough "Rough",
          Medium "Medium rough",
          MediumSmooth "Medium smooth",
          Smooth "Smooth",
          VerySmooth "Very smooth")
        "Enumeration defining the surface roughness"
      annotation (Documentation(info="<html>
<p>
This enumeration is used to define the surface roughness
which may be used to compute the convective heat transfer coefficients of
building construction.
</p>
<p>
The surface roughness will be used to compute the
wind-driven convective heat transfer coefficient in
<a href=\"modelica://Buildings.HeatTransfer.Convection.Exterior\">
Buildings.HeatTransfer.Convection.Exterior</a>.
The possible surface roughness are
</p>

<table summary=\"summary\" border=\"1\">
<tr>
<th>Roughness index</th>
<th>Example material</th>
</tr>
<tr><td>VeryRough</td>     <td>Stucco</td></tr>
<tr><td>Rough</td>         <td>Brick</td></tr>
<tr><td>MediumRough</td>   <td>Concrete</td></tr>
<tr><td>MediumSmooth</td>  <td>Clear pine</td></tr>
<tr><td>Smooth</td>        <td>Smooth plaster</td></tr>
<tr><td>VerySmooth</td>    <td>Glass</td></tr>
</table>
</html>"));

      type ExteriorConvection = enumeration(
          Fixed "Fixed coefficient (a user-specified parameter is used)",
          TemperatureWind "Wind speed and temperature dependent")
        "Enumeration defining the convective heat transfer model for exterior surfaces"
      annotation (Documentation(info="<html>
<p>
This enumeration is used to set the function
that is used to compute the convective
heat transfer coefficient for exterior (outside-side facing) surfaces.
</p>
</html>"));

      type InteriorConvection = enumeration(
          Fixed "Fixed coefficient (a user-specified parameter is used)",
          Temperature "Temperature dependent")
        "Enumeration defining the convective heat transfer model for interior surfaces"
      annotation (Documentation(info="<html>
<p>
This enumeration is used to set the function
that is used to compute the convective
heat transfer coefficient for interior (room-side facing) surfaces.
</p>
</html>"));

      package Tilt "Enumeration for surface tilt"

        constant Modelica.SIunits.Angle Ceiling=0 "Tilt for ceiling";

        constant Modelica.SIunits.Angle Wall =    Modelica.Constants.pi/2
          "Tilt for wall";

        constant Modelica.SIunits.Angle Floor =   Modelica.Constants.pi
          "Tilt for floor";
        annotation(preferredView="info", Documentation(info="<html>
<p>
 Enumeration to define the tilt of a surface for the room model.
  For example, for a construction that is a floor, use
 <code>Buildings.HeatTransfer.Types.Tilt.Floor</code>.
</p>
<p>
Note that a ceiling has a tilt of <i>0</i>, and also the solar collector models
in
<a href=\"Buildings.Fluid.SolarCollectors\">Buildings.Fluid.SolarCollectors</a>
require a tilt of <i>0</i> if they are facing straight upwards.
This is correct because
the solar irradiation on a ceiling construction is on the other-side surface,
which faces upwards toward the sky. Hence, a construction is considered
a ceiling from the view point of a person standing inside a room.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 30, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Tilt;

      package Azimuth "Enumeration for surface azimuth"

         constant Modelica.SIunits.Angle S = 0
          "Azimuth for an exterior wall whose outer surface faces south";

         constant Modelica.SIunits.Angle E = -Modelica.Constants.pi/2
          "Azimuth for an exterior wall whose outer surface faces east";

         constant Modelica.SIunits.Angle N = Modelica.Constants.pi
          "Azimuth for an exterior wall whose outer surface faces north";

         constant Modelica.SIunits.Angle W = +Modelica.Constants.pi/2
          "Azimuth for an exterior wall whose outer surface faces west";
        annotation(preferredView="info",
        Documentation(info="<html>
<p>
 Enumeration to define the azimuth of a surface for the room model.
 For example, if an exterior wall is South oriented, i.e., its outside-facing
surface is towards South, use
 <code>Buildings.HeatTransfer.Types.Azimuth.S</code>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Azimuth;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>"));
    end Types;

    package Interfaces "Package with interfaces for heat transfer models"
      extends Modelica.Icons.InterfacesPackage;

      connector RadiosityInflow = input Real(min=0, final unit="W", nominal=419)
        "Connector for inflowing radiosity"
        annotation(defaultComponentName = "JIn", Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              pattern=LinePattern.None,
              smooth=Smooth.None,
              fillColor={0,127,0},
              fillPattern=FillPattern.Solid)}),
        Diagram(graphics={                    Text(
              extent={{-38,120},{38,100}},
              lineColor={0,127,0},
              fillColor={0,127,0},
              fillPattern=FillPattern.Solid,
              textString="%name"),                              Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              pattern=LinePattern.None,
              smooth=Smooth.None,
              fillColor={0,127,0},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
The nominal value is set to <i>&sigma; T<sup>4</sup> = &sigma; 293.15<sup>4</sup> = 419</i>.
</html>",
      revisions="<html>
<ul>
<li>
June 27, 2013, by Michael Wetter:<br/>
Removed <code>flow</code> attribute as this violates the Modelica Language Standard.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
September 3, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      connector RadiosityOutflow = output Real(min=0, final unit="W", nominal=419)
        "Connector for outflowing radiosity"
        annotation(defaultComponentName = "JOut", Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              smooth=Smooth.None,
              lineColor={0,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(graphics={                                       Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              smooth=Smooth.None,
              lineColor={0,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{-42,122},{34,102}},
              lineColor={0,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              textString="%name")}),
        Documentation(info="<html>
The nominal value is set to <i>&sigma; T<sup>4</sup> = &sigma; 293.15<sup>4</sup> = 419</i>.
</html>",
      revisions="<html>
<ul>
<li>
June 27, 2013, by Michael Wetter:<br/>
Removed <code>flow</code> attribute as this violates the Modelica Language Standard.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
September 3, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    annotation (preferredView="info", Documentation(info="<html>
This package contains interfaces for the heat transfer models.
</html>"));
    end Interfaces;
  annotation (preferredView="info", Documentation(info="<html>
This package contains models for heat transfer elements.
</html>"),
  Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}),
  graphics={
        Polygon(
          origin=  {13.758,27.517},
          lineColor=  {128,128,128},
          fillColor=  {192,192,192},
          fillPattern=  FillPattern.Solid,
          points=  {{-54,-6},{-61,-7},{-75,-15},{-79,-24},{-80,-34},{-78,-42},{-73,-49},{-64,-51},{-57,-51},{-47,-50},{-41,-43},{-38,-35},{-40,-27},{-40,-20},{-42,-13},{-47,-7},{-54,-5},{-54,-6}}),
      Polygon(
          origin=  {13.758,27.517},
          fillColor=  {160,160,164},
          fillPattern=  FillPattern.Solid,
          points=  {{-75,-15},{-79,-25},{-80,-34},{-78,-42},{-72,-49},{-64,-51},{-57,-51},{-47,-50},{-57,-47},{-65,-45},{-71,-40},{-74,-33},{-76,-23},{-75,-15},{-75,-15}}),
        Polygon(
          origin=  {13.758,27.517},
          lineColor=  {160,160,164},
          fillColor=  {192,192,192},
          fillPattern=  FillPattern.Solid,
          points=  {{39,-6},{32,-7},{18,-15},{14,-24},{13,-34},{15,-42},{20,-49},{29,-51},{36,-51},{46,-50},{52,-43},{55,-35},{53,-27},{53,-20},{51,-13},{46,-7},{39,-5},{39,-6}}),
        Polygon(
          origin=  {13.758,27.517},
          fillColor=  {160,160,164},
          fillPattern=  FillPattern.Solid,
          points=  {{18,-15},{14,-25},{13,-34},{15,-42},{21,-49},{29,-51},{36,-51},{46,-50},{36,-47},{28,-45},{22,-40},{19,-33},{17,-23},{18,-15},{18,-15}}),
        Polygon(
          origin=  {13.758,27.517},
          lineColor=  {191,0,0},
          fillColor=  {191,0,0},
          fillPattern=  FillPattern.Solid,
          points=  {{-9,-23},{-9,-10},{18,-17},{-9,-23}}),
        Line(
          origin=  {13.758,27.517},
          points=  {{-41,-17},{-9,-17}},
          color=  {191,0,0},
          thickness=  0.5),
        Line(
          origin=  {13.758,27.517},
          points=  {{-17,-40},{15,-40}},
          color=  {191,0,0},
          thickness=  0.5),
        Polygon(
          origin=  {13.758,27.517},
          lineColor=  {191,0,0},
          fillColor=  {191,0,0},
          fillPattern=  FillPattern.Solid,
          points=  {{-17,-46},{-17,-34},{-40,-40},{-17,-46}})}));
  end HeatTransfer;

  package Media "Package with medium models"
    extends Modelica.Icons.Package;

    package IdealGases "Package with models for ideal gases"
      extends Modelica.Icons.MaterialPropertiesPackage;

      package SimpleAir "Air: Simple dry air model (-50..100 degC)"
        extends Modelica.Media.Air.SimpleAir(
           T_min=Modelica.SIunits.Conversions.from_degC(-50));

      replaceable function enthalpyOfCondensingGas
          "Enthalpy of steam per unit mass of steam"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        output SpecificEnthalpy h "steam enthalpy";
      algorithm
        h := 0;
        annotation (Documentation(info="<html>
<p>
Dummy function that returns <code>0</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 27, 2011, by Michael Wetter:<br/>
First implementation to allow using the room model with a medium that does not contain water vapor.
</li>
</ul>
</html>"));
      end enthalpyOfCondensingGas;

      replaceable function saturationPressure
          "Return saturation pressure of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature Tsat "saturation temperature";
        output AbsolutePressure psat "saturation pressure";
      algorithm
        psat := 0;
        annotation (Documentation(info="<html>
<p>
Dummy function that returns <code>0</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 27, 2011, by Michael Wetter:<br/>
First implementation to allow using the room model with a medium that does not contain water vapor.
</li>
</ul>
</html>"));
      end saturationPressure;

        annotation (preferredView="info", Documentation(info="<html>
<p>
This package is identical to
<a href=\"modelica://Modelica.Media.Air.SimpleAir\">
Modelica.Media.Air.SimpleAir</a> except for the minimum fluid temperature.
The package is here for convenience so that all medium models that are typically used
with the <code>Buildings</code> library are at a central location.
</html>",     revisions="<html>
<ul>
<li>
April 27, 2011, by Michael Wetter:<br/>
Added function <code>enthalpyOfCondensingGas</code>, which returns <code>0</code>,
to allow using the room model with a medium that does not contain water vapor.
</li><li>
September 4, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end SimpleAir;
    annotation (Documentation(info="<html>
<p>
This package contains medium models for ideal gases.
</p>
</html>"));
    end IdealGases;

    package PerfectGases "Package with models for perfect gases"
      extends Modelica.Icons.MaterialPropertiesPackage;

      package MoistAir
        extends Modelica.Media.Interfaces.PartialCondensingGases(
           mediumName="Moist air perfect gas",
           substanceNames={"water", "air"},
           final reducedX=true,
           final singleState=false,
           reference_X={0.01,0.99},
           fluidConstants = {Modelica.Media.IdealGases.Common.FluidData.H2O,
                             Modelica.Media.IdealGases.Common.FluidData.N2});

        constant Integer Water=1
          "Index of water (in substanceNames, massFractions X, etc.)";
        constant Integer Air=2
          "Index of air (in substanceNames, massFractions X, etc.)";
        constant Real k_mair =  steam.MM/dryair.MM "Ratio of molar weights";
        constant Buildings.Media.PerfectGases.Common.DataRecord dryair=
              Buildings.Media.PerfectGases.Common.SingleGasData.Air;
        constant Buildings.Media.PerfectGases.Common.DataRecord steam=
              Buildings.Media.PerfectGases.Common.SingleGasData.H2O;
        import SI = Modelica.SIunits;

        // Min and max values, used for Brent's algorithm in T_hpX
        constant Modelica.SIunits.Temperature TMin = 200 "Minimum temperature";
        constant Modelica.SIunits.Temperature TMax = 400 "Maximum temperature";

        redeclare record extends ThermodynamicState(
          p(start=p_default),
          T(start=T_default),
          X(start=X_default)) "ThermodynamicState record for moist air"
        end ThermodynamicState;

        redeclare replaceable model extends BaseProperties(
          T(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
          p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
          Xi(each stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
          final standardOrderComponents=true)

          /* p, T, X = X[Water] are used as preferred states, since only then all
     other quantities can be computed in a recursive sequence.
     If other variables are selected as states, static state selection
     is no longer possible and non-linear algebraic equations occur.
      */
          MassFraction x_water "Mass of total water/mass of dry air";
          Real phi "Relative humidity";

        protected
          constant SI.MolarMass[2] MMX = {steam.MM,dryair.MM}
            "Molar masses of components";

          MassFraction X_liquid "Mass fraction of liquid water";
          MassFraction X_steam "Mass fraction of steam water";
          MassFraction X_air "Mass fraction of air";
          MassFraction X_sat
            "Steam water mass fraction of saturation boundary in kg_water/kg_moistair";
          MassFraction x_sat
            "Steam water mass content of saturation boundary in kg_water/kg_dryair";
          AbsolutePressure p_steam_sat "Partial saturation pressure of steam";

        equation
          assert(T >= TMin and T <= TMax, "
Temperature T is not in the allowed range "       + String(TMin) + " <= (T ="
                     + String(T) + " K) <= " + String(TMax) + " K
required from medium model \""           + mediumName + "\".");
          MM = 1/(Xi[Water]/MMX[Water]+(1.0-Xi[Water])/MMX[Air]);

          p_steam_sat = min(saturationPressure(T),0.999*p);
          X_sat = min(p_steam_sat * k_mair/max(100*Modelica.Constants.eps, p - p_steam_sat)*(1 - Xi[Water]), 1.0)
            "Water content at saturation with respect to actual water content";
          X_liquid = max(Xi[Water] - X_sat, 0.0);
          X_steam  = Xi[Water]-X_liquid;
          X_air    = 1-Xi[Water];

          h = specificEnthalpy_pTX(p,T,Xi);
          R = dryair.R*(1 - X_steam/(1 - X_liquid)) + steam.R*X_steam/(1 - X_liquid);
          //
          u = h - R*T;
          d = p/(R*T);
          /* Note, u and d are computed under the assumption that the volume of the liquid
         water is neglible with respect to the volume of air and of steam
      */
          state.p = p;
          state.T = T;
          state.X = X;

          // this x_steam is water load / dry air!!!!!!!!!!!
          x_sat    = k_mair*p_steam_sat/max(100*Modelica.Constants.eps,p - p_steam_sat);
          x_water = Xi[Water]/max(X_air,100*Modelica.Constants.eps);
          phi = p/p_steam_sat*Xi[Water]/(Xi[Water] + k_mair*X_air);
        end BaseProperties;

        function Xsaturation = Modelica.Media.Air.MoistAir.Xsaturation
          "Steam water mass fraction of saturation boundary in kg_water/kg_moistair";

        redeclare function setState_pTX
          "Thermodynamic state as function of p, T and composition X"
            extends Modelica.Media.Air.MoistAir.setState_pTX;
        end setState_pTX;

        redeclare function setState_phX
          "Thermodynamic state as function of p, h and composition X"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:] "Mass fractions";
        output ThermodynamicState state;
        algorithm
        state := if size(X,1) == nX then
              ThermodynamicState(p=p,T=T_phX(p,h,X),X=X) else
              ThermodynamicState(p=p,T=T_phX(p,h,X), X=cat(1,X,{1-sum(X)}));
          annotation (Documentation(info="<html>
Function to set the state for given pressure, enthalpy and species concentration.
This function needed to be reimplemented in order for the medium model to use
the implementation of <code>T_phX</code> provided by this package as opposed to the
implementation provided by its parent package.
</html>"));
        end setState_phX;

        redeclare function setState_dTX
          "Thermodynamic state as function of d, T and composition X"
           extends Modelica.Media.Air.MoistAir.setState_dTX;
        end setState_dTX;

        redeclare function gasConstant
          "Gas constant (computation neglects liquid fraction)"
           extends Modelica.Media.Air.MoistAir.gasConstant;
        end gasConstant;

      function saturationPressureLiquid
          "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 373.16 K"

        extends Modelica.Icons.Function;
        input SI.Temperature Tsat "saturation temperature";
        output SI.AbsolutePressure psat "saturation pressure";
      algorithm
        psat := 611.657*Modelica.Math.exp(17.2799 - 4102.99/(Tsat - 35.719));
        annotation(Inline=false,smoothOrder=5,derivative=saturationPressureLiquid_der,
          Documentation(info="<html>
Saturation pressure of water above the triple point temperature is computed from temperature. It's range of validity is between
273.16 and 373.16 K. Outside these limits a less accurate result is returned.
</html>"));
      end saturationPressureLiquid;

      function saturationPressureLiquid_der
          "Time derivative of saturationPressureLiquid"

        extends Modelica.Icons.Function;
        input SI.Temperature Tsat "Saturation temperature";
        input Real dTsat(unit="K/s") "Saturation temperature derivative";
        output Real psat_der(unit="Pa/s") "Saturation pressure";
      algorithm
        psat_der:=611.657*Modelica.Math.exp(17.2799 - 4102.99/(Tsat - 35.719))*4102.99*dTsat/(Tsat - 35.719)/(Tsat - 35.719);

        annotation(Inline=false,smoothOrder=5,
          Documentation(info="<html>
Derivative function of <a href=modelica://Modelica.Media.Air.MoistAir.saturationPressureLiquid>saturationPressureLiquid</a>
</html>"));
      end saturationPressureLiquid_der;

        function sublimationPressureIce =
            Modelica.Media.Air.MoistAir.sublimationPressureIce
          "Saturation curve valid for 223.16 <= T <= 273.16. Outside of these limits a (less accurate) result is returned"
          annotation(Inline=false,smoothOrder=5,derivative=Modelica.Media.Air.MoistAir.sublimationPressureIce_der);

      redeclare function extends saturationPressure
          "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"

      algorithm
        psat := Buildings.Utilities.Math.Functions.spliceFunction(
                                                        saturationPressureLiquid(Tsat),sublimationPressureIce(Tsat),Tsat-273.16,1.0);
        annotation(Inline=false,smoothOrder=5);
      end saturationPressure;

       redeclare function pressure "Gas pressure"
          extends Modelica.Media.Air.MoistAir.pressure;
       end pressure;

       redeclare function temperature "Gas temperature"
          extends Modelica.Media.Air.MoistAir.temperature;
       end temperature;

       redeclare function density "Gas density"
          extends Modelica.Media.Air.MoistAir.density;
       end density;

       redeclare function specificEntropy
          "Specific entropy (liquid part neglected, mixing entropy included)"
          extends Modelica.Media.Air.MoistAir.specificEntropy;
       end specificEntropy;

       redeclare function extends enthalpyOfVaporization
          "Enthalpy of vaporization of water"
       algorithm
        r0 := 2501014.5;
       end enthalpyOfVaporization;

        function HeatCapacityOfWater
          "Specific heat capacity of water (liquid only) which is constant"
          extends Modelica.Icons.Function;
          input Temperature T;
          output SpecificHeatCapacity cp_fl;
        algorithm
          cp_fl := 4186;
        end HeatCapacityOfWater;

      redeclare replaceable function extends enthalpyOfLiquid
          "Enthalpy of liquid (per unit mass of liquid) which is linear in the temperature"

      algorithm
        h := (T - 273.15)*4186;
        annotation(smoothOrder=5, derivative=der_enthalpyOfLiquid);
      end enthalpyOfLiquid;

      replaceable function der_enthalpyOfLiquid
          "Temperature derivative of enthalpy of liquid per unit mass of liquid"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T "temperature derivative";
        output Real der_h "derivative of liquid enthalpy";
      algorithm
        der_h := 4186*der_T;
      end der_enthalpyOfLiquid;

      redeclare function enthalpyOfCondensingGas
          "Enthalpy of steam per unit mass of steam"
        extends Modelica.Icons.Function;

        input Temperature T "temperature";
        output SpecificEnthalpy h "steam enthalpy";
      algorithm
        h := (T-273.15) * steam.cp + enthalpyOfVaporization(T);
        annotation(smoothOrder=5, derivative=der_enthalpyOfCondensingGas);
      end enthalpyOfCondensingGas;

      replaceable function der_enthalpyOfCondensingGas
          "Derivative of enthalpy of steam per unit mass of steam"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T "temperature derivative";
        output Real der_h "derivative of steam enthalpy";
      algorithm
        der_h := steam.cp*der_T;
      end der_enthalpyOfCondensingGas;

      redeclare function enthalpyOfNonCondensingGas
          "Enthalpy of non-condensing gas per unit mass of steam"
        extends Modelica.Icons.Function;

        input Temperature T "temperature";
        output SpecificEnthalpy h "enthalpy";
      algorithm
        h := enthalpyOfDryAir(T);
        annotation(smoothOrder=5, derivative=der_enthalpyOfNonCondensingGas);
      end enthalpyOfNonCondensingGas;

      replaceable function der_enthalpyOfNonCondensingGas
          "Derivative of enthalpy of non-condensing gas per unit mass of steam"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T "temperature derivative";
        output Real der_h "derivative of steam enthalpy";
      algorithm
        der_h := der_enthalpyOfDryAir(T, der_T);
      end der_enthalpyOfNonCondensingGas;

      redeclare replaceable function extends enthalpyOfGas
          "Enthalpy of gas mixture per unit mass of gas mixture"
      algorithm
        h := enthalpyOfCondensingGas(T)*X[Water]
             + enthalpyOfDryAir(T)*(1.0-X[Water]);
      end enthalpyOfGas;

      replaceable function enthalpyOfDryAir
          "Enthalpy of dry air per unit mass of dry air"
        extends Modelica.Icons.Function;

        input Temperature T "temperature";
        output SpecificEnthalpy h "dry air enthalpy";
      algorithm
        h := (T - 273.15)*dryair.cp;
        annotation(smoothOrder=5, derivative=der_enthalpyOfDryAir);
      end enthalpyOfDryAir;

      replaceable function der_enthalpyOfDryAir
          "Derivative of enthalpy of dry air per unit mass of dry air"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T "temperature derivative";
        output Real der_h "derivative of dry air enthalpy";
      algorithm
        der_h := dryair.cp*der_T;
      end der_enthalpyOfDryAir;

      redeclare replaceable function extends specificHeatCapacityCp
          "Specific heat capacity of gas mixture at constant pressure"
      algorithm
        cp := dryair.cp*(1-state.X[Water]) +steam.cp*state.X[Water];
        annotation(smoothOrder=5);
      end specificHeatCapacityCp;

      redeclare replaceable function extends specificHeatCapacityCv
          "Specific heat capacity of gas mixture at constant volume"
      algorithm
        cv:= dryair.cv*(1-state.X[Water]) +steam.cv*state.X[Water];
        annotation(smoothOrder=5);
      end specificHeatCapacityCv;

      redeclare function extends dynamicViscosity
          "dynamic viscosity of dry air"
      algorithm
        eta := 1.85E-5;
      end dynamicViscosity;

      redeclare function extends thermalConductivity
          "Thermal conductivity of dry air as a polynomial in the temperature"
      algorithm
        lambda := Modelica.Media.Incompressible.TableBased.Polynomials_Temp.evaluate(
                     {(-4.8737307422969E-008), 7.67803133753502E-005, 0.0241814385504202},
                     Modelica.SIunits.Conversions.to_degC(state.T));
      end thermalConductivity;

      function h_pTX
          "Compute specific enthalpy from pressure, temperature and mass fraction"
        extends Modelica.Icons.Function;
        input SI.Pressure p "Pressure";
        input SI.Temperature T "Temperature";
        input SI.MassFraction X[:] "Mass fractions of moist air";
        output SI.SpecificEnthalpy h "Specific enthalpy at p, T, X";

        protected
        SI.AbsolutePressure p_steam_sat "Partial saturation pressure of steam";
        SI.MassFraction x_sat
            "steam water mass fraction of saturation boundary";
        SI.MassFraction X_liquid "mass fraction of liquid water";
        SI.MassFraction X_steam "mass fraction of steam water";
        SI.MassFraction X_air "mass fraction of air";
        SI.SpecificEnthalpy hDryAir "Enthalpy of dry air";
      algorithm
        p_steam_sat :=saturationPressure(T);
        x_sat    :=k_mair*p_steam_sat/(p - p_steam_sat);
        X_liquid :=max(X[Water] - x_sat/(1 + x_sat), 0.0);
        X_steam  :=X[Water] - X_liquid;
        X_air    :=1 - X[Water];

      /* THIS DOES NOT WORK --------------------------
  h := enthalpyOfDryAir(T) * X_air +
       Modelica.Media.Air.MoistAir.enthalpyOfCondensingGas(T) * X_steam + enthalpyOfLiquid(T)*X_liquid;
--------------------------------- */

      /* THIS WORKS!!!! +++++++++++++++++++++
  h := (T - 273.15)*dryair.cp * X_air +
       Modelica.Media.Air.MoistAir.enthalpyOfCondensingGas(T) * X_steam + enthalpyOfLiquid(T)*X_liquid;
 +++++++++++++++++++++*/

        hDryAir := (T - 273.15)*dryair.cp;
        h := hDryAir * X_air +
             ((T-273.15) * steam.cp + 2501014.5) * X_steam +
             (T - 273.15)*4186*X_liquid;
        annotation(Inline=false,smoothOrder=1);
      end h_pTX;

      redeclare function extends specificEnthalpy "Specific enthalpy"
      algorithm
        h := h_pTX(state.p, state.T, state.X);
      end specificEnthalpy;

      redeclare function extends specificInternalEnergy
          "Specific internal energy"
        extends Modelica.Icons.Function;
      algorithm
        u := h_pTX(state.p,state.T,state.X) - gasConstant(state)*state.T;
      end specificInternalEnergy;

      redeclare function extends specificGibbsEnergy "Specific Gibbs energy"
        extends Modelica.Icons.Function;
      algorithm
        g := h_pTX(state.p,state.T,state.X) - state.T*specificEntropy(state);
      end specificGibbsEnergy;

      redeclare function extends specificHelmholtzEnergy
          "Specific Helmholtz energy"
        extends Modelica.Icons.Function;
      algorithm
        f := h_pTX(state.p,state.T,state.X) - gasConstant(state)*state.T - state.T*specificEntropy(state);
      end specificHelmholtzEnergy;

      function T_phX
          "Compute temperature from specific enthalpy and mass fraction"
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:] "Mass fractions of composition";
        output Temperature T "Temperature";

        protected
      package Internal
            "Solve h(data,T) for T with given h (use only indirectly via temperature_phX)"
        extends Modelica.Media.Common.OneNonLinearEquation;

        redeclare record extends f_nonlinear_Data
              "Data to be passed to non-linear function"
          extends Modelica.Media.IdealGases.Common.DataRecord;
        end f_nonlinear_Data;

        redeclare function extends f_nonlinear
        algorithm
            y := h_pTX(p,x,X);
        end f_nonlinear;

        // Dummy definition has to be added for current Dymola
        redeclare function extends solve
        end solve;
      end Internal;
        protected
      constant Modelica.Media.IdealGases.Common.DataRecord steam=
                    Modelica.Media.IdealGases.Common.SingleGasesData.H2O;
        protected
       SI.AbsolutePressure p_steam_sat "Partial saturation pressure of steam";
       SI.MassFraction x_sat "steam water mass fraction of saturation boundary";

      algorithm
        T := 273.15 + (h - 2501014.5 * X[Water])/((1 - X[Water])*dryair.cp + X[Water] *
           Buildings.Media.PerfectGases.Common.SingleGasData.H2O.cp);
        // check for saturation
        p_steam_sat :=saturationPressure(T);
        x_sat    :=k_mair*p_steam_sat/(p - p_steam_sat);
        // If the state is in the fog region, then the above equation is not valid, and
        // T is computed by inverting h_pTX(), which is much more costly.
        // For Buildings.Fluid.HeatExchangers.Examples.WetEffectivenessNTUPControl, the
        // computation above reduces the computing time by about a factor of 2.
        if (X[Water] > x_sat/(1 + x_sat)) then
           T := Internal.solve(h, TMin, TMax, p, X[1:nXi], steam);
        end if;
          annotation (Documentation(info="<html>
Temperature is computed from pressure, specific enthalpy and composition via numerical inversion of function <a href=modelica://Modelica.Media.Air.MoistAir.h_pTX>h_pTX</a>.
</html>"));
      end T_phX;

        annotation (preferredView="info", Documentation(info="<html>
<p>
This is a medium model that is similar to
<a href=\"modelica://Modelica.Media.Air.MoistAir\">
Modelica.Media.Air.MoistAir</a> but it is a perfect gas, i.e.,
it has a constant specific heat capacity.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 29, 2013, by Michael Wetter:<br/>
Added <code>final standardOrderComponents=true</code> in the
<code>BaseProperties</code> declaration. This avoids an error
when models are checked in Dymola 2014 in the pedenatic mode.
</li>
<li>
April 12, 2012, by Michael Wetter:<br/>
Added keyword <code>each</code> to <code>Xi(stateSelect=...</code>.
</li>
<li>
April 4, 2012, by Michael Wetter:<br/>
Added redeclaration of <code>ThermodynamicState</code> to avoid a warning
during model check and translation.
</li>
<li>
February 22, 2010, by Michael Wetter:<br/>
Changed <code>T_phX</code> to first compute <code>T</code>
in closed form assuming no saturation. Then, a check is done to determine
whether the state is in the fog region. If the state is in the fog region,
then <code>Internal.solve</code> is called. This new implementation
can lead to significantly shorter computing
time in models that frequently call <code>T_phX</code>.
</li>
<li>
January 27, 2010, by Michael Wetter:<br/>
Fixed bug that lead to run-time error in <code>T_phX</code>.
</li>
<li>
January 13, 2010, by Michael Wetter:<br/>
Added function <code>enthalpyOfNonCondensingGas</code> and its derivative.
</li>
<li>
January 13, 2010, by Michael Wetter:<br/>
Fixed implementation of derivative functions.
</li>
<li>
October 12, 2009, by Michael Wetter:<br/>
Added annotation for analytic derivative for functions
<code>saturationPressureLiquid</code> and <code>sublimationPressureIce</code>.
<li>
August 28, 2008, by Michael Wetter:<br/>
Referenced <code>spliceFunction</code> from package
<a href=\"modelica://Buildings.Utilities.Math\">Buildings.Utilities.Math</a>
to avoid duplicate code.
</li>
<li>
May 8, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end MoistAir;

      package Common "Package with common data for perfect gases"
        extends Modelica.Icons.MaterialPropertiesPackage;

        record DataRecord
          "Coefficient data record for properties of perfect gases"
          extends Modelica.Icons.Record;

          String name "Name of ideal gas";
          Modelica.SIunits.MolarMass MM "Molar mass";
          Modelica.SIunits.SpecificHeatCapacity R "Gas constant";
          Modelica.SIunits.SpecificHeatCapacity cp
            "Specific heat capacity at constant pressure";
          Modelica.SIunits.SpecificHeatCapacity cv
            "Specific heat capacity at constant volume";
          annotation (
        defaultComponentName="gas",
        Documentation(preferredView="info", info="<html>
<p>
This data record contains the coefficients for perfect gases.
</p>
</html>"),         revisions=
                "<html>
<ul>
<li>
May 12, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>");
        end DataRecord;

        package SingleGasData "Package with data records for single gases"
          extends Modelica.Icons.MaterialPropertiesPackage;

         constant PerfectGases.Common.DataRecord Air(
           name = Modelica.Media.IdealGases.Common.SingleGasesData.Air.name,
           R =    Modelica.Media.IdealGases.Common.SingleGasesData.Air.R,
           MM =   Modelica.Media.IdealGases.Common.SingleGasesData.Air.MM,
           cp =   1006,
           cv =   1006 - Modelica.Media.IdealGases.Common.SingleGasesData.Air.R);

        constant PerfectGases.Common.DataRecord H2O(
           name = Modelica.Media.IdealGases.Common.SingleGasesData.H2O.name,
           R =    Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R,
           MM =   Modelica.Media.IdealGases.Common.SingleGasesData.H2O.MM,
           cp =   1860,
           cv =   1860 - Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R);
          annotation (Documentation(preferredView="info", info="<html>
<p>
This package contains the coefficients for perfect gases.
</p>
</html>"),         revisions="<html>
<ul>
<li>
May 12, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>");
        end SingleGasData;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains records that are used to model perfect gases.
</p>
</html>"));
      end Common;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models of <i>thermally perfect</i> gases.
</p>
<p>
A medium is called thermally perfect if
<ul>
<li>
it is in thermodynamic equilibrium,
</li><li>
it is chemically not reacting, and
</li><li>
internal energy and enthalpy are functions of temperature only.
</li>
</ul>
<p>
In addition, the gases in this package are <i>calorically perfect</i>, i.e., the
specific heat capacities at constant pressure <i>c<sub>p</sub></i>
and constant volume <i>c<sub>v</sub></i> are both constant (Bower 1998).
</p>
<p>
For dry and moist air media that also have a constant density, see
<a href=\"modelica://Buildings.Media.GasesConstantDensity\">
Buildings.Media.GasesConstantDensity</a>.
</p>
<h4>References</h4>
<p>
Bower, William B. <i>A primer in fluid mechanics: Dynamics of flows in one
space dimension</i>. CRC Press. 1998.
</p>
</html>"));
    end PerfectGases;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains different implementations for
various media.
The media models in this package are
compatible with
<a href=\"modelica://Modelica.Media\">
Modelica.Media</a>
but the implementation is in general simpler, which often
leads to easier numerical problems and better convergence of the
models.
Due to the simplifications, the media model of this package
are generally accurate for a smaller temperature range than the
models in <a href=\"modelica://Modelica.Media\">
Modelica.Media</a>, but the smaller temperature range may often be
sufficient for building HVAC applications.
</p>
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
          graphics={
          Line(
            points=  {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
            color={64,64,64},
            smooth=Smooth.Bezier),
          Line(
            points={{-40,20},{68,20}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{-40,20},{-44,88},{-44,88}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{68,20},{86,-58}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{-60,-28},{56,-28}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{-60,-28},{-74,84},{-74,84}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{56,-28},{70,-80}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{-76,-80},{38,-80}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{-76,-80},{-94,-16},{-94,-16}},
            color={175,175,175},
            smooth=Smooth.None)}));
  end Media;

  package Rooms "Package with models for rooms"
    extends Modelica.Icons.Package;

    package Constructions
      "Package with models for constructions that are used in the room model"
      extends Modelica.Icons.VariantsPackage;

      model ConstructionWithWindow
        "Model for an opaque construction that has one window embedded in the construction"
        extends Buildings.Rooms.Constructions.BaseClasses.PartialConstruction(
          final AOpa=A-AWin);

        parameter Modelica.SIunits.Area AWin "Heat transfer area of window"
            annotation (Dialog(group="Glazing system"));
        parameter Real fFra(
          min=0,
          max=1) = 0.1 "Fraction of window frame divided by total window area"
          annotation (Dialog(group="Glazing system"));
        final parameter Modelica.SIunits.Area AFra = fFra*AWin "Frame area"
          annotation (Dialog(group="Glazing system"));
        final parameter Modelica.SIunits.Area AGla=AWin - AFra "Glass area"
          annotation (Dialog(group="Glazing system"));
        parameter Boolean linearizeRadiation = true
          "Set to true to linearize emissive power"
          annotation (Dialog(group="Glazing system"));

       replaceable parameter HeatTransfer.Data.GlazingSystems.Generic glaSys
          "Material properties of glazing system"
          annotation (Dialog(group="Glazing system"), choicesAllMatching=true, Placement(transformation(extent={{140,80},
                  {160,100}})));

        HeatTransfer.Windows.Window win(
          final glaSys=glaSys,
          final A=AWin,
          final fFra=fFra,
          final linearize = linearizeRadiation,
          final til=til) "Window model"
          annotation (Placement(transformation(extent={{-114,-184},{112,42}})));

        HeatTransfer.Interfaces.RadiosityOutflow JOutUns_a
          "Outgoing radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-300,-30},{-320,-10}}),
              iconTransformation(extent={{-300,-30},{-320,-10}})));
        HeatTransfer.Interfaces.RadiosityInflow JInUns_a
          "Incoming radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-320,10},{-300,30}}),
              iconTransformation(extent={{-320,10},{-300,30}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutSha_a if haveShade
          "Outgoing radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-300,-210},{-320,-190}}),
              iconTransformation(extent={{-300,-210},{-320,-190}})));
        HeatTransfer.Interfaces.RadiosityInflow JInSha_a if haveShade
          "Incoming radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-320,-170},{-300,-150}}),
              iconTransformation(extent={{-320,-170},{-300,-150}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns_a
          "Heat port at unshaded glass of exterior-facing surface"
                                                          annotation (Placement(transformation(extent={{-310,
                  -90},{-290,-70}}), iconTransformation(extent={{-310,-90},{-290,
                  -70}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha_a if haveShade
          "Heat port at shaded glass of exterior-facing surface"
          annotation (Placement(transformation(extent={{-310,-130},{-290,-110}}),
              iconTransformation(extent={{-310,-130},{-290,-110}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a fra_a
          "Heat port at frame of exterior-facing surface"                                   annotation (Placement(transformation(extent={{-310,
                  -270},{-290,-250}}), iconTransformation(extent={{-310,-270},{-290,
                  -250}})));
        Modelica.Blocks.Interfaces.RealInput uSha(min=0, max=1) if
             haveShade
          "Control signal for the shading device, 0: unshaded; 1: fully shaded (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-340,40},{-300,80}}),
              iconTransformation(extent={{-340,40},{-300,80}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutUns_b
          "Outgoing radiosity that connects to unshaded part of glass at room-side"
          annotation (Placement(transformation(extent={{300,10},{320,30}}),
              iconTransformation(extent={{300,10},{320,30}})));
        HeatTransfer.Interfaces.RadiosityInflow JInUns_b
          "Incoming radiosity that connects to unshaded part of glass at room-side"
          annotation (Placement(transformation(extent={{320,-30},{300,-10}}),
              iconTransformation(extent={{320,-30},{300,-10}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutSha_b if haveShade
          "Outgoing radiosity that connects to shaded part of glass at room-side"
          annotation (Placement(transformation(extent={{300,-170},{320,-150}}),
              iconTransformation(extent={{300,-170},{320,-150}})));
        HeatTransfer.Interfaces.RadiosityInflow JInSha_b if haveShade
          "Incoming radiosity that connects to shaded part of glass at room-side"
          annotation (Placement(transformation(extent={{320,-210},{300,-190}}),
              iconTransformation(extent={{320,-210},{300,-190}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaUns_b
          "Heat port at unshaded glass of room-facing surface"
                                                      annotation (Placement(transformation(extent={{290,-90},
                  {310,-70}}), iconTransformation(extent={{290,-90},{310,-70}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaSha_b if haveShade
          "Heat port at shaded glass of room-facing surface"
        annotation (Placement(transformation(extent={{290,-130},{310,-110}}),
              iconTransformation(extent={{290,-130},{310,-110}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b fra_b
          "Heat port at frame of room-facing surface"
          annotation (Placement(transformation(extent={{292,-270},{312,-250}}), iconTransformation(extent={{292,-270},{312,-250}})));

      protected
        final parameter Boolean haveShade = glaSys.haveExteriorShade or glaSys.haveInteriorShade
          "Parameter, equal to true if the window has a shade"
          annotation(Evaluate=true);

      public
        Modelica.Blocks.Interfaces.RealInput QAbsUns_flow[glaSys.nLay](each unit="W",
            each quantity="Power")
          "Solar radiation absorbed by unshaded part of glass"
                                                             annotation (Placement(
              transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-40,-320}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-80,-320})));
        Modelica.Blocks.Interfaces.RealInput QAbsSha_flow[glaSys.nLay](each unit="W",
            each quantity="Power") if haveShade
          "Solar radiation absorbed by shaded part of glass"
                                              annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={100,-320}),iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={80,-320})));

      equation
        connect(win.uSha, uSha) annotation (Line(
            points={{-125.3,19.4},{-178.75,19.4},{-178.75,60},{-320,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(JInUns_a, win.JInUns_a) annotation (Line(
            points={{-310,20},{-200,20},{-200,-3.2},{-119.65,-3.2}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(JOutUns_a, win.JOutUns_a) annotation (Line(
            points={{-310,-20},{-220,-20},{-220,-25.8},{-119.65,-25.8}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(win.glaUns_a, glaUns_a) annotation (Line(
            points={{-114,-59.7},{-200,-59.7},{-200,-80},{-300,-80}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.glaSha_a, glaSha_a) annotation (Line(
            points={{-114,-82.3},{-180,-82.3},{-180,-120},{-300,-120}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.JInSha_a, JInSha_a) annotation (Line(
            points={{-119.65,-104.9},{-162,-104.9},{-162,-160},{-310,-160}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(win.JOutSha_a, JOutSha_a) annotation (Line(
            points={{-119.65,-127.5},{-139.375,-127.5},{-139.375,-200},{-310,-200}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(win.fra_a, fra_a) annotation (Line(
            points={{-114,-161.4},{-128,-161.4},{-128,-260},{-300,-260}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.JOutUns_b, JOutUns_b) annotation (Line(
            points={{117.65,-3.2},{225.375,-3.2},{225.375,20},{310,20}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(win.JInUns_b, JInUns_b) annotation (Line(
            points={{117.65,-25.8},{233.375,-25.8},{233.375,-20},{310,-20}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(win.glaUns_b, glaUns_b) annotation (Line(
            points={{112,-59.7},{239,-59.7},{239,-80},{300,-80}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.glaSha_b, glaSha_b) annotation (Line(
            points={{112,-82.3},{220,-82.3},{220,-120},{300,-120}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.JOutSha_b, JOutSha_b) annotation (Line(
            points={{117.65,-104.9},{201.375,-104.9},{201.375,-160},{310,-160}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(win.JInSha_b, JInSha_b) annotation (Line(
            points={{117.65,-127.5},{178.375,-127.5},{178.375,-200},{310,-200}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(win.fra_b, fra_b) annotation (Line(
            points={{113.13,-161.4},{159.675,-161.4},{159.675,-260},{302,-260}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(opa.port_a, opa_a)                 annotation (Line(
            points={{-52,200},{-300,200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(opa.port_b, opa_b)                 annotation (Line(
            points={{52,200},{302,200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.QAbsUns_flow, QAbsUns_flow) annotation (Line(
            points={{-46.2,-195.3},{-46.2,-280},{-40,-280},{-40,-320}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(win.QAbsSha_flow, QAbsSha_flow) annotation (Line(
            points={{44.2,-195.3},{44.2,-280},{100,-280},{100,-320}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,
                  -300},{300,300}})),
                                Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-300,-300},{300,300}}), graphics={
              Rectangle(
                extent={{-290,202},{298,198}},
                lineColor={0,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                visible=  glaSys.haveInteriorShade,
                points={{48,60},{48,-40},{116,-104},{116,-4},{48,60}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.CrossDiag,
                fillColor={215,215,215}),
              Line(
                points={{-74,-188},{28,-188}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{28,60},{28,-188},{90,-252},{90,-4},{28,60}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{38,38},{38,-184},{78,-224},{78,-4},{38,38}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-102,60},{48,60}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{-20,60},{-20,-188},{42,-252},{42,-4},{-20,60}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-10,38},{-10,-184},{30,-224},{30,-4},{-10,38}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-74,60},{-74,-188},{-12,-252},{-12,-4},{-74,60}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-64,36},{-64,-186},{-24,-226},{-24,-6},{-64,36}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                visible=  glaSys.haveExteriorShade,
                points={{-102,60},{-102,-40},{-34,-104},{-34,-4},{-102,60}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.CrossDiag,
                fillColor={215,215,215}),
              Line(
                points={{-34,-4},{116,-4}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{56,-80},{290,-80}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-290,-80},{-56,-80}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-294,-120},{-44,-120}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{60,-120},{296,-120}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-60,-200},{-60,-260}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{84,-218},{84,-260}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{84,-260},{302,-260}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-292,-260},{-60,-260}},
                color={160,0,0},
                smooth=Smooth.None),
              Rectangle(
                extent={{-62,270},{-44,156}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Rectangle(
                extent={{42,270},{60,156}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Rectangle(
                extent={{8,276},{68,76}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-48,276},{8,76}},
                lineColor={0,0,0},
                fillColor={183,183,121},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-72,276},{-48,76}},
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-48,276},{-62,290},{-10,290},{8,276},{-48,276}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={183,183,121},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-72,276},{-80,290},{-62,290},{-48,276},{-72,276}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{8,276},{-10,290},{48,290},{68,276},{8,276}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-80,290},{-80,98},{-72,76},{-72,276},{-80,290}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
                                     Ellipse(
                extent={{-222,68},{-160,4}},
                lineColor={255,255,0},
                fillColor={255,213,170},
                fillPattern=FillPattern.Sphere)}),
      defaultComponentName="conWin",
      Documentation(revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
December 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>",       info="<html>
<p>
This model is used to compute heat transfer through constructions with windows inside the
room model.
</p>
<p>
The model consists of the following two main submodels:
</p>
<ul>
<li>
The instance <code>opa</code>, which uses the model
<a href=\"modelica://Buildings.HeatTransfer.Conduction.MultiLayer\">
Buildings.HeatTransfer.Conduction.MultiLayer</a> to compute
the heat transfer through the opaque part of the construction.
This model uses the record <code>layers</code> to access the material properties
of the opaque construction.
</li>
<li>
The instance <code>win</code>, which uses the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a> to compute
the heat transfer through the glazing system.
This model uses the record <code>glaSys</code> to access the material properties
of the glazing system.
</li>
</ul>
<p>
The parameter <code>A</code> is the area of the opaque construction plus the window.
The parameter <code>AWin</code> is the area of the glazing system, including the frame.
The area of the opaque construction is assigned internally as <code>AOpa=A-AWin</code>.
</p>
</html>"));
      end ConstructionWithWindow;

      model Construction "Model for an opaque construction that has no window"
        extends Buildings.Rooms.Constructions.BaseClasses.PartialConstruction(
          final AOpa=A);

        annotation (
      defaultComponentName="conOpa",
      Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,-300},
                  {300,300}})), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-300,-300},{300,300}}), graphics={
              Rectangle(
                extent={{-290,202},{298,198}},
                lineColor={0,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{0,260},{60,60}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-56,260},{0,60}},
                lineColor={0,0,0},
                fillColor={183,183,121},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-80,260},{-56,60}},
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-56,260},{-70,274},{-18,274},{0,260},{-56,260}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={183,183,121},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-80,260},{-88,274},{-70,274},{-56,260},{-80,260}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{0,260},{-18,274},{40,274},{60,260},{0,260}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-88,274},{-88,82},{-80,60},{-80,260},{-88,274}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid)}),
          Documentation(
          info="<html>
This model is used to compute heat transfer through opaque constructions inside the
room model.
The model uses the record <code>layers</code> to access the material properties
of the opaque construction. The heat transfer is computed in the instance
<code>opa</code>, which uses the model
<a href=\"modelica://Buildings.HeatTransfer.Conduction.MultiLayer\">
Buildings.HeatTransfer.Conduction.MultiLayer</a>.
</html>",
      revisions="<html>
<ul>
<li>
December 6 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Construction;

      package BaseClasses
        "Package with base classes for Buildings.Rooms.Constructions"
        extends Modelica.Icons.BasesPackage;

        partial model PartialConstruction
          "Partial model for exterior construction that has no window"

          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Area AOpa
            "Heat transfer area of opaque construction"
            annotation (Dialog(group="Opaque construction"));

          parameter Buildings.HeatTransfer.Data.OpaqueConstructions.Generic
            layers "Material properties of opaque construction"
            annotation(Dialog(group="Opaque construction"),
                       choicesAllMatching=true, Placement(transformation(extent={{146,258},
                    {166,278}})));

          parameter Modelica.SIunits.Angle til "Surface tilt";

          final parameter Boolean isFloor=til > 2.74889125 and til < 3.53428875
            "Flag, true if construction is a floor" annotation (Evaluate=true);
          final parameter Boolean isCeiling=til > -0.392699 and til < 0.392699
            "Flag, true if construction is a floor" annotation (Evaluate=true);

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a opa_a
            "Heat port at surface a of opaque construction"
            annotation (Placement(transformation(extent={{-310,190},{-290,210}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b opa_b
            "Heat port at surface b of opaque construction"
            annotation (Placement(transformation(extent={{292,190},{312,210}})));

          final parameter Integer nLay(min=1, fixed=true) = layers.nLay
            "Number of layers";
          final parameter Integer nSta[nLay](min=1)={layers.material[i].nSta for i in 1:nLay}
            "Number of states"  annotation(Evaluate=true);
          parameter Boolean steadyStateInitial=false
            "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
                annotation (Dialog(group="Initialization"), Evaluate=true);
          parameter Modelica.SIunits.Temperature T_a_start=293.15
            "Initial temperature at port_a, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
          parameter Modelica.SIunits.Temperature T_b_start=293.15
            "Initial temperature at port_b, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));

          HeatTransfer.Conduction.MultiLayer opa(
            final A=AOpa,
            final layers=layers,
            final steadyStateInitial=steadyStateInitial,
            final T_a_start=T_a_start,
            final T_b_start=T_b_start)
            "Model for heat transfer through opaque construction"
            annotation (Placement(transformation(extent={{-52,148},{52,252}})));

        equation
          connect(opa.port_a, opa_a) annotation (Line(
              points={{-52,200},{-300,200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(opa.port_b, opa_b) annotation (Line(
              points={{52,200},{302,200}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,-300},
                    {300,300}})), Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-300,-300},{300,300}}), graphics={
                Rectangle(
                  extent={{-290,202},{298,198}},
                  lineColor={0,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-70,254},{-52,140}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Polygon(
                  points={{2,208},{4,208},{6,204},{8,198},{8,194},{6,188},{0,184},{-4,180},
                      {-12,178},{-16,182},{-22,188},{-24,198},{-22,204},{-20,208},{-18,210},
                      {-16,212},{-12,214},{-8,214},{-2,212},{2,208}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{34,254},{52,140}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{-314,336},{286,302}},
                  lineColor={0,0,255},
                  textString="%name")}),
            Documentation(info="<html>
<p>
This is the base class that is used to model opaque constructions in the room model.
</p>
<p>
The surface azimuth is defined in
<a href=\"modelica://Buildings.HeatTransfer.Types.Azimuth\">
Buildings.HeatTransfer.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.HeatTransfer.Types.Tilt\">
Buildings.HeatTransfer.Types.Tilt</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
December 14, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialConstruction;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Rooms.Constructions\">Buildings.Rooms.Constructions</a>.
</p>
</html>"));
      end BaseClasses;
      annotation (
      preferredView="info", Documentation(info="<html>
This package contains models for constructions that are
used in the room model.
</html>"));
    end Constructions;

    package BaseClasses "Package with base classes for Buildings.Rooms"
      extends Modelica.Icons.BasesPackage;

      model AirHeatMassBalanceMixed
        "Heat and mass balance of the air, assuming completely mixed air"
        extends Buildings.Rooms.BaseClasses.ConstructionRecords;
        extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
        parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        // Port definitions
        parameter Integer nPorts=0 "Number of ports"
          annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
        parameter Boolean homotopyInitialization "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        parameter Modelica.SIunits.Volume V "Volume";

        parameter Buildings.HeatTransfer.Types.InteriorConvection conMod
          "Convective heat transfer model for opaque constructions"
          annotation (Dialog(group="Convective heat transfer"));
        parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed
          "Constant convection coefficient for opaque constructions"
          annotation (Dialog(group="Convective heat transfer",
                             enable=(conMod == Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));

        parameter Boolean haveShade
          "Set to true if at least one window has an interior or exterior shade";

        // Input/output signals
        Modelica.Blocks.Interfaces.RealInput uSha[NConExtWin] if haveShade
          "Input connector, used to scale the surface area to take into account an operable shading device, 0: unshaded; 1: fully shaded"
          annotation (Placement(transformation(extent={{-280,180},{-240,220}}),
              iconTransformation(extent={{-256,192},{-240,208}})));
        Modelica.Blocks.Interfaces.RealInput QRadAbs_flow[NConExtWin](
        final unit="W") if
           haveShade
          "Total net radiation that is absorbed by the shade (positive if absorbed)"
          annotation (Placement(transformation(extent={{-280,70},{-240,110}}),
              iconTransformation(extent={{-260,90},{-240,110}})));
        Modelica.Blocks.Interfaces.RealOutput TSha[NConExtWin](
         final unit="K",
         final quantity="ThermodynamicTemperature") if
            haveShade "Shade temperature"
          annotation (Placement(transformation(extent={{-240,50},{-260,70}})));

        // Fluid port
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
            redeclare each final package Medium = Medium)
          "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-40,-10},{40,10}},
            origin={0,-238})));

        // Heat ports
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorAir
          "Heat port to air volume"
          annotation (Placement(transformation(extent={{-250,-10},{-230,10}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExt[NConExt] if
           haveConExt
          "Heat port that connects to room-side surface of exterior constructions"
                                    annotation (Placement(transformation(extent={{230,210},
                  {250,230}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExtWin[NConExtWin] if
           haveConExtWin
          "Heat port that connects to room-side surface of exterior constructions that contain a window"
                                    annotation (Placement(transformation(extent={{230,170},
                  {250,190}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns[NConExtWin] if
           haveConExtWin
          "Heat port that connects to room-side surface of unshaded glass"
                                    annotation (Placement(transformation(extent={{230,110},
                  {250,130}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha[NConExtWin] if
             haveShade
          "Heat port that connects to room-side surface of shaded glass"
                                    annotation (Placement(transformation(extent={{230,70},
                  {250,90}}), iconTransformation(extent={{230,70},
                  {250,90}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExtWinFra[NConExtWin] if
           haveConExtWin
          "Heat port that connects to room-side surface of window frame"
                                    annotation (Placement(transformation(extent={{232,-10},
                  {252,10}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conPar_a[NConPar] if
           haveConPar
          "Heat port that connects to room-side surface a of partition constructions"
                                    annotation (Placement(transformation(extent={{232,-70},
                  {252,-50}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conPar_b[NConPar] if
           haveConPar
          "Heat port that connects to room-side surface b of partition constructions"
                                    annotation (Placement(transformation(extent={{232,
                  -110},{252,-90}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conBou[NConBou] if
           haveConBou
          "Heat port that connects to room-side surface of constructions that expose their other surface to the outside"
                                    annotation (Placement(transformation(extent={{232,
                  -170},{252,-150}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conSurBou[NSurBou] if
           haveSurBou
          "Heat port to surfaces of models that compute the heat conduction outside of this room"
                                    annotation (Placement(transformation(extent={{231,
                  -230},{251,-210}})));

        // Mixing volume
        Fluid.MixingVolumes.MixingVolume vol(
          redeclare package Medium = Medium,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          final V=V,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start,
          final C_nominal=C_nominal,
          final m_flow_nominal = m_flow_nominal,
          final prescribedHeatFlowRate = true,
          final nPorts=nPorts,
          m_flow_small=1E-4*abs(m_flow_nominal),
          allowFlowReversal=true) "Room air volume"
          annotation (Placement(transformation(extent={{10,-210},{-10,-190}})));

        // Convection models
        HeatTransfer.Convection.Interior convConExt[NConExt](
          final A=AConExt,
          final til = datConExt.til,
          each conMod=conMod,
          each hFixed=hFixed,
          each final homotopyInitialization=homotopyInitialization) if
             haveConExt "Convective heat transfer"
          annotation (Placement(transformation(extent={{120,210},{100,230}})));

        HeatTransfer.Convection.Interior convConExtWin[NConExtWin](
          final A=AConExtWinOpa,
          final til = datConExtWin.til,
          each conMod=conMod,
          each hFixed=hFixed,
          each final homotopyInitialization=homotopyInitialization) if
             haveConExtWin "Convective heat transfer"
          annotation (Placement(transformation(extent={{120,170},{100,190}})));

        HeatTransfer.Windows.InteriorHeatTransferConvective convConWin[NConExtWin](
          final fFra=datConExtWin.fFra,
          final haveExteriorShade={datConExtWin[i].glaSys.haveExteriorShade for i in 1:NConExtWin},
          final haveInteriorShade={datConExtWin[i].glaSys.haveInteriorShade for i in 1:NConExtWin},
          final A=AConExtWinGla + AConExtWinFra) if
             haveConExtWin "Model for convective heat transfer at window"
          annotation (Placement(transformation(extent={{98,110},{118,130}})));

        HeatTransfer.Convection.Interior convConPar_a[nConPar](
          final A=AConPar,
          final til=Modelica.Constants.pi .- datConPar.til,
          each conMod=conMod,
          each hFixed=hFixed,
          each final homotopyInitialization=homotopyInitialization) if
             haveConPar "Convective heat transfer"
          annotation (Placement(transformation(extent={{120,-70},{100,-50}})));

        HeatTransfer.Convection.Interior convConPar_b[nConPar](
          final A=AConPar,
          final til = datConPar.til,
          each conMod=conMod,
          each hFixed=hFixed,
          each final homotopyInitialization=homotopyInitialization) if
             haveConPar "Convective heat transfer"
          annotation (Placement(transformation(extent={{120,-110},{100,-90}})));

        HeatTransfer.Convection.Interior convConBou[nConBou](
          final A=AConBou,
          final til = datConBou.til,
          each conMod=conMod,
          each hFixed=hFixed,
          each final homotopyInitialization=homotopyInitialization) if
             haveConBou "Convective heat transfer"
          annotation (Placement(transformation(extent={{120,-170},{100,-150}})));

        HeatTransfer.Convection.Interior convSurBou[nSurBou](
          final A=ASurBou,
          final til = surBou.til,
          each conMod=conMod,
          each hFixed=hFixed,
          each final homotopyInitialization=homotopyInitialization) if
             haveSurBou "Convective heat transfer"
          annotation (Placement(transformation(extent={{122,-230},{102,-210}})));

        // Surface areas
      protected
        final parameter Modelica.SIunits.Area AConExt[NConExt] = datConExt.A
          "Areas of exterior constructions";
        final parameter Modelica.SIunits.Area AConExtWinOpa[NConExtWin] = datConExtWin.AOpa
          "Opaque areas of exterior construction that have a window";
        final parameter Modelica.SIunits.Area AConExtWinGla[NConExtWin] = (1 .- datConExtWin.fFra) .* datConExtWin.AWin
          "Glass areas of exterior construction that have a window";
        final parameter Modelica.SIunits.Area AConExtWinFra[NConExtWin] = datConExtWin.fFra .* datConExtWin.AWin
          "Frame areas of exterior construction that have a window";
        final parameter Modelica.SIunits.Area AConPar[NConPar] = datConPar.A
          "Areas of partition constructions";
        final parameter Modelica.SIunits.Area AConBou[NConBou] = datConBou.A
          "Areas of constructions with exterior boundary conditions exposed to outside of room model";
        final parameter Modelica.SIunits.Area ASurBou[NSurBou] = surBou.A
          "Area of surface models of constructions that are modeled outside of this room";

        // Thermal collectors
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConExt(final m=nConExt) if
             haveConExt
          "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={48,220})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConExtWin(final m=nConExtWin) if
             haveConExtWin
          "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={48,180})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConWin(final m=nConExtWin) if
             haveConExtWin
          "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={50,120})));

        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConPar_a(final m=nConPar) if
             haveConPar
          "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={52,-60})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConPar_b(final m=nConPar) if
             haveConPar
          "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={50,-100})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConBou(final m=nConBou) if
             haveConBou
          "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={50,-160})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConSurBou(final m=nSurBou) if
             haveSurBou
          "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={52,-220})));

      equation
        connect(convConPar_a.fluid,theConConPar_a. port_a) annotation (Line(
            points={{100,-60},{62,-60}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConPar_b.fluid,theConConPar_b. port_a) annotation (Line(
            points={{100,-100},{60,-100}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConBou.fluid,theConConBou. port_a) annotation (Line(
            points={{100,-160},{60,-160}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convSurBou.fluid,theConSurBou. port_a) annotation (Line(
            points={{102,-220},{62,-220}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConPar_a.port_b,vol. heatPort) annotation (Line(
            points={{42,-60},{20,-60},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConPar_b.port_b,vol. heatPort) annotation (Line(
            points={{40,-100},{20,-100},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConBou.port_b,vol. heatPort) annotation (Line(
            points={{40,-160},{20,-160},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConSurBou.port_b,vol. heatPort) annotation (Line(
            points={{42,-220},{20,-220},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conExtWinFra,convConWin. frame) annotation (Line(
            points={{242,4.44089e-16},{160,4.44089e-16},{160,100},{115,100},{115,110}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConExt.solid, conExt) annotation (Line(
            points={{120,220},{240,220}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConExt.fluid,theConConExt. port_a) annotation (Line(
            points={{100,220},{58,220}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConExt.port_b,vol. heatPort) annotation (Line(
            points={{38,220},{20,220},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConExtWin.port_b,vol. heatPort) annotation (Line(
            points={{38,180},{20,180},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConExtWin.fluid,theConConExtWin. port_a) annotation (Line(
            points={{100,180},{58,180}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConExtWin.solid, conExtWin) annotation (Line(
            points={{120,180},{240,180}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConWin.port_b,vol. heatPort) annotation (Line(
            points={{40,120},{20,120},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConWin.air,theConConWin. port_a) annotation (Line(
            points={{98,120},{60,120}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConWin.glaSha, glaSha) annotation (Line(
            points={{118,118},{166,118},{166,80},{240,80}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConWin.glaUns, glaUns) annotation (Line(
            points={{118,122},{180,122},{180,120},{240,120}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConPar_a.solid, conPar_a) annotation (Line(
            points={{120,-60},{242,-60}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConPar_b.solid, conPar_b) annotation (Line(
            points={{120,-100},{242,-100}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConBou.solid, conBou) annotation (Line(
            points={{120,-160},{242,-160}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convSurBou.solid, conSurBou) annotation (Line(
            points={{122,-220},{241,-220}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(vol.ports, ports) annotation (Line(
            points={{0,-210},{0,-238}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(heaPorAir, vol.heatPort) annotation (Line(
            points={{-240,0},{20,0},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(uSha, convConWin.uSha) annotation (Line(
            points={{-260,200},{0,200},{0,150},{82,150},{82,128},{97.2,128}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(convConWin.QRadAbs_flow, QRadAbs_flow) annotation (Line(
            points={{102,109},{102,90},{-260,90}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(convConWin.TSha, TSha) annotation (Line(
            points={{108,109},{108,60},{-250,60}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
          preferredView="info",
          Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-240,-240},{240,
                  240}}), graphics),
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-240,-240},{240,240}}),
                          graphics={
              Text(
                extent={{-230,182},{-188,216}},
                lineColor={0,0,127},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                textString="uSha"),
              Text(
                extent={{-232,82},{-190,116}},
                lineColor={0,0,127},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                textString="QRadAbs"),
              Text(
                extent={{-228,44},{-186,78}},
                lineColor={0,0,127},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                textString="TSha"),
                Rectangle(
                extent={{-144,184},{148,-200}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={170,213,255},
                fillPattern=FillPattern.Sphere),
              Text(
                extent={{-84,232},{94,282}},
                lineColor={0,0,127},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                textString="%name")}),
          Documentation(info="<html>
<p>
This model computes the heat and mass balance of the air.
The model assumes a completely mixed air volume.
</p>
</html>",
      revisions="<html>
<ul>
<li>
July 12, 2013, by Michael Wetter:<br/>
First implementation to facilitate the separation of the convective and radiative model.
</li>
</ul>
</html>"));
      end AirHeatMassBalanceMixed;

      model ExteriorBoundaryConditions
        "Model for convection and radiation bounary condition of exterior constructions"
        parameter Integer nCon(min=1) "Number of exterior constructions"
        annotation (Dialog(group="Exterior constructions"));
        parameter Modelica.SIunits.Angle lat "Latitude";

        parameter Boolean linearizeRadiation
          "Set to true to linearize emissive power";

        replaceable parameter ParameterConstruction conPar[nCon] constrainedby
          ParameterConstruction "Records for construction"
          annotation (Placement(transformation(extent={{174,-214},{194,-194}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a opa_a[nCon]
          "Heat port at surface a of opaque construction"
          annotation (Placement(transformation(extent={{-310,190},{-290,210}})));
        parameter Buildings.HeatTransfer.Types.ExteriorConvection conMod=
        Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind
          "Convective heat transfer model for opaque part of the constructions"
          annotation (Dialog(group="Convective heat transfer"));
        parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed=10.0
          "Constant convection coefficient for opaque part of the constructions"
          annotation (Dialog(group="Convective heat transfer",
                             enable=(conMod == Buildings.HeatTransfer.Types.ExteriorConvection.Fixed)));

        // The convection coefficients are not final to allow a user to individually
        // assign them.
        // We reassign the tilt since a roof has been declared in the room model as the
        // ceiling (of the room)
        HeatTransfer.Convection.Exterior conOpa[nCon](
          A=AOpa,
          final til=Modelica.Constants.pi*ones(nCon) .- conPar[:].til,
          final azi=conPar[:].azi,
          each conMod=conMod,
          each hFixed=hFixed) "Convection model for opaque part of the wall"
          annotation (Placement(transformation(extent={{-180,160},{-140,200}})));

        SkyRadiationExchange skyRadExc(
          final n=nCon,
          final A=AOpa,
          final absIR=conPar[:].layers.absIR_a,
          vieFacSky={(Modelica.Constants.pi - conPar[i].til)./Modelica.Constants.pi for i in 1:nCon})
          "Infrared radiative heat exchange with sky"
          annotation (Placement(transformation(extent={{-140,240},{-180,280}})));
        BoundaryConditions.WeatherData.Bus weaBus
          annotation (Placement(transformation(extent={{234,32},{254,52}}),
              iconTransformation(extent={{192,-10},{254,52}})));

        BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirTil[
                  nCon](
          each final lat=lat,
          final til=conPar[:].til,
          final azi=conPar[:].azi) "Direct solar irradiation on the surface"
          annotation (Placement(transformation(extent={{220,120},{200,140}})));
        BoundaryConditions.SolarIrradiation.DiffusePerez HDifTil[nCon](
          each final lat=lat,
          final til=conPar[:].til,
          final azi=conPar[:].azi) "Diffuse solar irradiation"
          annotation (Placement(transformation(extent={{220,80},{200,100}})));
        Modelica.Blocks.Math.Add HTotConExt[nCon](
          final k1=conPar[:].layers.absSol_a .* AOpa,
          final k2=conPar[:].layers.absSol_a .* AOpa) "Total solar irradiation"
          annotation (Placement(transformation(extent={{40,100},{20,120}})));
        Buildings.HeatTransfer.Sources.PrescribedHeatFlow solHeaGaiConExt[nCon]
          "Total solar heat gain of the surface"
          annotation (Placement(transformation(extent={{0,100},{-20,120}})));

      protected
        parameter Modelica.SIunits.Area AOpa[nCon]=conPar[:].A
          "Area of opaque construction";

        Buildings.HeatTransfer.Sources.PrescribedTemperature TAirConExt[
          nCon] "Outside air temperature for exterior constructions"
          annotation (Placement(transformation(extent={{8,160},{-32,200}})));
        Modelica.Blocks.Routing.Replicator repConExt(nout=nCon)
          "Signal replicator"
          annotation (Placement(transformation(extent={{100,170},{80,190}})));

        Modelica.Blocks.Routing.Replicator repConExt1(
                                                     nout=nCon)
          "Signal replicator"
          annotation (Placement(transformation(extent={{130,200},{110,220}})));
        Modelica.Blocks.Routing.Replicator repConExt2(
                                                     nout=nCon)
          "Signal replicator"
          annotation (Placement(transformation(extent={{180,220},{160,240}})));

      equation
        connect(conOpa.solid, opa_a) annotation (Line(
            points={{-180,180},{-240,180},{-240,200},{-300,200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(skyRadExc.port, opa_a) annotation (Line(
            points={{-180,260},{-212,260},{-212,260},{-240,260},{-240,200},{-300,200}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(TAirConExt.port, conOpa.fluid) annotation (Line(
            points={{-32,180},{-140,180}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(repConExt.y, TAirConExt.T) annotation (Line(
            points={{79,180},{12,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExt.u, weaBus.TDryBul) annotation (Line(
            points={{102,180},{244,180},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(skyRadExc.TOut, weaBus.TDryBul) annotation (Line(
            points={{-136,252},{244,252},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(skyRadExc.TBlaSky, weaBus.TBlaSky) annotation (Line(
            points={{-136,268},{244,268},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        for i in 1:nCon loop
        connect(weaBus, HDirTil[i].weaBus) annotation (Line(
            points={{244,42},{244,130},{220,130}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(HDifTil[i].weaBus, weaBus) annotation (Line(
            points={{220,90},{244,90},{244,42}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
         end for;
        connect(HTotConExt.y, solHeaGaiConExt.Q_flow) annotation (Line(
            points={{19,110},{5.55112e-16,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solHeaGaiConExt.port, opa_a) annotation (Line(
            points={{-20,110},{-240,110},{-240,200},{-300,200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(HDirTil.H, HTotConExt.u1) annotation (Line(
            points={{199,130},{60,130},{60,116},{42,116}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HDifTil.H, HTotConExt.u2) annotation (Line(
            points={{199,90},{60,90},{60,104},{42,104}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExt2.u, weaBus.winDir) annotation (Line(
            points={{182,230},{244,230},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(repConExt1.u, weaBus.winSpe) annotation (Line(
            points={{132,210},{244,210},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(repConExt1.y, conOpa.v) annotation (Line(
            points={{109,210},{-194,210},{-194,200},{-184,200}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExt2.y, conOpa.dir) annotation (Line(
            points={{159,230},{-200,230},{-200,190},{-184,190}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,-300},
                  {300,300}})), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-300,-300},{300,300}}), graphics={
              Rectangle(
                extent={{-160,280},{280,-250}},
                fillColor={230,243,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
                                     Ellipse(
                extent={{164,262},{270,162}},
                lineColor={255,255,0},
                fillColor={255,213,170},
                fillPattern=FillPattern.Sphere),
              Rectangle(
                extent={{-220,280},{-160,-280}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-160,-250},{280,-280}},
                lineColor={0,0,0},
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-168,346},{212,280}},
                lineColor={0,0,255},
                textString="%name")}),
              Documentation(info="<html>
This model computes the boundary conditions for the outside-facing surface of
opaque constructions.
<p>
The model computes the infrared, solar, and convective heat exchange
between these surfaces and the exterior temperature and the sky temperature.
Input into this model are weather data that may be obtained from
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">
Buildings.BoundaryConditions.WeatherData</a>.
</p>
<p>
In this model, the solar radiation data are converted from horizontal irradiation to
irradiation on tilted surfaces using models from the package
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation\">
Buildings.BoundaryConditions.SolarIrradiation</a>.
The convective heat transfer between the exterior surface of the opaque constructions
is computed using
<a href=\"modelica://Buildings.HeatTransfer.Convection\">
Buildings.HeatTransfer.Convection</a>.
</p>
<p>
The heat transfer of windows are not computed in this model. They are implemented in
<a href=\"modelica://Buildings.Rooms.BaseClasses.ExteriorBoundaryConditionsWithWindow\">
Buildings.Rooms.BaseClasses.ExteriorBoundaryConditionsWithWindow</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
August 9, 2011 by Michael Wetter:<br/>
Changed assignment of tilt in instance <code>conOpa</code>.
This fixes the bug in <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/35\">issue 35</a>
that led to the wrong solar radiation gain for roofs and floors.
(Since the tilt has been changed in the model
<a href=\"modelica://Buildings.Rooms.MixedAir\">
Buildings.Rooms.MixedAir</a> at the place where it makes an instance of this model,
the change in the tilt parameter of the convective heat transfer model was required.)
</li>
<li>
March 28, 2011, by Michael Wetter:<br/>
Propaged parameter <code>hFixed</code> to top-level of the model.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Removed default value for convection model.
</li>
<li>
November 23, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ExteriorBoundaryConditions;

      model ExteriorBoundaryConditionsWithWindow
        "Model for exterior boundary conditions for constructions with a window"
        extends Buildings.Rooms.BaseClasses.ExteriorBoundaryConditions(
         final AOpa=conPar[:].AOpa,
         redeclare Buildings.Rooms.BaseClasses.ParameterConstructionWithWindow conPar);

        final parameter Modelica.SIunits.Area AWin[nCon] = conPar[:].hWin .* conPar[:].wWin
          "Window area"
          annotation (Dialog(group="Glazing system"));

        final parameter Boolean haveExteriorShade[nCon] = conPar[:].glaSys.haveExteriorShade
          "Set to true if window has exterior shade (at surface a)"
          annotation (Dialog(group="Shading"));
        final parameter Boolean haveInteriorShade[nCon] = conPar[:].glaSys.haveInteriorShade
          "Set to true if window has interior shade (at surface b)"
          annotation (Dialog(group="Shading"));

        // fixme: this should use Modelica.Math.BooleanVectors.anyTrue
        final parameter Boolean haveShade=
          Modelica.Math.BooleanVectors.anyTrue(haveExteriorShade) or
          Modelica.Math.BooleanVectors.anyTrue(haveInteriorShade)
          "Set to true if window system has a shade"
          annotation (Dialog(group="Shading"), Evaluate=true);

        final parameter Boolean haveOverhangOrSideFins=
          Modelica.Math.BooleanVectors.anyTrue(conPar.haveOverhangOrSideFins)
          "Flag, true if the room has at least one window with either an overhang or side fins";

        Buildings.HeatTransfer.Windows.FixedShade sha[nCon](
          final conPar=conPar,
          each lat=lat,
          azi=conPar.azi) if
             haveOverhangOrSideFins "Shade due to overhang or side fins"
          annotation (Placement(transformation(extent={{140,100},{120,120}})));

        Modelica.Blocks.Interfaces.RealInput uSha[nCon](min=0, max=1) if
             haveShade
          "Control signal for the shading device, 0: unshaded; 1: fully shaded"
          annotation (Placement(transformation(extent={{-340,80},{-300,120}}),
              iconTransformation(extent={{-340,80},{-300,120}})));

        Modelica.Blocks.Interfaces.RealInput QAbsSolSha_flow[nCon](
          final unit="W", quantity="Power") "Solar radiation absorbed by shade"
          annotation (Placement(transformation(extent={{-340,40},{-300,80}})));

        HeatTransfer.Windows.ExteriorHeatTransfer conExtWin[nCon](
          final A=conPar[:].AWin,
          final fFra=conPar[:].fFra,
          each final linearizeRadiation = linearizeRadiation,
          final vieFacSky={(Modelica.Constants.pi - conPar[i].til) ./ Modelica.Constants.pi for i in 1:nCon},
          final absIRSha_air=conPar[:].glaSys.shade.absIR_a,
          final absIRSha_glass=conPar[:].glaSys.shade.absIR_b,
          final tauIRSha_air=conPar[:].glaSys.shade.tauIR_a,
          final tauIRSha_glass=conPar[:].glaSys.shade.tauIR_b,
          final haveExteriorShade=haveExteriorShade,
          final haveInteriorShade=haveInteriorShade)
          "Exterior convection of the window"
          annotation (Placement(transformation(extent={{20,-120},{-40,-60}})));

        SkyRadiationExchange skyRadExcWin(
          final n=nCon,
          each final absIR=conPar[:].glaSys.absIRFra,
          vieFacSky={(Modelica.Constants.pi - conPar[i].til) ./ Modelica.Constants.pi for i in
                  1:nCon},
          each final A=conPar[:].AWin .* conPar[:].fFra)
          "Infrared radiative heat exchange between window frame and sky"
          annotation (Placement(transformation(extent={{-140,-280},{-180,-240}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutUns[nCon]
          "Outgoing radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-300,-30},{-320,-10}}),
              iconTransformation(extent={{-300,-30},{-320,-10}})));
        HeatTransfer.Interfaces.RadiosityInflow JInUns[nCon]
          "Incoming radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-320,10},{-300,30}}),
              iconTransformation(extent={{-320,10},{-300,30}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutSha[nCon] if
             haveShade
          "Outgoing radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-300,-210},{-320,-190}}),
              iconTransformation(extent={{-300,-210},{-320,-190}})));
        HeatTransfer.Interfaces.RadiosityInflow JInSha[nCon] if
             haveShade
          "Incoming radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-320,-170},{-300,-150}}),
              iconTransformation(extent={{-320,-170},{-300,-150}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns[nCon]
          "Heat port at unshaded glass of exterior-facing surface"
                                                          annotation (Placement(transformation(extent={{-310,
                  -90},{-290,-70}}), iconTransformation(extent={{-310,-90},{-290,
                  -70}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha[nCon] if
             haveShade "Heat port at shaded glass of exterior-facing surface"
          annotation (Placement(transformation(extent={{-310,-130},{-290,-110}}),
              iconTransformation(extent={{-310,-130},{-290,-110}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a fra[nCon](T(each nominal=
                300, each start=283.15))
          "Heat port at frame of exterior-facing surface"                                   annotation (Placement(transformation(extent={{-310,
                  -270},{-290,-250}}), iconTransformation(extent={{-310,-270},{-290,
                  -250}})));
        Modelica.Blocks.Math.Add HTotConExtWinFra[nCon](
           final k1=conPar[:].fFra .* conPar[:].glaSys.absSolFra .* conPar[:].AWin,
           final k2=conPar[:].fFra .* conPar[:].glaSys.absSolFra .* conPar[:].AWin)
          "Total solar irradiation on window frame"
          annotation (Placement(transformation(extent={{40,60},{20,80}})));
        Buildings.HeatTransfer.Sources.PrescribedHeatFlow solHeaGaiConWin[nCon]
          "Total solar heat gain of the window frame"
          annotation (Placement(transformation(extent={{0,60},{-20,80}})));
        Modelica.Blocks.Interfaces.RealOutput HDir[nCon](
           each final quantity="RadiantEnergyFluenceRate",
           each final unit="W/m2") "Direct solar irradition on tilted surface"
          annotation (Placement(transformation(extent={{300,110},{320,130}})));
        Modelica.Blocks.Interfaces.RealOutput HDif[nCon](
           each final quantity="RadiantEnergyFluenceRate",
           each final unit="W/m2")
          "Diffuse solar irradiation on tilted surface"
          annotation (Placement(transformation(extent={{300,50},{320,70}})));
        Modelica.Blocks.Interfaces.RealOutput inc[nCon](
          each final quantity="Angle",
          each final unit="rad",
          each displayUnit="deg") "Incidence angle"
          annotation (Placement(transformation(extent={{300,170},{320,190}})));

      protected
        Buildings.HeatTransfer.Sources.PrescribedTemperature TAirConExtWin[
          nCon] "Outside air temperature for window constructions"
          annotation (Placement(transformation(extent={{160,-90},{120,-50}})));
        Modelica.Blocks.Routing.Replicator repConExtWin(final nout=nCon)
          "Signal replicator"
          annotation (Placement(transformation(extent={{220,-80},{200,-60}})));
        Modelica.Blocks.Routing.Replicator repConExtWinVWin(final nout=nCon)
          "Signal replicator"
          annotation (Placement(transformation(extent={{140,-22},{120,-2}})));
        Modelica.Blocks.Routing.Replicator repConExtWinTSkyBla(final nout=nCon)
          "Signal replicator"
          annotation (Placement(transformation(extent={{220,-112},{200,-92}})));
      equation
        connect(uSha, conExtWin.uSha)
                                annotation (Line(
            points={{-320,100},{-140,100},{-140,-40},{40,-40},{40,-66},{22.4,-66}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(JInUns,conExtWin. JInUns) annotation (Line(
            points={{-310,20},{-200,20},{-200,-72},{-43,-72}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(conExtWin.JOutUns,JOutUns)  annotation (Line(
            points={{-43,-66},{-196.45,-66},{-196.45,-20},{-310,-20}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(conExtWin.glaUns,glaUns)  annotation (Line(
            points={{-40,-84},{-192,-84},{-192,-80},{-300,-80}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conExtWin.glaSha,glaSha)  annotation (Line(
            points={{-40,-96},{-190,-96},{-190,-120},{-300,-120}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conExtWin.JOutSha,JOutSha)  annotation (Line(
            points={{-43,-108},{-176,-108},{-176,-200},{-310,-200}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(conExtWin.JInSha,JInSha)  annotation (Line(
            points={{-43,-114},{-184.45,-114},{-184.45,-160},{-310,-160}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(conExtWin.frame,fra)  annotation (Line(
            points={{-31,-120},{-31,-220},{-260,-220},{-260,-260},{-300,-260}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(TAirConExtWin.port,conExtWin. air) annotation (Line(
            points={{120,-70},{90,-70},{90,-90},{20,-90}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(TAirConExtWin.T,repConExtWin. y) annotation (Line(
            points={{164,-70},{199,-70}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExtWin.u, weaBus.TDryBul) annotation (Line(
            points={{222,-70},{244,-70},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(repConExtWinVWin.y,conExtWin. vWin) annotation (Line(
            points={{119,-12},{50,-12},{50,-78},{22.4,-78}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExtWinVWin.u, weaBus.winSpe) annotation (Line(
            points={{142,-12},{192,-12},{192,-14},{244,-14},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(HTotConExtWinFra.y, solHeaGaiConWin.Q_flow) annotation (Line(
            points={{19,70},{0,70}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solHeaGaiConWin.port, fra) annotation (Line(
            points={{-20,70},{-60,70},{-60,-220},{-260,-220},{-260,-260},{-300,-260}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(HDifTil.H, HDif) annotation (Line(
            points={{199,90},{72,90},{72,60},{310,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HDirTil.inc, inc) annotation (Line(
            points={{199,126},{180,126},{180,112},{260,112},{260,180},{310,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HTotConExtWinFra.u2, HDifTil.H) annotation (Line(
            points={{42,64},{72,64},{72,90},{199,90}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyRadExcWin.TOut, weaBus.TDryBul)
                                                annotation (Line(
            points={{-136,-268},{244,-268},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(skyRadExcWin.TBlaSky, weaBus.TBlaSky)
                                                   annotation (Line(
            points={{-136,-252},{244,-252},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(skyRadExcWin.port, fra) annotation (Line(
            points={{-180,-260},{-242,-260},{-242,-260},{-300,-260}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(repConExtWin.y, conExtWin.TOut) annotation (Line(
            points={{199,-70},{180,-70},{180,-114.6},{23,-114.6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExtWinTSkyBla.y, conExtWin.TBlaSky) annotation (Line(
            points={{199,-102},{23,-102}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExtWinTSkyBla.u, weaBus.TBlaSky) annotation (Line(
            points={{222,-102},{244,-102},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        for i in 1:nCon loop
          connect(sha[i].weaBus, weaBus) annotation (Line(
            points={{140,110},{244,110},{244,42}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        end for;

        connect(HDirTil.inc, sha.incAng) annotation (Line(
            points={{199,126},{168,126},{168,104},{142,104}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(QAbsSolSha_flow, conExtWin.QSolAbs_flow) annotation (Line(
            points={{-320,60},{-160,60},{-160,-140},{-10,-140},{-10,-123}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(sha.HDirTilUns, HDirTil.H) annotation (Line(
            points={{142,116},{160,116},{160,130},{199,130}},
            color={0,0,127},
            smooth=Smooth.None));

        if haveOverhangOrSideFins then
          connect(sha.HDirTil, HTotConExtWinFra.u1) annotation (Line(
            points={{119,116},{100,116},{100,76},{42,76}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(sha.HDirTil, HDir) annotation (Line(
            points={{119,116},{100,116},{100,70},{280,70},{280,120},{310,120}},
            color={0,0,127},
            smooth=Smooth.None));
        else
          connect(HDirTil.H, HTotConExtWinFra.u1) annotation (Line(
              points={{199,130},{100,130},{100,76},{42,76}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDirTil.H, HDir) annotation (Line(
            points={{199,130},{100,130},{100,70},{280,70},{280,120},{310,120}},
            color={0,0,127},
            smooth=Smooth.None));
        end if;

        annotation (Icon(graphics={
              Rectangle(
                extent={{-220,180},{-160,-102}},
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-212,180},{-202,-102}},
                lineColor={0,0,0},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.Dash),
              Rectangle(
                extent={{-180,180},{-170,-102}},
                lineColor={0,0,0},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.Dash)}),
          Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-300,-300},{300,
                  300}}), graphics),
          Documentation(info="<html>
This model computes the boundary conditions for the outside-facing surface of
opaque constructions and of windows.
<p>
The model computes the infrared, solar, and convective heat exchange
between these surfaces and the exterior temperature and the sky temperature.
Input into this model are weather data that may be obtained from
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">
Buildings.BoundaryConditions.WeatherData</a>.
</p>
<p>
This model extends
<a href=\"modelica://Buildings.Rooms.BaseClasses.ExteriorBoundaryConditions\">
Buildings.Rooms.BaseClasses.ExteriorBoundaryConditions</a>,
which models the boundary conditions for the opaque constructions,
and then implements the boundary condition for windows by using
the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.ExteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.ExteriorHeatTransfer</a>.
</html>",       revisions="<html>
<ul>
<li>
October 28, 2014, by Michael Wetter:<br/>
Replaced
<code>final parameter Boolean haveShade=haveExteriorShade[1] or haveInteriorShade[1]</code>
with a test for all elements of the vector.
This was not possible in earlier versions of Dymola, but now works.
</li>
<li>
October 20, 2014, by Michael Wetter:<br/>
Conditionally removed shade if not present. This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/234\">
issue 234</a>.
</li>
<li>
February 8 2012, by Michael Wetter:<br/>
Changed model to use new implementation of
<a href=\"modelica://Buildings.HeatTransfer.Radiosity.OutdoorRadiosity\">
Buildings.HeatTransfer.Radiosity.OutdoorRadiosity</a>.
This change leads to the use of the same equations for the radiative
heat transfer between window and ambient as is used for
the opaque constructions.
</li>
<li>
August 9, 2011, by Michael Wetter:<br/>
Fixed bug that caused too high a surface temperature of the window frame.
The previous version did not compute the infrared radiation exchange between the
window frame and the sky. This has been corrected by adding the instance
<code>skyRadExcWin</code> and adding the parameter <code>absIRFra</code>.
This closes ticket <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/36\">issue 36</a>.
</li>
<li>
November 23, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ExteriorBoundaryConditionsWithWindow;

      model HeatGain "Model to convert internal heat gain signals"
        extends Buildings.BaseClasses.BaseIcon;

        replaceable package Medium =
           Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choicesAllMatching = true);

        parameter Modelica.SIunits.Area AFlo "Floor area";
        parameter Modelica.SIunits.Temperature TWat=273.15+34
          "Temperature at which water vapor is released";

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a QCon_flow
          "Convective heat gain"    annotation (Placement(transformation(extent={{90,-10},
                  {110,10}}), iconTransformation(extent={{90,-10},
                  {110,10}})));

      public
        Modelica.Blocks.Interfaces.RealInput qGai_flow[3]
          "Radiant, convective and latent heat input into room (positive if heat gain)"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput QRad_flow "Radiative heat gain"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));
        Modelica.Fluid.Interfaces.FluidPort_b QLat_flow(redeclare final package
            Medium =
              Medium) "Latent heat gain"
          annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
      protected
        Modelica.SIunits.MassFlowRate mWat_flow
          "Water vapor flow rate released by latent gain";

        parameter Modelica.SIunits.SpecificEnergy h_fg = Medium.enthalpyOfCondensingGas(TWat)
          "Latent heat of water vapor";
       // constant Medium.MassFraction Xi[Medium.nXi] = {1}
       //   "Species concentration (water vapor only)";

      protected
        parameter Real s[Medium.nX](each fixed=false)
          "Vector with zero everywhere except where water vapor is";
      initial algorithm
        for i in 1:Medium.nX loop
          if ( Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="water",
                                                  caseSensitive=false)) then
            s[i] :=1;
          else
            s[i] :=0;
          end if;
         end for;
         assert(Medium.nX == 1 or abs(1-sum(s)) < 1E-4, "Substance 'water' is not present in medium '"
                        + Medium.mediumName + "'.\n"
                        + "Change medium model to one that has 'water' as a substance.");
      equation
        QRad_flow = qGai_flow[1]*AFlo;
        QCon_flow.Q_flow = -qGai_flow[2]*AFlo;

        // Interface to fluid port
        // If a medium does not contain water vapor, then h_fg is equal to zero.
        if Medium.nXi == 0 or (h_fg == 0) then
          mWat_flow = 0;
        else
          mWat_flow = qGai_flow[3]*AFlo/h_fg;
        end if;

        QLat_flow.C_outflow  = fill(0, Medium.nC);
        QLat_flow.h_outflow  = h_fg;
        QLat_flow.Xi_outflow = s[1:Medium.nXi];
        QLat_flow.m_flow     = if (h_fg > 0) then
                                 -qGai_flow[3]*AFlo/h_fg else
                                  0;

       annotation(Documentation(info="<html>
This model computes the radiant, convective and latent heat flow.
Input into this model are these three components in units of [W/m2].
The inputs need to be positive quantities if heat or moisture is added
to the room.
The outputs are
<ul>
<li>
the radiant heat flow in Watts,
</li>
<li>
the convective heat flow in Watts, and
</li>
<li>
the water vapor released into the air.
</li>
</ul>
If the medium model does not contain water vapor, then
the water vapor released into the air is zero, i.e.,
the mass flow rate at the fluid port is equal to zero.
</html>",     revisions="<html>
<ul>
<li>
December 6, 2011, by Michael Wetter:<br/>
Fixed sign error in convective heat gain that is assigned to
<code>QCon_flow.Q_flow</code>.
This closes ticket <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/46\">issue 46</a>.
</li>
<li>
April 27, 2011, by Michael Wetter:<br/>
Changed assert statement to allow use of model for media without water vapor.
</li>
<li>
June 9, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
                  Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
              Line(
                points={{-48,-66},{-24,-18},{0,-68}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-24,-18},{-24,46}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-52,24},{-24,38}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-24,38},{8,22}},
                color={0,0,255},
                smooth=Smooth.None),
              Ellipse(extent={{-40,76},{-8,46}},  lineColor={0,0,255}),
              Text(
                extent={{-98,30},{-38,-26}},
                lineColor={0,0,127},
                textString="q_flow"),
              Text(
                extent={{12,72},{86,50}},
                lineColor={0,0,127},
                textString="QRad_flow"),
              Text(
                extent={{10,12},{84,-10}},
                lineColor={0,0,127},
                textString="QCon_flow"),
              Text(
                extent={{12,-46},{86,-68}},
                lineColor={0,0,127},
                textString="mLat_flow")}),
              Documentation(info = "<html>
This is a dummy model that is required to implement the room
model with a variable number of surface models.
The model is required since arrays of models, such as used for the surfaces
that model the construction outside of the room,
must have at least one element, unless the whole array
is conditionally removed if its size is zero.
However, conditionally removing the surface models does not work in this
situation since some models, such as for computing the radiative heat exchange
between the surfaces, require access to the area and absorptivity of the surface models.

</html>",     revisions="<html>
<ul>
<li>
June 25, by Michael Wetter:<br/>
Added missing <code>each</code> attribute.
</li>
<li>
February 22, by Michael Wetter:<br/>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
June 8 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end HeatGain;

      model InfraredRadiationExchange
        "Infrared radiation heat exchange between the room facing surfaces"
        extends Buildings.Rooms.BaseClasses.PartialSurfaceInterfaceRadiative;
        parameter Boolean linearizeRadiation
          "Set to true to linearize emissive power";
        parameter Boolean homotopyInitialization=true
          "= true, use homotopy method"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        HeatTransfer.Interfaces.RadiosityInflow JInConExtWin[NConExtWin] if
            haveConExtWin
          "Incoming radiosity that connects to non-frame part of the window"
          annotation (Placement(transformation(extent={{260,70},{240,90}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutConExtWin[NConExtWin]
          "Outgoing radiosity that connects to non-frame part of the window"
          annotation (Placement(transformation(extent={{240,110},{260,130}})));
      protected
        final parameter Integer NOpa=NConExt + 2*NConExtWin + 2*NConPar + NConBou +
            NSurBou "Number of opaque surfaces, including the window frame";
        final parameter Integer nOpa=nConExt + 2*nConExtWin + 2*nConPar + nConBou +
            nSurBou "Number of opaque surfaces, including the window frame";
        final parameter Integer NWin=NConExtWin "Number of window surfaces";
        final parameter Integer nWin=nConExtWin "Number of window surfaces";
        final parameter Integer NTot=NOpa + NWin "Total number of surfaces";
        final parameter Integer nTot=nOpa + nWin "Total number of surfaces";
        final parameter Real epsOpa[nOpa](
          min=0,
          max=1,
          fixed=false) "Absorptivity of opaque surfaces";
        final parameter Real rhoOpa[nOpa](
          min=0,
          max=1,
          fixed=false) "Reflectivity of opaque surfaces";
        final parameter Modelica.SIunits.Area AOpa[nOpa](fixed=false)
          "Surface area of opaque surfaces";
        final parameter Modelica.SIunits.Area A[nTot](fixed=false)
          "Surface areas";
        final parameter Real kOpa[nOpa](unit="W/K4", fixed=false)
          "Product sigma*epsilon*A for opaque surfaces";
        final parameter Real F[nTot, nTot](
          min=0,
          max=1,
          fixed=false) "View factor from surface i to j";

         Buildings.HeatTransfer.Interfaces.RadiosityInflow JInConExtWin_internal[NConExtWin]
          "Incoming radiosity that connects to non-frame part of the window";

        Modelica.SIunits.HeatFlowRate J[nTot](
          max=0,
          start=A .* 0.8*Modelica.Constants.sigma*293.15^4,
          each nominal=10*0.8*Modelica.Constants.sigma*293.15^4)
          "Radiosity leaving the surface";
        Modelica.SIunits.HeatFlowRate G[nTot](
          min=0,
          start=A .* 0.8*Modelica.Constants.sigma*293.15^4,
          each nominal=10*0.8*Modelica.Constants.sigma*293.15^4)
          "Radiosity entering the surface";
        constant Real T30(unit="K3") = 293.15^3 "Nominal temperature";
        constant Real T40(unit="K4") = 293.15^4 "Nominal temperature";
        Modelica.SIunits.Temperature TOpa[nOpa](each start=293.15, each nominal=
              293.15) "Temperature of opaque surfaces";
        Real T4Opa[nOpa](
          each unit="K4",
          each start=T40,
          each nominal=293.15^4)
          "Forth power of temperature of opaque surfaces";
        Modelica.SIunits.HeatFlowRate Q_flow[nTot] "Heat flow rate at surfaces";
        parameter Modelica.SIunits.Temperature T0=293.15
          "Temperature used to linearize radiative heat transfer";
        final parameter Real T03(
          min=0,
          unit="K3") = T0^3 "3rd power of temperature T0";
        Modelica.SIunits.HeatFlowRate sumEBal
          "Sum of energy balance, should be zero";
      initial equation
        // The next loops build the array epsOpa, AOpa and kOpa that simplify
        // the model equations.
        // These arrays store the values of the constructios in the following order
        // [x[1:NConExt] x[1:NConPar] x[1: NConPar] x[1: NConBou] x[1: NSurBou] x[1: NConExtWin] x[1: NConExtWin]]
        // where x is epsOpa, AOpa or kOpa.
        // The last two entries are for the opaque wall that contains a window, and for the window frame.
        for i in 1:nConExt loop
          epsOpa[i] = epsConExt[i];
          AOpa[i] = AConExt[i];
          kOpa[i] = Modelica.Constants.sigma*epsConExt[i]*AOpa[i];
        end for;
        for i in 1:nConPar loop
          epsOpa[i + nConExt] = epsConPar_a[i];
          AOpa[i + nConExt] = AConPar[i];
          kOpa[i + nConExt] = Modelica.Constants.sigma*epsConPar_a[i]*AOpa[i +
            nConExt];
          epsOpa[i + nConExt + nConPar] = epsConPar_b[i];
          AOpa[i + nConExt + nConPar] = AConPar[i];
          kOpa[i + nConExt + nConPar] = Modelica.Constants.sigma*epsConPar_b[i]*AOpa[
            i + nConExt + nConPar];
        end for;
        for i in 1:nConBou loop
          epsOpa[i + nConExt + 2*nConPar] = epsConBou[i];
          AOpa[i + nConExt + 2*nConPar] = AConBou[i];
          kOpa[i + nConExt + 2*nConPar] = Modelica.Constants.sigma*epsConBou[i]*AOpa[
            i + nConExt + 2*nConPar];
        end for;
        for i in 1:nSurBou loop
          epsOpa[i + nConExt + 2*nConPar + nConBou] = epsSurBou[i];
          AOpa[i + nConExt + 2*nConPar + nConBou] = ASurBou[i];
          kOpa[i + nConExt + 2*nConPar + nConBou] = Modelica.Constants.sigma*
            epsSurBou[i]*AOpa[i + nConExt + 2*nConPar + nConBou];
        end for;
        for i in 1:nConExtWin loop
          // Opaque part of construction that has a window embedded
          epsOpa[i + nConExt + 2*nConPar + nConBou + nSurBou] = epsConExtWinOpa[i];
          AOpa[i + nConExt + 2*nConPar + nConBou + nSurBou] = AConExtWinOpa[i];
          kOpa[i + nConExt + 2*nConPar + nConBou + nSurBou] = Modelica.Constants.sigma
            *epsConExtWinOpa[i]*AOpa[i + nConExt + 2*nConPar + nConBou + nSurBou];
          // Window frame
          epsOpa[i + nConExt + 2*nConPar + nConBou + nSurBou + nConExtWin] =
            epsConExtWinFra[i];
          AOpa[i + nConExt + 2*nConPar + nConBou + nSurBou + nConExtWin] =
            AConExtWinFra[i];
          kOpa[i + nConExt + 2*nConPar + nConBou + nSurBou + nConExtWin] = Modelica.Constants.sigma
            *epsConExtWinFra[i]*AOpa[i + nConExt + 2*nConPar + nConBou + nSurBou +
            nConExtWin];
        end for;
        // Vector with all surface areas.
        // The next loops build the array A that simplifies
        // the model equations.
        // These array stores the values of the constructios in the following order
        // [AOpa[1:nConExt] AOpa[1:nConPar] AOpa[1: nConPar] AOpa[1: nConBou] AOpa[1: nSurBou]
        //  AOpa[1: nConExtWin] AOpa[1: nConExtWin] AGla[1: nConExtWin]]
        // since nWin=nConExtWin.
        for i in 1:nOpa loop
          A[i] = AOpa[i];
        end for;
        for i in 1:nWin loop
          A[i + nOpa] = AConExtWinGla[i];
        end for;
        // Reflectivity for opaque surfaces
        rhoOpa = 1 .- epsOpa;
        // View factors from surface i to surface j
        for i in 1:nTot loop
          for j in 1:nTot loop
            F[i, j] = A[j]/sum((A[k]) for k in 1:nTot);
          end for;
        end for;
        // Test whether the view factors add up to one, or the sum is zero in case there
        // is only one construction
        for i in 1:nTot loop
          assert((abs(1 - sum(F[i, j] for j in 1:nTot))) < 1E-10,
            "Program error: Sum 1 of view factors is " + String(sum(F[i, j] for j in
            1:nTot)));
        end for;
        ////////////////////////////////////////////////////////////////////
      equation
        // Conditional connector
        connect(JInConExtWin, JInConExtWin_internal);
        if not haveConExtWin then
          JInConExtWin_internal = fill(0, NConExtWin);
        end if;
        // Assign temperature of opaque surfaces
        for i in 1:nConExt loop
          TOpa[i] = conExt[i].T;
        end for;
        for i in 1:nConPar loop
          TOpa[i + nConExt] = conPar_a[i].T;
          TOpa[i + nConExt + nConPar] = conPar_b[i].T;
        end for;
        for i in 1:nConBou loop
          TOpa[i + nConExt + 2*nConPar] = conBou[i].T;
        end for;
        for i in 1:nSurBou loop
          TOpa[i + nConExt + 2*nConPar + nConBou] = conSurBou[i].T;
        end for;
        for i in 1:nConExtWin loop
          TOpa[i + nConExt + 2*nConPar + nConBou + nSurBou] = conExtWin[i].T;
          TOpa[i + nConExt + 2*nConPar + nConBou + nConExtWin + nSurBou] =
            conExtWinFra[i].T;
        end for;
        // Incoming radiosity at each surface
        // is equal to the negative of the outgoing radiosity of
        // all other surfaces times the view factor
        G = -transpose(F)*J;
        // Outgoing radiosity
        // Opaque surfaces.
        // If kOpa[j]=absIR[j]*A[j] < 1E-28, then A < 1E-20 and the surface is
        // from a dummy construction. In this situation, we set T40=293.15^4 to
        // avoid a singularity.
        for j in 1:nOpa loop
          //   T4Opa[j] = if (kOpa[j] > 1E-28) then (Q_flow[j]-epsOpa[j] * G[j])/kOpa[j] else T40;
          T4Opa[j] = (-J[j] - rhoOpa[j]*G[j])/kOpa[j];
        end for;
        // 4th power of temperature
        if linearizeRadiation then
          TOpa = (T4Opa .+ 3*T40)/(4*T30);
          // Based on T4 = 4*T30*T-3*T40
        else
          if homotopyInitialization then
            TOpa = homotopy(actual=Buildings.Utilities.Math.Functions.powerLinearized(
              x=T4Opa,
              x0=243.15^4,
              n=0.25), simplified=(T4Opa .+ 3*T40)/(4*T30));
          else
            TOpa = Buildings.Utilities.Math.Functions.powerLinearized(
              x=T4Opa,
              x0=243.15^4,
              n=0.25);
          end if;
        end if;
        // Assign radiosity that comes from window
        // and that leaves window.
        // J < 0 because it leaves the surface
        // G > 0 because it strikes the surface
        for j in 1:nWin loop
          J[j + nOpa] = -JInConExtWin_internal[j];
          G[j + nOpa] = +JOutConExtWin[j];
        end for;
        // Net heat exchange
        Q_flow = -J - G;
        // Assign heat exchange to connectors
        for i in 1:nConExt loop
          Q_flow[i] = conExt[i].Q_flow;
        end for;
        if nConExt == 0 then
          conExt[1].T = T0;
        end if;
        for i in 1:nConPar loop
          Q_flow[i + nConExt] = conPar_a[i].Q_flow;
          Q_flow[i + nConExt + nConPar] = conPar_b[i].Q_flow;
        end for;
        if nConPar == 0 then
          conPar_a[1].T = T0;
          conPar_b[1].T = T0;
        end if;
        for i in 1:nConBou loop
          Q_flow[i + nConExt + 2*nConPar] = conBou[i].Q_flow;
        end for;
        if nConBou == 0 then
          conBou[1].T = T0;
        end if;
        for i in 1:nSurBou loop
          Q_flow[i + nConExt + 2*nConPar + nConBou] = conSurBou[i].Q_flow;
        end for;
        if nSurBou == 0 then
          conSurBou[1].T = T0;
        end if;
        for i in 1:nConExtWin loop
          Q_flow[i + nConExt + 2*nConPar + nConBou + nSurBou] = conExtWin[i].Q_flow;
          Q_flow[i + nConExt + 2*nConPar + nConBou + nSurBou + nConExtWin] =
            conExtWinFra[i].Q_flow;
        end for;
        if nConExtWin == 0 then
          conExtWin[1].T = T0;
          conExtWinFra[1].T = T0;
          JOutConExtWin[1] = 0;
        end if;
        // Sum of energy balance
        // Remove sumEBal and assert statement for final release
        sumEBal = sum(conExt.Q_flow) + sum(conPar_a.Q_flow) + sum(conPar_b.Q_flow) +
          sum(conBou.Q_flow) + sum(conSurBou.Q_flow) + sum(conExtWin.Q_flow) + sum(
          conExtWinFra.Q_flow) + (sum(JInConExtWin_internal) - sum(JOutConExtWin));
        assert(abs(sumEBal) < 1E-1,
          "Program error: Energy is not conserved in InfraredRadiationExchange.
               Sum of all energy is "       + String(sumEBal));
        annotation (
          preferredView="info",
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,
                  240}})),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,
                  240}}), graphics={
              Line(
                points={{-144,-8},{146,-8}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-144,-8},{2,184}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-144,-8},{2,-200}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{2,-200},{2,184}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{2,184},{148,-8}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{2,-200},{148,-8}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5)}),
          Documentation(info="<html>
<p>
This model computes the infrared radiative heat transfer between the interior
surfaces of a room. Each opaque surface emits radiation according to
</p>
<p align=\"center\" style=\"font-style:italic;\">
  E<sup>i</sup> = &sigma; &nbsp; A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup> &nbsp;
(T<sup>i</sup>)<sup>4</sup>,
</p>
<p>
where
<i>&sigma;</i>
is the Stefan-Boltzmann constant,
<i>A<sup>i</sup> </i>
is the surface area,
<i>&epsilon;<sup>i</sup> </i>
is the absorptivity in the infrared spectrum, and
<i>T<sup>i</sup></i>
is the surface temperature.
If the parameter <code>linearizeRadidation</code> is set to <code>true</code>,
then the term <i>(T<sup>i</sup>)<sup>4</sup></i> is replaced with
<i>T<sub>0</sub><sup>3</sup> T<sup>i</sup></i>,
where <i>T<sub>0</sub> = 20&deg;C</i> is a parameter.
</p>
<p>
The incoming radiation at surface <i>i</i> is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  G<sup>i</sup> = -&sum;<sub>j</sub> &nbsp; F<sup>j,i</sup> &nbsp; J<sup>j</sup>
</p>
<p>
where
<i>F<sup>j,i</sup></i>
is the view factor from surface
<i>j</i> to surface <i>i</i>,
<i>J<sup>j</sup></i>
is the radiosity leaving surface <i>j</i>
and the sum is over all surfaces.
For opaque surfaces, it follows from the first law
that the radiosity
<i>J<sup>i</sup></i>
is
</p>
<p align=\"center\" style=\"font-style:italic;\">
 J<sup>i</sup> = -E<sup>i</sup>  - (1-&epsilon;<sup>i</sup>) &nbsp; G<sup>i</sup>.
</p>
<p>
For windows, the outgoing radiosity is an input into this model
because the window model computes this quantity directly.
</p>
<p>
For each surface <i>i</i>, the heat balance is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  0 = Q<sup>i</sup> + J<sup>i</sup> + G<sup>i</sup>.
</p>
<p>
For opaque surfaces, the heat flow rate
<i>Q<sup>i</sup></i>
is set to be equal to the heat flow rate at the heat port.
For the glass of the windows, the radiosity outflow at the connector is
set to the radiosity
<i>G<sup>i</sup></i>
that is leaving the surface.
</p>
<p>
The view factor from surface <i>i</i> to <i>j</i> is approximated as
<p align=\"center\" style=\"font-style:italic;\">
  F<sup>i,j</sup> = A<sup>j</sup> &frasl; &sum;<sub>k </sub> A<sup>k</sup>.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
April 18, 2013, by Michael Wetter:<br/>
Removed <code>cardinality</code> function as this is
deprecated in the MSL specification and not correctly implemented in omc.
</li>
<li>
February 10, 2012 by Wangda Zuo:<br/>
Fixed a bug for linearization of T4.
</li>
<li>
April 21, 2011 by Michael Wetter:<br/>
Fixed a bug in the view factor calculation, and rewrote the model to reduce simulation time. The bug caused too much radiosity to flow from large to small surfaces because the law of reciprocity for view factors was not satisfied. This led to low surface temperatures if a surface had a large area compared to other surfaces.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
Feb. 3, 2011, by Michael Wetter:<br/>
Corrected bug in start value of radiosity, reformulated equations to get
smaller system of coupled equations.
<li>
Dec. 1, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end InfraredRadiationExchange;

      model InfraredRadiationGainDistribution
        "Infrared radiative heat gain distribution between the room facing surfaces"
        extends Buildings.Rooms.BaseClasses.PartialSurfaceInterfaceRadiative;
        parameter Boolean haveShade "Set to true if a shade is present";

        Modelica.Blocks.Interfaces.RealInput uSha[NConExtWin](each min=0, each max=1) if
             haveShade
          "Control signal for the shading device (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-280,160},{-240,200}}),
              iconTransformation(extent={{-280,160},{-240,200}})));

        Modelica.Blocks.Interfaces.RealInput Q_flow
          "Radiative heat input into room (positive if heat gain)"
              annotation (Placement(transformation(
              origin={-260,0},
              extent={{20,-20},{-20,20}},
              rotation=180)));
        Buildings.HeatTransfer.Interfaces.RadiosityOutflow[NConExtWin] JOutConExtWin
          "Outgoing radiosity that connects to shaded and unshaded part of glass"
          annotation (Placement(transformation(extent={{240,110},{260,130}})));
      protected
        Real fraConExt[NConExt] = AEpsConExt/sumAEps
          "Fraction of infrared radiant heat gain absorbed by exterior constructions";
        Real fraConExtWinOpa[NConExtWin] = AEpsConExtWinOpa/sumAEps
          "Fraction of infrared radiant heat gain absorbed by opaque part of exterior constructions that have a window";
        Real fraConExtWinGla[NConExtWin] = (AEpsConExtWinSha + AEpsConExtWinUns)/sumAEps
          "Fraction of infrared radiant heat gain absorbed by opaque part of glass constructions that have a window";
        Real fraConExtWinFra[NConExtWin] = AEpsConExtWinFra/sumAEps
          "Fraction of infrared radiant heat gain absorbed by window frame of exterior constructions that have a window";

        Real fraConPar_a[NConPar] = AEpsConPar_a/sumAEps
          "Fraction of infrared radiant heat gain absorbed by partition constructions surface a";
        Real fraConPar_b[NConPar] = AEpsConPar_b/sumAEps
          "Fraction of infrared radiant heat gain absorbed by partition constructions surface b";
        Real fraConBou[NConBou] = AEpsConBou/sumAEps
          "Fraction of infrared radiant heat gain absorbed by constructions with exterior boundary conditions exposed to outside of room model";
        Real fraSurBou[NSurBou] = AEpsSurBou/sumAEps
          "Fraction of infrared radiant heat gain absorbed by surface models of constructions that are modeled outside of this room";

       parameter Real AEpsConExt[NConExt] = {AConExt[i]*epsConExt[i] for i in 1:NConExt}
          "Absorptivity times area of exterior constructions";
       parameter Real AEpsConExtWinOpa[NConExtWin] = {AConExtWinOpa[i]*epsConExtWinOpa[i] for i in 1:NConExtWin}
          "Absorptivity times area of opaque part of exterior constructions that contain a window";
       Real AEpsConExtWinUns[NConExtWin] = {shaSig[i].yCom * AConExtWinGla[i]*epsConExtWinUns[i]
           for i in 1:NConExtWin}
          "Absorptivity times area of unshaded window constructions";
       Real AEpsConExtWinSha[NConExtWin] = {shaSig[i].y    * AConExtWinGla[i]*epsConExtWinSha[i]
          for i in 1:NConExtWin}
          "Absorptivity times area of shaded window constructions";
       parameter Real AEpsConExtWinFra[NConExtWin] = {AConExtWinFra[i]*epsConExtWinFra[i] for i in 1:NConExtWin}
          "Absorptivity times area of window frame";
       parameter Real AEpsConPar_a[NConPar] = {AConPar[i]*epsConPar_a[i] for i in 1:NConPar}
          "Absorptivity times area of partition constructions surface a";
       parameter Real AEpsConPar_b[NConPar] = {AConPar[i]*epsConPar_b[i] for i in 1:NConPar}
          "Absorptivity times area of partition constructions surface b";
       parameter Real AEpsConBou[NConBou] = {AConBou[i]*epsConBou[i] for i in 1:NConBou}
          "Absorptivity times area of constructions with exterior boundary conditions exposed to outside of room model";
       parameter Real AEpsSurBou[NSurBou] = {ASurBou[i]*epsSurBou[i] for i in 1:NSurBou}
          "Absorptivity times area of surface models of constructions that are modeled outside of this room";

       parameter Real sumAEpsNoWin(fixed=false)
          "Sum of absorptivity times area of all constructions except for windows";
       Real sumAEps
          "Sum of absorptivity times area of all constructions including windows";

       Buildings.HeatTransfer.Windows.BaseClasses.ShadingSignal shaSig[NConExtWin](
            each final haveShade=haveShade)
          "Block to constrain the shading control signal to be strictly within (0, 1) if a shade is present";
      initial equation
        sumAEpsNoWin = sum(AEpsConExt)+sum(AEpsConExtWinOpa)+sum(AEpsConExtWinFra)
                      +sum(AEpsConPar_a)+sum(AEpsConPar_b)+sum(AEpsConBou)+sum(AEpsSurBou);
      equation
        connect(uSha, shaSig.u);

        sumAEps      = sumAEpsNoWin + sum(AEpsConExtWinUns) + sum(AEpsConExtWinSha);

        // Infrared radiative heat flow
        // If a construction is not present, we assign the temperature of the connector to 20 degC.
        if haveConExt then
          conExt.Q_flow    = -fraConExt*Q_flow;
        else
          conExt[1].T = 293.15;
        end if;

        if haveConExtWin then
          conExtWin.Q_flow = -fraConExtWinOpa*Q_flow;
        else
          conExtWin[1].T = 293.15;
        end if;

        if haveConPar then
          conPar_a.Q_flow  = -fraConPar_a*Q_flow;
          conPar_b.Q_flow  = -fraConPar_b*Q_flow;
        else
          conPar_a[1].T = 293.15;
          conPar_b[1].T = 293.15;
        end if;

        if haveConBou then
          conBou.Q_flow    = -fraConBou*Q_flow;
        else
          conBou[1].T = 293.15;
        end if;

        if haveSurBou then
          conSurBou.Q_flow    = -fraSurBou*Q_flow;
        else
          conSurBou[1].T = 293.15;
        end if;

        // This model makes the simplification that the shade, the glass and the frame have
        // the same absorptivity in the infrared region
        JOutConExtWin        = +fraConExtWinGla*Q_flow;
        if haveConExtWin then
           conExtWinFra.Q_flow  = -fraConExtWinFra*Q_flow;
        else
           conExtWinFra[1].T = 293.15;
        end if;

        // Check for conservation of energy
        assert(abs(1 - sum(fraConExt) - sum(fraConExtWinOpa)- sum(fraConExtWinGla) - sum(fraConExtWinFra)
                 - sum(fraConPar_a) - sum(fraConPar_b)
                 - sum(fraConBou) - sum(fraSurBou))  < 1E-5,
                 "Programming error: Radiation balance is wrong. Check equations.");
        annotation (
      preferredView="info",
      Documentation(info = "<html>
This model computes the distribution of the infrared radiant heat gain
to the room surfaces.
The infrared radiant heat gain <i>Q</i> is an input to this model.
It is distributed to the individual surfaces according to
<p align=\"center\" style=\"font-style:italic;\">
  Q<sup>i</sup> = Q &nbsp; A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup> &frasl;
 &sum;<sub>k</sub> A<sup>k</sup> &nbsp; &epsilon;<sup>k</sup>.
</p>
For opaque surfaces, the heat flow rate
<i>Q<sup>i</sup></i>
is set to be equal to the heat flow rate at the heat port.
For the glass of the windows, the heat flow rate
<i>Q<sup>i</sup></i> is set to the radiosity
<i>J<sup>i</sup></i>
that will strike the glass or the window shade.
</html>",     revisions="<html>
<ul>
<li>
July 16, 2013, by Michael Wetter:<br/>
Added assignment of heat port temperature instead of heat flow rate
for the cases where a construction has been conditionally removed.
This is required to avoid a singularity.
</li>
<li>
June 27, 2013, by Michael Wetter:<br/>
Changed model because the outflowing radiosity has been changed to be a non-negative quantity.
See track issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/158\">#158</a>.
</li>
<li>
December 1, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Text(
                extent={{-234,40},{-178,10}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Rectangle(
                extent={{-242,4},{-2,-4}},
                lineColor={255,0,0},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-4,4},{2,-8}},
                lineColor={255,0,0},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-144,-8},{146,-8}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{2,-200},{2,184}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Text(
                extent={{-230,210},{-174,148}},
                lineColor={0,0,127},
                textString="uSha")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,
                  240}}),
                  graphics));
      end InfraredRadiationGainDistribution;

      model RadiationAdapter
        "Model to connect between signals and heat port for radiative gains of the room"
        extends Buildings.BaseClasses.BaseIcon;

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a rad
          "Port for radiative heat gain and radiation temperature"    annotation (Placement(transformation(extent={{-10,
                  -110},{10,-90}}), iconTransformation(extent={{-12,
                  -110},{8,-90}})));
      public
        Modelica.Blocks.Interfaces.RealInput TRad
          "Radiation temperature of room"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput QRad_flow "Radiative heat gain"
          annotation (Placement(transformation(extent={{100,-10},{120,10}}),
              iconTransformation(extent={{100,-10},{120,10}})));
      equation
        QRad_flow = rad.Q_flow;
        rad.T = TRad;
       annotation (Placement(transformation(extent={{-140,-20},{-100,20}})),
                  Documentation(info="<html>
This model can be used as a thermal adapter in situations where the temperature
and the heat flow rate are computed in separate models.
For example, this thermal adapter is used in the room model, which computes
the distribution of radiative heat gains (such as due to a radiator) in
<a href=\"modelica://Buildings.Rooms.BaseClasses.InfraredRadiationGainDistribution\">
Buildings.Rooms.BaseClasses.InfraredRadiationGainDistribution</a>
and computes the radiative temperature in
<a href=\"modelica://Buildings.Rooms.BaseClasses.RadiationTemperature\">
Buildings.Rooms.BaseClasses.RadiationTemperature</a>.
This adapter combines the heat flow rate and the temperatures that are computed in these
separate models, and exposes these two quantities at its heat port.

</html>",     revisions="<html>
<ul>
<li>
Feb. 2, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
                  Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
              Text(
                extent={{-90,24},{-40,-26}},
                lineColor={0,0,127},
                textString="TRad"),
              Text(
                extent={{50,14},{92,-12}},
                lineColor={0,0,127},
                textString="Q")}),
              Documentation(info = "<html>
This is a dummy model that is required to implement the room
model with a variable number of surface models.
The model is required since arrays of models, such as used for the surfaces
that model the construction outside of the room,
must have at least one element, unless the whole array
is conditionally removed if its size is zero.
However, conditionally removing the surface models does not work in this
situation since some models, such as for computing the radiative heat exchange
between the surfaces, require access to the area and absorptivity of the surface models.

</html>",     revisions="<html>
<ul>
<li>
June 8 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end RadiationAdapter;

      model RadiationTemperature "Radiative temperature of the room"
        extends Buildings.Rooms.BaseClasses.PartialSurfaceInterfaceRadiative;

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns[NConExtWin] if
           haveConExtWin
          "Heat port that connects to room-side surface of unshaded glass"
                                    annotation (Placement(transformation(extent={{230,110},
                  {250,130}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha[NConExtWin] if
          haveShade
          "Heat port that connects to room-side surface of shaded glass"
                                    annotation (Placement(transformation(extent={{230,70},
                  {250,90}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a sha[NConExtWin] if
          haveShade "Heat port that connects to shade"
                                             annotation (Placement(transformation(extent={{230,28},
                  {250,48}})));
        parameter Boolean haveShade "Set to true if the windows have a shade"
        annotation(HideResult="true");

        Modelica.Blocks.Interfaces.RealInput uSha[NConExtWin](each min=0, each max=1) if
             haveShade
          "Control signal for the shading device (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-280,160},{-240,200}}),
              iconTransformation(extent={{-280,160},{-240,200}})));

        Modelica.Blocks.Interfaces.RealOutput TRad(min=0, unit="K", displayUnit="degC")
          "Radiative temperature"
          annotation (Placement(transformation(extent={{-240,-190},{-260,-170}}),
              iconTransformation(extent={{-240,-194},{-260,-174}})));

      protected
        final parameter Integer NOpa = NConExt+2*NConExtWin+2*NConPar+NConBou+NSurBou
          "Number of opaque surfaces, including the window frame";
        final parameter Integer NWin = NConExtWin "Number of window surfaces";
        final parameter Integer NTot = NOpa + NWin "Total number of surfaces";

        final parameter Modelica.SIunits.Area AGla[NWin] = datConExtWin.AGla
          "Surface area of opaque surfaces";
        final parameter Real epsGla[NWin](min=0, max=1)=
          {datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].absIR_b for i in 1:NWin}
          "Absorptivity of glass";
        final parameter Real epsSha[NWin](min=0, max=1)=
          {datConExtWin[i].glaSys.shade.absIR_a for i in 1:NWin}
          "Absorptivity of shade";
        final parameter Real tauSha[NWin](min=0, max=1)=
          {(if datConExtWin[i].glaSys.haveInteriorShade then
            datConExtWin[i].glaSys.shade.tauIR_a else 1) for i in 1:NWin}
          "Transmissivity of shade";
        final parameter Modelica.SIunits.Area epsAOpa[NOpa](fixed=false)
          "Product of area times absorptivity of opaque surfaces";
        final parameter Modelica.SIunits.Area epsAGla[NWin](fixed=false)
          "Product of area times absorptivity of window surfaces";
        final parameter Modelica.SIunits.Area epsASha[NWin](fixed=false)
          "Product of area times absorptivity of window shade";
        final parameter Modelica.SIunits.Area epsTauASha[NWin](fixed=false)
          "Product of area times glass absorptivity times shade transmittance";
        Modelica.SIunits.Temperature TOpa[NOpa](each start=293.15, each nominal=293.15)
          "Temperature of opaque surfaces";
        Modelica.SIunits.Temperature TGlaUns[NWin](each start=293.15, each nominal=293.15)
          "Temperature of unshaded part of glass";
        Modelica.SIunits.Temperature TGlaSha[NWin](each start=293.15, each nominal=293.15)
          "Temperature of shaded part of glass";
        Modelica.SIunits.Temperature TSha[NWin](each start=293.15, each nominal=293.15)
          "Temperature of shade";
        // Internal connectors, used because of the conditionally removed connectors
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns_internal[NConExtWin]
          "Heat port that connects to room-side surface of unshaded glass";
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha_internal[NConExtWin]
          "Heat port that connects to room-side surface of shaded glass";
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a sha_internal[NConExtWin]
          "Heat port that connects to shade";
        Modelica.Blocks.Interfaces.RealInput uSha_internal[NConExtWin](each min=0, each max=1)
          "Control signal for the shading device";

      initial equation
        // The next loops build the array epsAOpa that simplifies
        // the model equations.
        // The arrays stores the values of the constructios in the following order
        // [x[1:NConExt] x[1:NConPar] x[1: NConPar] x[1: NConBou] x[1: NSurBou] x[1: NConExtWin] x[1: NConExtWin]]
        // where x is epsOpa, AOpa or kOpa.
        // The last two entries are for the opaque wall that contains a window, and for the window frame.
        for i in 1:NConExt loop
          epsAOpa[i] = epsConExt[i] * AConExt[i];
        end for;
        for i in 1:NConPar loop
          epsAOpa[i+NConExt]         = epsConPar_a[i] * AConPar[i];
          epsAOpa[i+NConExt+NConPar] = epsConPar_b[i] * AConPar[i];
        end for;
        for i in 1:NConBou loop
          epsAOpa[i+NConExt+2*NConPar] = epsConBou[i] * AConBou[i];
        end for;
        for i in 1:NSurBou loop
          epsAOpa[i+NConExt+2*NConPar+NConBou] = epsSurBou[i] * ASurBou[i];
        end for;
        for i in 1:NConExtWin loop
          // Opaque part of construction that has a window embedded
          epsAOpa[i+NConExt+2*NConPar+NConBou+NSurBou] = epsConExtWinOpa[i] * AConExtWinOpa[i];
          // Window frame
          epsAOpa[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin] = epsConExtWinFra[i] * AConExtWinFra[i];
        end for;
        // Window glass
        for i in 1:NConExtWin loop
          // Window glass
          epsAGla[i] = AGla[i] * epsGla[i];
          // Window shade
          epsASha[i]    = AGla[i] * epsSha[i];
          // Emitted from glas and transmitted through window shade
          epsTauASha[i] = AGla[i] * epsGla[i] * tauSha[i];
        end for;
      ////////////////////////////////////////////////////////////////////
      equation
        // Conditional connnector
        connect(glaUns, glaUns_internal);
        connect(glaSha, glaSha_internal);
        connect(sha, sha_internal);
        connect(uSha, uSha_internal);
        if not haveConExtWin then
          glaUns_internal.T = fill(293.15, NConExtWin);
        end if;
        if not haveShade then
          glaSha_internal.T = fill(293.15, NConExtWin);
          sha_internal.T = fill(293.15, NConExtWin);
          uSha_internal = fill(0, NConExtWin);
        end if;

        // Assign temperature of opaque surfaces
        for i in 1:NConExt loop
          TOpa[i] = conExt[i].T;
        end for;
        for i in 1:NConPar loop
          TOpa[i+NConExt]         = conPar_a[i].T;
          TOpa[i+NConExt+NConPar] = conPar_b[i].T;
        end for;
        for i in 1:NConBou loop
          TOpa[i+NConExt+2*NConPar] = conBou[i].T;
        end for;
        for i in 1:NSurBou loop
          TOpa[i+NConExt+2*NConPar+NConBou] = conSurBou[i].T;
        end for;
        for i in 1:NConExtWin loop
          TOpa[i+NConExt+2*NConPar+NConBou+NSurBou]            = conExtWin[i].T;
          TOpa[i+NConExt+2*NConPar+NConBou+NConExtWin+NSurBou] = conExtWinFra[i].T;
        end for;
        // Assign temperature of glass and shade
        for i in 1:NConExtWin loop
          TGlaUns[i] = glaUns_internal[i].T;
          TGlaSha[i] = glaSha_internal[i].T;
          TSha[i]    = sha_internal[i].T;
        end for;
        // Compute radiative temperature
        if haveShade then
          TRad = (sum(epsAOpa[i] * TOpa[i] for i in 1:NOpa)
              + sum(
            ( uSha_internal[i] * (epsASha[i] * TSha[i] + epsTauASha[i] * TGlaSha[i]) +
            (1-uSha_internal[i]) * epsAGla[i] * TGlaUns[i])
              for i in 1:NConExtWin))  /
              (sum(epsAOpa) + sum(
            ( uSha_internal[i] * (epsASha[i] + epsTauASha[i]) + (1-uSha_internal[i]) * epsAGla[i])
              for i in 1:NConExtWin));
            else
          TRad = (sum(epsAOpa[i] * TOpa[i] for i in 1:NOpa) + sum(epsAGla .* TGlaUns)) / (sum(epsAOpa) + sum(epsAGla));
        end if;

        // Assign heat exchange to connectors
        if haveConExt then
          for i in 1:NConExt loop
            0 = conExt[i].Q_flow;
          end for;
        else
            conExt[1].T = 293.15;
        end if;

        if haveConPar then
          for i in 1:NConPar loop
            0 = conPar_a[i].Q_flow;
            0 = conPar_b[i].Q_flow;
          end for;
        else
            conPar_a[1].T = 293.15;
            conPar_b[1].T = 293.15;
        end if;

        if haveConBou then
          for i in 1:NConBou loop
            0 = conBou[i].Q_flow;
          end for;
        else
           conBou[1].T = 293.15;
        end if;

        if haveSurBou then
          for i in 1:NSurBou loop
            0 = conSurBou[i].Q_flow;
          end for;
        else
            conSurBou[1].T = 293.15;
        end if;

        if haveConExtWin then
          for i in 1:NConExtWin loop
            0 = conExtWin[i].Q_flow;
            0 = conExtWinFra[i].Q_flow;
          end for;
        else
            conExtWin[1].T    = 293.15;
            conExtWinFra[1].T = 293.15;
        end if;

        annotation (
      preferredView="info",
      Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,240}}),
                            graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-240,-240},{240,240}}),
                                            graphics={
              Line(
                points={{-144,-8},{146,-8}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{2,-200},{2,184}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5)}),
      Documentation(
      info="<html>
<p>
This model computes the radiative temperature in the room.
For a room with windows but no shade, the radiative temperature is
computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  T<sub>rad</sub> = &sum;<sub>i</sub> &nbsp; (A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup> &nbsp; T<sup>i</sup>)
  &frasl;
  &sum;<sub>i</sub> &nbsp; (A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup>)
</p>
<p>
where
<i>T<sub>rad</sub></i> is the radiative temperature of the room,
<i>A<sup>i</sup></i> are the surface areas of the room,
<i>&epsilon;<sup>i</sup></i> are the infrared emissivities of the surfaces, and
<i>T<sup>i</sup></i> are the surface temperatures.
</p>
<p>
If a the windows have a shade, then the equation is modified to take the actual shaded and non-shaded
surface area into account. In this situation, the shaded part of a window has a infrared radiative power
of</p>
<p align=\"center\" style=\"font-style:italic;\">
 E = A &nbsp; ( u &nbsp; &epsilon;<sub>s</sub> &nbsp; T<sub>s</sub> +
   (1-u) &nbsp; &epsilon;<sub>g</sub> &tau;<sub>s</sub> &nbsp; T<sub>gs</sub>)
</p>
<p>
where
<i>A</i> is the surface area of the glass,
<i>u</i> is the control signal of the shade,
<i>&epsilon;<sub>s</sub></i> is the infrared absorptivity of the shade,
<i>T<sub>s</sub></i> is the temperature of the shade,
<i>&epsilon;<sub>g</sub></i> is the infrared absorptivity of the glass,
<i>&tau;<sub>s</sub></i> is the infrared transmittance of the shade, and
<i>T<sub>gs</sub></i> is the glass temperature behind the shade.
</p>
<p>
For the unshaded part of the window, the radiative power is
</p>
<p align=\"center\" style=\"font-style:italic;\">
 E = A &nbsp; (1-u) &nbsp; &epsilon;<sub>g</sub> &nbsp; T<sub>gn</sub>
</p>
<p>where
<i>T<sub>gn</sub></i> is the glass temperature of the non-shaded part of the window.
</p>
</html>",
      revisions="<html>
<ul>
<li>
July 16, 2013, by Michael Wetter:<br/>
Added assignment of heat port temperature instead of heat flow rate
for the cases where a construction has been conditionally removed.
This is required to avoid a singularity.
</li>
<li>
March 29 2011, by Michael Wetter:<br/>
Rewrote sum for the radiation temperature.
</li>
<li>
Jan. 18 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end RadiationTemperature;

      model SolarRadiationExchange
        "Solar radiation heat exchange between the room facing surfaces"
        extends Buildings.Rooms.BaseClasses.PartialSurfaceInterfaceRadiative(
        final epsConExt = datConExt.layers.absSol_b,
        final epsConExtWinOpa = datConExtWin.layers.absSol_b,
        final epsConExtWinUns={(1-datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].tauSol
                           -datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].rhoSol_b) for i in 1:NConExtWin},
        final epsConExtWinSha = {(1-datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].tauSol
                             -datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].rhoSol_b) for i in 1:NConExtWin},
        final epsConExtWinFra = datConExtWin.glaSys.absSolFra,
        final epsConPar_a = datConPar.layers.absSol_a,
        final epsConPar_b = datConPar.layers.absSol_b,
        final epsConBou = datConBou.layers.absSol_b,
        final epsSurBou = surBou.absSol);
        // In the above declaration, we simplified the assignment of epsConExtWinSha.
        // An exact formulation would need to take into account the transmission and reflection
        // of the shade for the solar radiation that strikes the window from the room-side.
        // The simplification leads to too low a value of epsConExtWinSha. Since epsConExtWinSha
        // is used as a weight for how much solar radiation hits the window from the room-side,
        // underestimating epsConExtWinSha does not seem to cause concerns. The reason is that
        // the model assumes diffuse reflection, whereas in reality, reflection of the solar
        // radiation at the floor is likely specular, and therefore less radiation would hit
        // the window from the room-side.
        parameter Boolean isFloorConExt[NConExt]
          "Flag to indicate if floor for exterior constructions";
        parameter Boolean isFloorConExtWin[NConExtWin]
          "Flag to indicate if floor for constructions";
        parameter Boolean isFloorConPar_a[NConPar]
          "Flag to indicate if floor for constructions";
        parameter Boolean isFloorConPar_b[NConPar]
          "Flag to indicate if floor for constructions";
        parameter Boolean isFloorConBou[NConBou]
          "Flag to indicate if floor for constructions with exterior boundary conditions exposed to outside of room model";
        parameter Boolean isFloorSurBou[NSurBou]
          "Flag to indicate if floor for constructions that are modeled outside of this room";

        parameter Modelica.SIunits.Emissivity tauGla[NConExtWin]
          "Transmissivity of window";

        Modelica.Blocks.Interfaces.RealOutput HOutConExtWin[NConExtWin](unit="W/m2")
          "Outgoing solar radiation that strikes window per unit area"
          annotation (Placement(transformation(extent={{240,110},{260,130}})));
        Modelica.Blocks.Interfaces.RealInput JInConExtWin[NConExtWin](unit="W")
          "Solar radiation transmitted by window per unit area"
          annotation (Placement(transformation(extent={{260,70},{240,90}})));
        Modelica.SIunits.HeatFlowRate JOutConExtWin[NConExtWin]
          "Outgoing solar radiation that strikes the window";

        Modelica.SIunits.HeatFlowRate HTot
          "Total solar radiation that enters the room";

      protected
        final parameter Real k1(unit="1", fixed=false)
          "Intermediate variable for gain for solar radiation distribution";
        final parameter Real k2(fixed=false)
          "Intermediate variable for gain for solar radiation distribution";
        Modelica.SIunits.HeatFlowRate Q_flow[NTot]
          "Total solar radiation that is absorbed by the surfaces (or transmitted back through the glass)";
        final parameter Integer NOpa = NConExt+2*NConExtWin+2*NConPar+NConBou+NSurBou
          "Number of opaque surfaces, including the window frame";
        final parameter Integer NWin = NConExtWin "Number of window surfaces";
        final parameter Integer NTot = NOpa + NWin "Total number of surfaces";
        final parameter Boolean isFlo[NTot](fixed=false)
          "Flag, true if a surface is a floor";
        final parameter Real eps[NTot](min=0, max=1, fixed=false)
          "Solar absorptivity";
        final parameter Real tau[NTot](min=0, max=1, fixed=false)
          "Solar transmissivity";
        final parameter Modelica.SIunits.Area AFlo(fixed=false)
          "Total floor area";
        final parameter Modelica.SIunits.Area A[NTot](fixed=false)
          "Surface areas";
        final parameter Real k[NTot](unit="1", fixed=false)
          "Gain for solar radiation distribution";

      initial equation
        // The next loops builds arrays that simplify
        // the model equations.
        // These arrays store the values of the constructios in the following order
        // [x[1:NConExt] x[1:NConPar] x[1: NConPar] x[1: NConBou] x[1: NSurBou] x[1: NConExtWin] x[1: NConExtWin]]
        // where x is epsOpa, AOpa or kOpa.
        // The last two entries are for the opaque wall that contains a window, and for the window frame.
        for i in 1:NConExt loop
          eps[i] = epsConExt[i];
          A[i]      = AConExt[i];
          isFlo[i]  = isFloorConExt[i];
        end for;
        for i in 1:NConPar loop
          eps[i+NConExt]           = epsConPar_a[i];
          A[i+NConExt]             = AConPar[i];
          isFlo[i+NConExt]         = isFloorConPar_a[i];
          eps[i+NConExt+NConPar]   = epsConPar_b[i];
          A[i+NConExt+NConPar]     = AConPar[i];
          isFlo[i+NConExt+NConPar] = isFloorConPar_b[i];
        end for;
        for i in 1:NConBou loop
          eps[i+NConExt+2*NConPar]   = epsConBou[i];
          A[i+NConExt+2*NConPar]     = AConBou[i];
          isFlo[i+NConExt+2*NConPar] = isFloorConBou[i];
        end for;
        for i in 1:NSurBou loop
          eps[i+NConExt+2*NConPar+NConBou]   = epsSurBou[i];
          A[i+NConExt+2*NConPar+NConBou]     = ASurBou[i];
          isFlo[i+NConExt+2*NConPar+NConBou] = isFloorSurBou[i];
        end for;

        for i in 1:NConExtWin loop
          // Opaque part of construction that has a window embedded
          eps[i+NConExt+2*NConPar+NConBou+NSurBou]   = epsConExtWinOpa[i];
          A[i+NConExt+2*NConPar+NConBou+NSurBou]     = AConExtWinOpa[i];
          isFlo[i+NConExt+2*NConPar+NConBou+NSurBou] = isFloorConExtWin[i];
          // Window frame
          eps[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin]   = epsConExtWinFra[i];
          A[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin]     = AConExtWinFra[i];
          isFlo[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin] = isFloorConExtWin[i];
        end for;
        // Window glass
        for i in 1:NConExtWin loop
          // We simplify and assume that the shaded and unshaded part of the window
          // have the same solar absorbtance.
          // This simplification allows lumping the solar distribution into
          // a parameter.
          eps[i+NConExt+2*NConPar+NConBou+NSurBou+2*NConExtWin] = epsConExtWinUns[i];
          isFlo[i+NConExt+2*NConPar+NConBou+NSurBou+2*NConExtWin] = isFloorConExtWin[i];
          A[i+NConExt+2*NConPar+NConBou+NSurBou+2*NConExtWin] = AConExtWinGla[i];
        end for;
        // Vector with all surface areas.
        // The next loops build the array A that simplifies
        // the model equations.
        // These array stores the values of the constructios in the following order
        // [AOpa[1:NConExt] AOpa[1:NConPar] AOpa[1: NConPar] AOpa[1: NConBou] AOpa[1: NSurBou]
        //  AOpa[1: NConExtWin] AOpa[1: NConExtWin] AGla[1: NConExtWin]]
        // since NWin=NConExtWin.

        // Solar transmissivity
        for i in 1:NOpa loop
          tau[i] = 0;
        end for;
        for i in 1:NWin loop
          tau[NOpa+i] = tauGla[i];
        end for;

        // Sum of surface areas
        AFlo = sum( (if isFlo[i] then A[i] else 0) for i in 1:NTot);

        // Coefficient that is used for non-floor areas.
        // The expression  max(1E-20, AFlo) is used to prevent a division by zero in case AFlo=0.
        // The situation for AFlo=0 is caught by the assert statement.
        k1 = sum( ( if isFlo[i] then (A[i] * (1-eps[i]-tau[i])) else 0)  for i in 1:NTot) / max(1E-20, AFlo);

        k2 = sum( ( if isFlo[i] then 0 else (A[i] * (eps[i]+tau[i])))  for i in 1:NTot);

        if ( k2 > 1E-10) then
          for i in 1:NTot loop
            if isFlo[i] then
               k[i] = (eps[i]+tau[i]) * A[i] / AFlo;
            else
               k[i] = k1/k2*(eps[i]+tau[i]) * A[i];
            end if;
           end for;
        else
              // This branch only happens if k2=0, i.e., there is no surface other than floors
          for i in 1:NTot loop
            if isFlo[i] then
              k[i] = A[i] / AFlo;
            else
              k[i] = 0;
            end if;
          end for;
        end if;

        // Test whether there is a floor inside this room
        assert( AFlo > 1E-10,
           "Error in parameters of the room model: The geometry is incorrect:\n" +
           "    The room model must have a construction that is a floor,\n" +
           "    and this construction must not have a window.\n" +
           "    The parameters for the room model are such that there is no such construction.\n" +
           "    Revise the model parameters.");
        // Test whether the distribution factors add up to one
        assert(abs(1-sum(k)) < 1E-5,
           "Program error: Sum of solar distribution factors in room is not equal to one. k=" + String(sum(k)));

      ////////////////////////////////////////////////////////////////////
      equation
        // Incoming radiation
        HTot = sum(JInConExtWin);
        // Radiation that is absorbed by the surfaces
        Q_flow = -k .* HTot;
        // Assign heat exchange to connectors
        if haveConExt then
          for i in 1:NConExt loop
            Q_flow[i] = conExt[i].Q_flow;
          end for;
        else
          conExt[1].T = 293.15;
        end if;

        if haveConPar then
          for i in 1:NConPar loop
            Q_flow[i+NConExt]         = conPar_a[i].Q_flow;
            Q_flow[i+NConExt+NConPar] = conPar_b[i].Q_flow;
          end for;
        else
            conPar_a[1].T = 293.15;
            conPar_b[1].T = 293.15;
        end if;

        if haveConBou then
          for i in 1:NConBou loop
            Q_flow[i+NConExt+2*NConPar] = conBou[i].Q_flow;
          end for;
        else
          conBou[1].T = 293.15;
        end if;

        if haveSurBou then
          for i in 1:NSurBou loop
            Q_flow[i+NConExt+2*NConPar+NConBou] = conSurBou[i].Q_flow;
           end for;
        else
            conSurBou[1].T = 293.15;
        end if;

        if haveConExtWin then
          for i in 1:NConExtWin loop
            Q_flow[i+NConExt+2*NConPar+NConBou+NSurBou]            = conExtWin[i].Q_flow;
            Q_flow[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin] = conExtWinFra[i].Q_flow;
          end for;
        else
          conExtWin[1].T    = 293.15;
          conExtWinFra[1].T = 293.15;
        end if;
        // Windows
        for j in 1:NWin loop
          Q_flow[j+NOpa] = JOutConExtWin[j];
          HOutConExtWin[j] = if (AConExtWinGla[j] > 1E-10) then JOutConExtWin[j] / AConExtWinGla[j] else 0;
        end for;

        annotation (
      preferredView="info",
      Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},
                  {240,240}}),
                            graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-240,-240},{240,240}}),
                                            graphics={
              Line(
                points={{-144,-8},{2,-200}},
                color={255,128,0},
                smooth=Smooth.None),
              Line(
                points={{2,-200},{2,184}},
                color={255,128,0},
                smooth=Smooth.None),
              Line(
                points={{2,-200},{148,-8}},
                color={255,128,0},
                smooth=Smooth.None,
                thickness=1),
              Rectangle(
                extent={{148,74},{174,-78}},
                lineColor={95,95,95},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{154,74},{158,-78}},
                lineColor={95,95,95},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{166,74},{170,-78}},
                lineColor={95,95,95},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid)}),
              Documentation(info="<html>
<p>
This model computes the distribution of the solar radiation gain
to the room surfaces.
Let
<i>N<sup>w</sup></i>
denote the number of windows,
<i>N<sup>f</sup></i>
the number of floor elements and
<i>N<sup>n</sup></i>
the number of non-floor elements such as ceiling, wall and window elements.
Input to the model are the solar radiosities
<i>J<sup>i</sup>, i &isin; {1, &hellip; , N<sup>w</sup>}</i>,
that were transmitted through the window.
The total incoming solar radiation is therefore
</p>
<p align=\"center\" style=\"font-style:italic;\">
H = &sum;<sub>i=1</sub><sup>N<sup>w</sup></sup> J<sub>in</sub><sup>i</sup>
</p>
<p>
It is assumed that <i>H</i> first hits the floor where some of it is absorbed,
and some of it is diffusely reflected to all other surfaces. Only the first
reflection is taken into account and the location of the floor patch
relative to the window is neglected.
</p>
<p>Hence, the radiation that is
absorbed by each floor patch <i>i &isin; {1, &hellip;, N<sup>f</sup>}</i>,
and may be partially transmitted in
the unusual case that the floor contains a window, is
</p>
<p align=\"center\" style=\"font-style:italic;\">
 Q<sup>i</sup> = H &nbsp; (&epsilon;<sup>i</sup>+&tau;<sup>i</sup>) &nbsp; A<sup>i</sup>
&frasl; &sum;<sub>j=1</sub><sup>N<sup>f</sup></sup> &nbsp; A<sup>j</sup>.
</p>
The sum of the radiation that is reflected by the floor is therefore
<p align=\"center\" style=\"font-style:italic;\">
 J<sup>f</sup> = H &nbsp;
&sum;<sub>i=1</sub><sup>N<sup>f</sup></sup>
(1-&epsilon;<sup>i</sup>-&tau;<sup>i</sup>) &nbsp; A<sup>i</sup>
&frasl; &sum;<sub>j=1</sub><sup>N<sup>f</sup></sup> &nbsp; A<sup>j</sup>.
</p>
<p>
This reflected radiosity is then distributed to all non-floor areas
<i>i &isin; {1, &hellip;, N<sup>n</sup>}</i>
using</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q<sup>i</sup> = J<sup>f</sup> &nbsp;
A<sup>i</sup> &nbsp; (&epsilon;<sup>i</sup>+&tau;<sup>i</sup>)
&frasl;
&sum;<sub>k=1</sub><sup>N<sup>n</sup></sup>
A<sup>k</sup> &nbsp; (&epsilon;<sup>k</sup>+&tau;<sup>k</sup>)
</p>
<p>
For opaque surfaces, the heat flow rate
<i>Q<sup>i</sup></i>
is set to be equal to the heat flow rate at the heat port.
For the glass of the windows, the heat flow rate
<i>Q<sup>i</sup></i> is set to the radiosity
<i>J<sub>out</sub><sup>i</sup></i>
that will strike the glass or the window shade as diffuse solar
radiation.
</html>",     revisions="<html>
<ul>
<li>
July 16, 2013, by Michael Wetter:<br/>
Added assignment of heat port temperature instead of heat flow rate
for the cases where a construction has been conditionally removed.
This is required to avoid a singularity.
</li>
<li>
November 6, 2011, by Michael Wetter:<br/>
Fixed bug as in the old version, the absorbtance and reflectance
of the infrared spectrum has been used instead of the solar spectrum.
</li>
<li>
Dec. 1 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end SolarRadiationExchange;

      partial model PartialSurfaceInterface
        "Partial model that is used for infrared radiation balance"
        extends Buildings.Rooms.BaseClasses.ConstructionRecords;

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExt[NConExt]
          "Heat port that connects to room-side surface of exterior constructions"
                                    annotation (Placement(transformation(extent={{230,210},
                  {250,230}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExtWin[NConExtWin]
          "Heat port that connects to room-side surface of exterior constructions that contain a window"
                                    annotation (Placement(transformation(extent={{230,170},
                  {250,190}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExtWinFra[NConExtWin]
          "Heat port that connects to room-side surface of window frame"
                                    annotation (Placement(transformation(extent={{232,-10},
                  {252,10}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conPar_a[NConPar]
          "Heat port that connects to room-side surface a of partition constructions"
                                    annotation (Placement(transformation(extent={{232,-70},
                  {252,-50}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conPar_b[NConPar]
          "Heat port that connects to room-side surface b of partition constructions"
                                    annotation (Placement(transformation(extent={{232,
                  -110},{252,-90}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conBou[NConBou]
          "Heat port that connects to room-side surface of constructions that expose their other surface to the outside"
                                    annotation (Placement(transformation(extent={{232,
                  -170},{252,-150}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conSurBou[NSurBou]
          "Heat port to surfaces of models that compute the heat conduction outside of this room"
                                    annotation (Placement(transformation(extent={{231,
                  -230},{251,-210}})));
      protected
        final parameter Modelica.SIunits.Area AConExt[NConExt] = datConExt.A
          "Areas of exterior constructions";
        final parameter Modelica.SIunits.Area AConExtWinOpa[NConExtWin] = datConExtWin.AOpa
          "Opaque areas of exterior construction that have a window";
        final parameter Modelica.SIunits.Area AConExtWinGla[NConExtWin] = (1 .- datConExtWin.fFra) .* datConExtWin.AWin
          "Glass areas of exterior construction that have a window";
        final parameter Modelica.SIunits.Area AConExtWinFra[NConExtWin] = datConExtWin.fFra .* datConExtWin.AWin
          "Frame areas of exterior construction that have a window";
        final parameter Modelica.SIunits.Area AConPar[NConPar] = datConPar.A
          "Areas of partition constructions";
        final parameter Modelica.SIunits.Area AConBou[NConBou] = datConBou.A
          "Areas of constructions with exterior boundary conditions exposed to outside of room model";
        final parameter Modelica.SIunits.Area ASurBou[NSurBou] = surBou.A
          "Area of surface models of constructions that are modeled outside of this room";

      protected
        function checkSurfaceAreas
          input Integer n "Number of surfaces";
          input Modelica.SIunits.Area A[:] "Surface areas";
          input String name
            "Name of the surface data record, used in error message";
        algorithm
          if n == 0 then
            assert(Modelica.Math.Vectors.norm(v=A, p=1) < 1E-10,
            "Error in declaration of room model: Construction record '" +
            name +
            "' has the following areas: " +
            Modelica.Math.Vectors.toString(A) +
            "However, the room model is declared as having zero surfaces.
Check the parameters of the room model.");
          else
            for i in 1:n loop
              assert(A[i] > 0, "Error in declaration of room model: Construction record '" + name + "' has the following areas: " +
            Modelica.Math.Vectors.toString(A) +
            "However, the surface areas must be bigger than zero.
Check the parameters of the room model.");
            end for;
          end if;
        end checkSurfaceAreas;
      initial algorithm
        checkSurfaceAreas(nConExt,    datConExt.A,       "datConExt");
        checkSurfaceAreas(nConExtWin, datConExtWin.AWin, "datConExtWin");
        checkSurfaceAreas(nConPar,    datConPar.A,       "datConPar");
        checkSurfaceAreas(nConBou,    datConBou.A,       "datConBou");
        checkSurfaceAreas(nSurBou,    surBou.A,          "surBou");
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,
                  -240},{240,240}}),
                            graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-240,-240},{240,240}}),
                                            graphics={
              Rectangle(
                extent={{-240,240},{240,-240}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{148,206},{174,-206}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-170,-200},{172,-224}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-170,206},{-144,-224}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-170,208},{174,184}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-234,328},{242,244}},
                lineColor={0,0,127},
                textString="%name"),
              Rectangle(
                extent={{-144,184},{148,-198}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid)}),
              Documentation(info="<html>
<p>
This partial model is used as a base class for models that need to exchange
heat with room-facing surfaces. It defines parameters for the surface areas.
The model is used as a base class to implement the convective model, and the various
radiation models.
</p>
</html>",
      revisions="<html>
<ul>
<li>
July 12, 2013, by Michael Wetter:<br/>
Removed the radiation related declarations
to facilitate the separation of the convective and radiative model.
</li>
<li>
July 17, 2012, by Michael Wetter:<br/>
Added validity check of surface areas.
This helped catching a bug in an early implementation of BESTEST Case960
in which the extending class set <code>nConExtWin=0</code>,
but did not set the area to zero.
Because the radiation balance model computes exchange among
<code>NConExtWin=max(nConExtWin, 1)</code> areas, its result was wrong.
</li>
<li>
November 6, 2011, by Michael Wetter:<br/>
Changed parameters that contain radiative properties from final to non-final, as
they need to be overwritten by
<a href=\"modelica://Buildings.Rooms.BaseClasses.SolarRadiationExchange\">
Buildings.Rooms.BaseClasses.SolarRadiationExchange</a>.
</li>
<li>
November 16 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialSurfaceInterface;

      partial model PartialSurfaceInterfaceRadiative
        "Partial model that is used for infrared radiation balance"
        extends Buildings.Rooms.BaseClasses.PartialSurfaceInterface;

      protected
        parameter Modelica.SIunits.Emissivity epsConExt[NConExt] = datConExt.layers.absIR_b
          "Absorptivity of exterior constructions";
        parameter Modelica.SIunits.Emissivity epsConExtWinOpa[NConExtWin] = datConExtWin.layers.absIR_b
          "Absorptivity of opaque part of exterior constructions that contain a window";
        parameter Modelica.SIunits.Emissivity epsConExtWinUns[NConExtWin]=
          {(datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].absIR_b) for i in 1:NConExtWin}
          "Absorptivity of unshaded part of window constructions";
        parameter Modelica.SIunits.Emissivity epsConExtWinSha[NConExtWin] = datConExtWin.glaSys.shade.absIR_a
          "Absorptivity of shaded part of window constructions";
        parameter Modelica.SIunits.Emissivity epsConExtWinFra[NConExtWin] = datConExtWin.glaSys.absIRFra
          "Absorptivity of window frame";
        parameter Modelica.SIunits.Emissivity epsConPar_a[NConPar] = datConPar.layers.absIR_a
          "Absorptivity of partition constructions surface a";
        parameter Modelica.SIunits.Emissivity epsConPar_b[NConPar] = datConPar.layers.absIR_b
          "Absorptivity of partition constructions surface b";
        parameter Modelica.SIunits.Emissivity epsConBou[NConBou] = datConBou.layers.absIR_b
          "Absorptivity of constructions with exterior boundary conditions exposed to outside of room model";
        parameter Modelica.SIunits.Emissivity epsSurBou[NSurBou] = surBou.absIR
          "Absorptivity of surface models of constructions that are modeled outside of this room";

        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,
                  -240},{240,240}}),
                            graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-240,-240},{240,240}}),
                                            graphics={
              Text(
                extent={{-234,328},{242,244}},
                lineColor={0,0,127},
                textString="%name")}),
              Documentation(info="<html>
<p>
This partial model is used as a base class for models that need to exchange
heat with room-facing surfaces by radiation. It declares parameters that are
needed for the radiative balance.
</p>
</html>",
      revisions="<html>
<ul>
<li>
July 12, 2013, by Michael Wetter:<br/>
First implementation to facilitate the separation of the convective and radiative model.
</li>
</ul>
</html>"));
      end PartialSurfaceInterfaceRadiative;

      model SkyRadiationExchange
        "Radiative heat exchange with the sky and the ambient"
        extends Buildings.BaseClasses.BaseIcon;
        parameter Integer n(min=1) "Number of constructions";
         parameter Modelica.SIunits.Area A[n] "Area of exterior constructions";
        parameter Real vieFacSky[n](min=0, max=1)
          "View factor to sky (=1 for roofs)";
        parameter Modelica.SIunits.Emissivity absIR[n]
          "Infrared absorptivity of building surface";
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port[n] "Heat port"
          annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        Modelica.Blocks.Interfaces.RealInput TOut(final quantity="ThermodynamicTemperature",
                                                  final unit = "K", min=0)
          "Outside air temperature"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}}),
              iconTransformation(extent={{-140,-60},{-100,-20}})));
        Modelica.Blocks.Interfaces.RealInput TBlaSky(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Black body sky temperature"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}}),
              iconTransformation(extent={{-140,20},{-100,60}})));
      protected
        parameter Real k[n](unit="W/K4") = {4*A[i]*Modelica.Constants.sigma*absIR[i] for i in 1:n}
          "Constant for radiative heat exchange";
        Modelica.SIunits.Temperature TEnv[n] "Environment temperature";
        Real TBlaSky4(unit="K4")
          "Auxiliary variable for radiative heat exchange";
        Real TOut4(unit="K4") "Auxiliary variable for radiative heat exchange";
        Modelica.SIunits.CoefficientOfHeatTransfer h[n]
          "Radiative heat transfer coefficient";

      equation
        TBlaSky4 = TBlaSky^4;
        TOut4 = TOut^4;
        for i in 1:n loop
          TEnv[i] = (vieFacSky[i] * TBlaSky4 + (1-vieFacSky[i]) * TOut4)^(0.25);
          // h[i] uses TEnv[i] instead of (port[i].T+TEnv[i])/2 to avoid
          // a nonlinear equation system
          h[i]  = k[i] * TEnv[i]^3;
          port[i].Q_flow = h[i] * (port[i].T-TEnv[i]);
        end for;
        annotation ( Icon(graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,80},{-40,-60}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{88,-60},{-74,-74}},
                fillColor={5,135,13},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Ellipse(
                extent={{2,82},{86,36}},
                pattern=LinePattern.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Line(
                points={{-40,16},{-30,28},{-14,28},{-6,44},{10,42},{12,46}},
                smooth=Smooth.None,
                color={255,0,0},
                thickness=0.5),
              Line(
                points={{-40,16},{-22,-4},{2,-6},{12,-30},{42,-40},{48,-58}},
                smooth=Smooth.None,
                color={255,0,0},
                thickness=0.5),
              Text(
                extent={{-128,12},{-78,-34}},
                lineColor={0,0,127},
                textString="TOut"),
              Text(
                extent={{-130,96},{-80,50}},
                lineColor={0,0,127},
                textString="TSky"),
              Text(
                extent={{86,52},{136,6}},
                lineColor={0,0,127},
                textString="QIR_flow")}),
              Documentation(info = "<html>
This model computes the infrared radiative heat flow
between exterior building surfaces and the ambient. The ambient consists
of the sky black-body radiation and the outdoor temperature
(which is used as an approximation to the surface temperature of
the ground and neighboring buildings).
</html>",     revisions="<html>
<ul>
<li>
June 4 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end SkyRadiationExchange;

      record ConstructionNumbers "Data records for construction data"

        ////////////////////////////////////////////////////////////////////////
        // Number of constructions and surface areas
        parameter Integer nConExt(min=0) "Number of exterior constructions"
          annotation (Dialog(group="Exterior constructions"));
        parameter Integer nConExtWin(min=0) "Number of window constructions"
          annotation (Dialog(group="Exterior constructions"));

        parameter Integer nConPar(min=0) "Number of partition constructions"
        annotation (Dialog(group="Partition constructions"));

        parameter Integer nConBou(min=0)
          "Number of constructions that have their outside surface exposed to the boundary of this room"
        annotation (Dialog(group="Boundary constructions"));

        parameter Integer nSurBou(min=0)
          "Number of surface heat transfer models that connect to constructions that are modeled outside of this room"
        annotation (Dialog(group="Boundary constructions"));

        // Dimensions of components and connectors
        final parameter Integer NConExt(min=1) = max(1, nConExt)
          "Number of elements for exterior constructions"
          annotation (HideResult=true);

        final parameter Integer NConExtWin(min=1)=max(1, nConExtWin)
          "Number of elements for exterior constructions with windows"
          annotation (HideResult=true);

        final parameter Integer NConPar(min=1)=max(1, nConPar)
          "Number of elements for partition constructions"
          annotation (HideResult=true);

        final parameter Integer NConBou(min=1)=max(1, nConBou)
          "Number of elements for constructions that have their outside surface exposed to the boundary of this room"
          annotation (HideResult=true);

        final parameter Integer NSurBou(min=1)=max(1, nSurBou)
          "Number of elements for surface heat transfer models that connect to constructions that are modeled outside of this room"
          annotation (HideResult=true);

        // Flags to conditionally remove components
        final parameter Boolean haveConExt = nConExt > 0
          "Flag to conditionally remove components"
          annotation (HideResult=true);
        final parameter Boolean haveConExtWin = nConExtWin > 0
          "Flag to conditionally remove components"
          annotation (HideResult=true);
        final parameter Boolean haveConPar = nConPar > 0
          "Flag to conditionally remove components"
          annotation (HideResult=true);
        final parameter Boolean haveConBou = nConBou > 0
          "Flag to conditionally remove components"
          annotation (HideResult=true);
        final parameter Boolean haveSurBou = nSurBou > 0
          "Flag to conditionally remove components"
          annotation (HideResult=true);
      annotation (
      Documentation(
      info="<html>
<p>
Record that defines the number of constructions that are
used in the room model.
</p>
<p>
This record also declares parameters that contain the number of constructions,
such as the number of exterior constructions <code>nConExt</code>.
This parameter may take on the value <code>0</code>.
If this parameter were to be used to declare the size of vectors of
component models, then there may be vectors with zero components.
This can cause problems in Dymola 7.4.
Therefore, a parameter is declared in the form
</p>
<pre>
  NConExt = max(1, nConExt)
</pre>
<p>This parameter is the used by models that extend this model
to set the size of the vector of component models.</p>
<p>
There are also parameters that can be used to conditionally remove components,
such as <code>haveConExt</code>, which is set to
</p>
<pre>
  haveConExt = nConExt > 0;
</pre>
</html>",
      revisions="<html>
<ul>
<li>
October 1, 2013, by Michael Wetter:<br/>
Added <code>HideResult=true</code> annotation.
</li>
<li>
January 14, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      end ConstructionNumbers;

      record ConstructionRecords "Data records for construction data"
        extends Buildings.Rooms.BaseClasses.ConstructionNumbers;

        parameter ParameterConstruction datConExt[NConExt](
          each A=0,
          each layers = dummyCon,
          each til=0,
          each azi=0) "Data for exterior construction"
          annotation (Placement(transformation(extent={{-140,-120},{-120,-100}})), HideResult=true);
        parameter Buildings.Rooms.BaseClasses.ParameterConstructionWithWindow
          datConExtWin[NConExtWin](
          each A=0,
          each layers = dummyCon,
          each til=0,
          each azi=0,
          each hWin=0,
          each wWin=0,
          each glaSys=dummyGlaSys) "Data for exterior construction with window"
          annotation (Placement(transformation(extent={{-140,-160},{-120,-140}})), HideResult=true);
        parameter Buildings.Rooms.BaseClasses.ParameterConstruction datConPar[NConPar](
          each A=0,
          each layers = dummyCon,
          each til=0,
          each azi=0) "Data for partition construction"
          annotation (Placement(transformation(extent={{-140,-200},{-120,-180}})), HideResult=true);
        parameter Buildings.Rooms.BaseClasses.ParameterConstruction datConBou[NConBou](
          each A=0,
          each layers = dummyCon,
          each til=0,
          each azi=0) "Data for construction boundary"
          annotation (Placement(transformation(extent={{-100,-120},{-80,-100}})), HideResult=true);
        parameter Buildings.HeatTransfer.Data.OpaqueSurfaces.Generic surBou[NSurBou](
          each A=0,
          each til=0)
          "Record for data of surfaces whose heat conduction is modeled outside of this room"
          annotation (Placement(transformation(extent={{-80,-160},{-100,-140}})), HideResult=true);

        // Dummy constructions to assign values to parameters.
        // The actual assignments will be overwritten by models that extend this model.
        // Note that parameters in records cannot be protected. However, we set the
        // annotation HideResult=true to avoid that they show up in the output file.
        parameter HeatTransfer.Data.OpaqueConstructions.Brick120 dummyCon
          "Dummy construction to assign a parameter to the instance"
          annotation (HideResult=true);
        parameter Buildings.HeatTransfer.Data.GlazingSystems.SingleClear3 dummyGlaSys
          "Dummy construction to assign a parameter to the instance"
          annotation (HideResult=true);
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},
                  {100,100}})),       Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-200,-200},{100,100}})),
      Documentation(
      info="<html>
<p>
Record that defines the number of constructions that are
used in the room model.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 14, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      end ConstructionRecords;

      record Overhang "Record for window overhang"
        extends Modelica.Icons.Record;

        parameter Modelica.SIunits.Length wL(min=0)
          "Overhang width left to the window, measured from the window corner"
          annotation(Dialog(tab="General",group="Overhang"));
        parameter Modelica.SIunits.Length wR(min=0)
          "Overhang width right to the window, measured from the window corner"
          annotation(Dialog(tab="General",group="Overhang"));

        parameter Modelica.SIunits.Length dep(min=0)
          "Overhang depth (measured perpendicular to the wall plane)"
          annotation(Dialog(tab="General",group="Overhang"));
        parameter Modelica.SIunits.Length gap(min=0)
          "Distance between window upper edge and overhang lower edge"
          annotation(Dialog(tab="General",group="Overhang"));

        final parameter Boolean haveOverhang= dep > Modelica.Constants.eps
          "Flag, true if the window has an overhang"
          annotation(Evaluate=true);

        annotation (
      Documentation(info="<html>
<p>
This record declares parameters for window overhangs.
</p>
<p>
See
<a href=\"modelica://Buildings.HeatTransfer.Windows.Overhang\">
Buildings.HeatTransfer.Windows.Overhang</a>
for an explanation of the parameters, and
for the assumptions and limitations
of the overhang model.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed definitions of <code>wL</code> and <code>wR</code> to be
measured from the corner of the window instead of the centerline.
This allows changing the window width without having to adjust the
overhang parameters.
</li>
<li>
May 21, 2012, by Kaustubh Phalak:<br/>
Removed <code>gap &gt; 0</code> as a necessary condition.
There can be an overhang with no gap.
</li>
<li>
March 5, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      end Overhang;

      record ParameterConstructionWithWindow
        "Record for exterior constructions that have a window"
        extends Buildings.Rooms.BaseClasses.PartialParameterConstruction;

        parameter Modelica.SIunits.Area A
          "Heat transfer area of opaque construction and window combined";
        parameter Modelica.SIunits.Length hWin "Window height"
          annotation (Dialog(group="Glazing system"));
        parameter Modelica.SIunits.Length wWin "Window width"
          annotation (Dialog(group="Glazing system"));
        final parameter Modelica.SIunits.Area AWin=hWin*wWin
          "Heat transfer area of window"
            annotation (Dialog(group="Glazing system"));

        final parameter Modelica.SIunits.Area AOpa = A-AWin
          "Heat transfer area of opaque construction"
          annotation (Dialog(group="Opaque construction"));

        parameter Real fFra(
          final min=0,
          final max=1) = 0.1
          "Fraction of window frame divided by total window area"
          annotation (Dialog(group="Glazing system"));

       parameter Buildings.Rooms.BaseClasses.Overhang ove(
          wR=0,
          wL=0,
          dep=0,
          gap=0) "Geometry of overhang"
          annotation (Dialog(group="Glazing system"), choicesAllMatching=true, Placement(transformation(extent={{60,20},
                  {80,40}})));
       parameter Buildings.Rooms.BaseClasses.SideFins sidFin(h=0, dep=0, gap=0)
          "Geometry of side fins"
          annotation (Dialog(group="Glazing system"), choicesAllMatching=true, Placement(transformation(extent={{60,-20},
                  {80,0}})));

        final parameter Modelica.SIunits.Area AFra = fFra*AWin "Frame area"
          annotation (Dialog(group="Glazing system"));
        final parameter Modelica.SIunits.Area AGla=AWin - AFra "Glass area"
          annotation (Dialog(group="Glazing system"));

        parameter HeatTransfer.Data.GlazingSystems.Generic glaSys
          "Material properties of glazing system"
          annotation (Dialog(group="Glazing system"), choicesAllMatching=true, Placement(transformation(extent={{58,62},
                  {78,82}})));
        final parameter Boolean haveOverhangOrSideFins = (ove.dep > 1E-8) or (sidFin.dep > 1E-8)
          "Flag, true if the construction has either an overhang or side fins"
          annotation(Evaluate=true);

        annotation (
      Documentation(info="<html>
<p>
This data record is used to set the parameters of constructions that do have a window.
</p>
<p>
The surface azimuth is defined in
<a href=\"modelica://Buildings.HeatTransfer.Types.Azimuth\">
Buildings.HeatTransfer.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.HeatTransfer.Types.Tilt\">
Buildings.HeatTransfer.Types.Tilt</a>
</p>
</html>",       revisions="<html>
<ul>
<li>
October 28, 2014, by Michael Wetter:<br/>
Removed <code>replacable</code> keyword for parameters that are records as this is not needed.
</li>
<li>
October 27, 2014, by Michael Wetter:<br/>
Introduced the parameter <code>haveOverhangOrSideFins</code> which is needed by
<a href=\"modelica://Buildings.Rooms.BaseClasses.ExteriorBoundaryConditionsWithWindow\">
Buildings.Rooms.BaseClasses.ExteriorBoundaryConditionsWithWindow</a>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
December 14, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      end ParameterConstructionWithWindow;

      record ParameterConstruction
        "Record for exterior constructions that have no window"
        extends Buildings.Rooms.BaseClasses.PartialParameterConstruction;
        parameter Modelica.SIunits.Area A "Heat transfer area";

        annotation (
      Documentation(info="<html>
<p>
This data record is used to set the parameters of constructions that do not have a window.
</p>
<p>
The surface azimuth is defined in
<a href=\"modelica://Buildings.HeatTransfer.Types.Azimuth\">
Buildings.HeatTransfer.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.HeatTransfer.Types.Tilt\">
Buildings.HeatTransfer.Types.Tilt</a>
</p>
</html>",       revisions="<html>
<ul>
<li>
December 14, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      end ParameterConstruction;

      record PartialParameterConstruction "Partial record for constructions"
        extends Modelica.Icons.Record;
        parameter Buildings.HeatTransfer.Data.OpaqueConstructions.Generic
          layers "Material properties of opaque construction"
          annotation(Dialog(group="Opaque construction"),
                     choicesAllMatching=true, Placement(transformation(extent={{146,258},
                  {166,278}})));
        parameter Modelica.SIunits.Angle til "Surface tilt";
        parameter Modelica.SIunits.Angle azi "Surface azimuth";
        final parameter Boolean isFloor=til > 2.74889125 and til < 3.53428875
          "Flag, true if construction is a floor" annotation (Evaluate=true);
        final parameter Boolean isCeiling=til > -0.392699 and til < 0.392699
          "Flag, true if construction is a floor" annotation (Evaluate=true);
        final parameter Integer nLay(min=1, fixed=true) = layers.nLay
          "Number of layers";
        final parameter Integer nSta[nLay](each min=1)={layers.material[i].nSta for i in 1:nLay}
          "Number of states"  annotation(Evaluate=true);
        parameter Boolean steadyStateInitial=false
          "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
              annotation (Dialog(group="Initialization"), Evaluate=true);
        parameter Modelica.SIunits.Temperature T_a_start=293.15
          "Initial temperature at port_a, used if steadyStateInitial = false"
          annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
        parameter Modelica.SIunits.Temperature T_b_start=293.15
          "Initial temperature at port_b, used if steadyStateInitial = false"
          annotation (Dialog(group="Initialization", enable=not steadyStateInitial));

        annotation (
      Documentation(info="<html>
<p>
This data record is used to set the parameters of constructions that do not have a window.
</p>
<p>
The surface azimuth is defined in
<a href=\"modelica://Buildings.HeatTransfer.Types.Azimuth\">
Buildings.HeatTransfer.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.HeatTransfer.Types.Tilt\">
Buildings.HeatTransfer.Types.Tilt</a>
</p>
</html>",       revisions="<html>
<ul>
<li>
October 11, 2013, by Michael Wetter:<br/>
Added missing <code>each</code> keyword.
</li>
<li>
December 14, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      end PartialParameterConstruction;

      record SideFins "Record for window side fins"
        extends Modelica.Icons.Record;
        parameter Modelica.SIunits.Length h(min=0)
          "Height of side fin that extends above window, measured from top of window"
          annotation(Dialog(tab="General",group="Side fin"));
        parameter Modelica.SIunits.Length dep(min=0)
          "Side fin depth (measured perpendicular to the wall plane)"
          annotation(Dialog(tab="General",group="Side fin"));
        parameter Modelica.SIunits.Length gap(min=0)
          "Distance between side fin and window edge"
          annotation(Dialog(tab="General",group="Side fin"));

        final parameter Boolean haveSideFins= dep > Modelica.Constants.eps
          "Flag, true if the window has side fins" annotation (Evaluate=true);

        annotation (
      Documentation(info="<html>
<p>
This record declares parameters for window side fins.
</p>
<p>
See
<a href=\"modelica://Buildings.HeatTransfer.Windows.SideFins\">
Buildings.HeatTransfer.Windows.SideFins</a>
for an explanation of the parameters, and
for the assumptions and limitations
of the model for side fins.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed definitions of side fin height <code>h</code> to be
measured from the top of the window.
This allows changing the window height without having to adjust the
side fin parameters.
</li>
<li>
May 21, 2012, by Kaustubh Phalak:<br/>
Removed <code>gap &gt; 0</code> as a necessary condition. There can be a side fin with no gap.
</li>
<li>
March 5, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      end SideFins;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Rooms\">Buildings.Rooms</a>.
</p>
</html>"));
    end BaseClasses;
  annotation (
  preferredView="info", Documentation(info="<html>
<p>
This package contains models for the heat transfer in rooms
and through the building envelope.
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
        graphics={
        Rectangle(
          extent={{-64,34},{64,-74}},
          lineColor={150,150,150},
          fillPattern=FillPattern.Solid,
          fillColor={150,150,150}),
        Polygon(
          points={{0,76},{-78,34},{80,34},{0,76}},
          lineColor={95,95,95},
          smooth=Smooth.None,
          fillPattern=FillPattern.Solid,
          fillColor={95,95,95}),
        Rectangle(
          extent={{16,-8},{44,20}},
          lineColor={255,255,255},
          fillColor={255,255,255},
          fillPattern=FillPattern.Solid),
        Rectangle(
          extent={{-42,-8},{-14,20}},
          lineColor={255,255,255},
          fillColor={255,255,255},
          fillPattern=FillPattern.Solid),
        Rectangle(
          extent={{-42,-58},{-14,-30}},
          lineColor={255,255,255},
          fillColor={255,255,255},
          fillPattern=FillPattern.Solid),
        Rectangle(
          extent={{16,-58},{44,-30}},
          lineColor={255,255,255},
          fillColor={255,255,255},
          fillPattern=FillPattern.Solid)}));
  end Rooms;

  package Utilities "Package with utility functions such as for I/O"
    extends Modelica.Icons.Package;

    package Math "Library with functions such as for smoothing"
      extends Modelica.Icons.Package;

      package Functions "Package with mathematical functions"
        extends Modelica.Icons.VariantsPackage;

        function cubicHermiteLinearExtrapolation
          "Interpolate using a cubic Hermite spline with linear extrapolation"
          input Real x "Abscissa value";
          input Real x1 "Lower abscissa value";
          input Real x2 "Upper abscissa value";
          input Real y1 "Lower ordinate value";
          input Real y2 "Upper ordinate value";
          input Real y1d "Lower gradient";
          input Real y2d "Upper gradient";
          output Real y "Interpolated ordinate value";
        algorithm
          if (x > x1 and x < x2) then
            y:=Modelica.Fluid.Utilities.cubicHermite(
              x=x,
              x1=x1,
              x2=x2,
              y1=y1,
              y2=y2,
              y1d=y1d,
              y2d=y2d);
          elseif x <= x1 then
            // linear extrapolation
            y:=y1 + (x - x1)*y1d;
          else
            y:=y2 + (x - x2)*y2d;
          end if;
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
For <i>x<sub>1</sub> &lt; x &lt; x<sub>2</sub></i>, this function interpolates
using cubic hermite spline. For <i>x</i> outside this interval, the function
linearly extrapolates.
</p>
<p>
For how to use this function, see
<a href=\"modelica://Buildings.Utilities.Math.Functions.Examples.CubicHermite\">
Buildings.Utilities.Math.Functions.Examples.CubicHermite</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end cubicHermiteLinearExtrapolation;

        function inverseXRegularized
          "Function that approximates 1/x by a twice continuously differentiable function"
         input Real x "Abscissa value";
         input Real delta(min=0)
            "Abscissa value below which approximation occurs";
         output Real y "Function value";
        protected
         Real delta2 "Delta^2";
         Real x2_d2 "=x^2/delta^2";
        algorithm
          if (abs(x) > delta) then
            y := 1/x;
          else
            delta2 :=delta*delta;
            x2_d2  := x*x/delta2;
            y      := x/delta2 + x*abs(x/delta2/delta*(2 - x2_d2*(3 - x2_d2)));
          end if;

          annotation (
            Documentation(info="<html>
<p>
Function that approximates <i>y=1 &frasl; x</i>
inside the interval <i>-&delta; &le; x &le; &delta;</i>.
The approximation is twice continuously differentiable with a bounded derivative on the whole
real line.
<p>
See the package <code>Examples</code> for the graph.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 18, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),          smoothOrder=2, Inline=true);
        end inverseXRegularized;

        function isMonotonic
          "Returns true if the argument is a monotonic sequence"
          input Real x[:] "Sequence to be tested";
          input Boolean strict=false
            "Set to true to test for strict monotonicity";
          output Boolean monotonic
            "True if x is monotonic increasing or decreasing";
        protected
          Integer n=size(x, 1) "Number of data points";

        algorithm
          if n == 1 then
            monotonic := true;
          else
            monotonic := true;
            if strict then
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] > x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] < x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            else
              // not strict
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] >= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] <= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            end if;
            // strict
          end if;

          annotation (Documentation(info="<html>
<p>
This function returns <code>true</code> if its argument is
monotonic increasing or decreasing, and <code>false</code> otherwise.
If <code>strict=true</code>, then strict monotonicity is tested,
otherwise weak monotonicity is tested.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 28, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end isMonotonic;

        function polynomial "Polynomial function"
         input Real x "Independent variable";
         input Real a[:] "Coefficients";
         output Real y "Result";
        protected
         parameter Integer n = size(a, 1)-1;
         Real xp[n+1] "Powers of x";
        algorithm
          xp[1] :=1;
          for i in 1:n loop
             xp[i+1] :=xp[i]*x;
          end for;
          y :=a*xp;
          annotation (Documentation(info="<html>
This function computes a polynomial of arbitrary order.
The polynomial has the form
<p align=\"center\" style=\"font-style:italic;\">
  y = a<sub>1</sub> + a<sub>2</sub> x + a<sub>3</sub> x<sup>2</sup> + ...
</p>
</html>"),
        revisions="<html>
<ul>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
March 2, by Michael Wetter:<br/>
Removed redundant <code>smoothOrder</code> annotation.
</li>
<li>
February 29, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>",
        smoothOrder=999,
        derivative(zeroDerivative=a)=Buildings.Utilities.Math.Functions.BaseClasses.der_polynomial);
        end polynomial;

        function powerLinearized
          "Power function that is linearized below a user-defined threshold"

         input Real x "Abscissa value";
         input Real n "Exponent";
         input Real x0 "Abscissa value below which linearization occurs";
         output Real y "Function value";
        algorithm
          if x > x0 then
           y := x^n;
          else
           y := x0^n * (1-n) + n * x0^(n-1) * x;
          end if;
          annotation (
            Documentation(info="<html>
Function that approximates <i>y=x<sup>n</sup></i>
where <i>0 &lt; n</i> so that
<ul>
<li>the function is defined and monotone increasing for all <i>x</i>.
<li><i>dy/dx</i> is bounded and continuous everywhere (for <i>n &lt; 1</i>).
</ul>
<p>
For <i>x &lt; x<sub>0</sub></i>, this function replaces
<i>y=x<sup>n</sup></i> by
a linear function that is continuously differentiable everywhere.
</p>
<p>
A typical use of this function is to replace
<i>T = T4<sup>(1/4)</sup></i> in a radiation balance to ensure that the
function is defined everywhere. This can help solving the initialization problem
when a solver may be far from a solution and hence <i>T4 &lt; 0</i>.
</p>
<p>
See the package <code>Examples</code> for the graph.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 3, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),          smoothOrder=1, Inline=true);
        end powerLinearized;

        function quadraticLinear
          "Function that is quadratic in first argument and linear in second argument"
         input Real a[6] "Coefficients";
         input Real x1 "Independent variable for quadratic part";
         input Real x2 "Independent variable for linear part";
         output Real y "Result";
        protected
         Real x1Sq;
        algorithm
          x1Sq :=x1*x1;
          y :=a[1] + a[2]*x1 + a[3]*x1Sq + (a[4] + a[5]*x1 + a[6]*x1Sq)*x2;

          annotation (smoothOrder=999, Documentation(info="<html>
This function computes
<p align=\"center\" style=\"font-style:italic;\">
  y =   a<sub>1</sub> + a<sub>2</sub>  x<sub>1</sub>
        + a<sub>3</sub> x<sub>1</sub><sup>2</sup>
        + (a<sub>4</sub> + a<sub>5</sub>  x<sub>1</sub>
        + a<sub>6</sub> x<sub>1</sub><sup>2</sup>)  x<sub>2</sub>
</p>
</html>",         revisions="<html>
<ul>
<li>
February 29, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end quadraticLinear;

        function regNonZeroPower
          "Power function, regularized near zero, but nonzero value for x=0"

         input Real x "Abscissa value";
         input Real n "Exponent";
         input Real delta = 0.01 "Abscissa value where transition occurs";
         output Real y "Function value";
        protected
          Real a1;
          Real a3;
          Real a5;
          Real delta2;
          Real x2;
          Real y_d "=y(delta)";
          Real yP_d "=dy(delta)/dx";
          Real yPP_d "=d^2y(delta)/dx^2";
        algorithm
          if abs(x) > delta then
           y := abs(x)^n;
          else
           delta2 :=delta*delta;
           x2 :=x*x;
           y_d :=delta^n;
           yP_d :=n*delta^(n - 1);
           yPP_d :=n*(n - 1)*delta^(n - 2);
           a1 := -(yP_d/delta - yPP_d)/delta2/8;
           a3 := (yPP_d - 12 * a1 * delta2)/2;
           a5 := (y_d - delta2 * (a3 + delta2 * a1));
           y := a5 + x2 * (a3 + x2 * a1);
           assert(a5>0, "Delta is too small for this exponent.");
          end if;
          annotation (
            Documentation(info="<html>

Function that approximates <i>y=|x|<sup>n</sup></i> where <i>n &gt; 0</i>
so that
<ul>
<li><i>y(0)</i> is not equal to zero.
<li><i>dy/dx</i> is bounded and continuous everywhere.
</ul>

<p>
This function replaces <i>y=|x|<sup>n</sup></i> in the interval
<i>-&delta;...+&delta;</i> by a 4-th order polynomial that has the same
function value and the first and second derivative at <i>x=&plusmn; &delta;</i>.
</p>
<p>
A typical use of this function is to replace the
function for the convective heat transfer
coefficient for forced or free convection that is of the form
<i>h=c |dT|<sup>n</sup></i> for some constant <i>c</i> and exponent
<i>0 &le; n &le; 1</i>.
By using this function, the original function
that has an infinite derivative near zero and that takes on zero
at the origin is replaced by a function with a bounded derivative and
a non-zero value at the origin. Physically,
the region <i>-&delta;...+&delta;</i> may be interpreted as the region
where heat conduction dominates convection in the boundary layer.
</p>
See the package <code>Examples</code> for the graph.
</html>",         revisions="<html>
<ul>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 14, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Inline=true,
                   smoothOrder=2,
                   derivative(zeroDerivative=n, zeroDerivative=delta)=BaseClasses.der_regNonZeroPower);
        end regNonZeroPower;

        function smoothLimit
          "Once continuously differentiable approximation to the limit function"
          input Real x "Variable";
          input Real l "Low limit";
          input Real u "Upper limit";
          input Real deltaX "Width of transition interval";
          output Real y "Result";

        protected
          Real cor;
        algorithm
          cor :=deltaX/10;
          y := Buildings.Utilities.Math.Functions.smoothMax(x,l+deltaX,cor);
          y := Buildings.Utilities.Math.Functions.smoothMin(y,u-deltaX,cor);
          annotation (Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>limit(.,.)</code> function.
The output is bounded to be in <i>[l, u]</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
Sept 1, 2010, by Michael Wetter:<br/>
Changed scaling to make sure that bounds are never violated.
</li>
<li>
July 14, 2010, by Wangda Zuo, Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothLimit;

        function smoothMax
          "Once continuously differentiable approximation to the maximum function"
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := Buildings.Utilities.Math.Functions.spliceFunction(
                 pos=x1, neg=x2, x=x1-x2, deltax=deltaX);
          annotation (
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>max(.,.)</code> function.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMax;

        function smoothMin
          "Once continuously differentiable approximation to the minimum function"
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := Buildings.Utilities.Math.Functions.spliceFunction(
               pos=x1, neg=x2, x=x2-x1, deltax=deltaX);
          annotation (
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>min(.,.)</code> function.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMin;

        function spliceFunction
            input Real pos "Argument of x > 0";
            input Real neg "Argument of x < 0";
            input Real x "Independent value";
            input Real deltax "Half width of transition interval";
            output Real out "Smoothed value";
        protected
            Real scaledX1;
            Real y;
            constant Real asin1 = Modelica.Math.asin(1);
        algorithm
            scaledX1 := x/deltax;
            if scaledX1 <= -0.999999999 then
              out := neg;
            elseif scaledX1 >= 0.999999999 then
              out := pos;
            else
              y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX1*asin1)) + 1)/2;
              out := pos*y + (1 - y)*neg;
            end if;

            annotation (
        smoothOrder=1,
        derivative=BaseClasses.der_spliceFunction,
        Documentation(info="<html>
<p>
Function to provide a once continuously differentialbe transition between
to arguments.
</p><p>
The function is adapted from
<a href=\"modelica://Modelica.Media.Air.MoistAir.Utilities.spliceFunction\">
Modelica.Media.Air.MoistAir.Utilities.spliceFunction</a> and provided here
for easier accessability to model developers.
</html>",         revisions="<html>
<ul>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
May 11, 2010, by Michael Wetter:<br/>
Removed default value for transition interval as this is problem dependent.
</li>
<li>
May 20, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end spliceFunction;

        function splineDerivatives
          "Function to compute the derivatives for cubic hermite spline interpolation"
          input Real x[:] "Support point, strict monotone increasing";
          input Real y[size(x, 1)] "Function values at x";
          input Boolean ensureMonotonicity=isMonotonic(y, strict=false)
            "Set to true to ensure monotonicity of the cubic hermite";
          output Real d[size(x, 1)] "Derivative at the support points";
        protected
          Integer n=size(x, 1) "Number of data points";
          Real delta[n - 1] "Slope of secant line between data points";
          Real alpha "Coefficient to ensure monotonicity";
          Real beta "Coefficient to ensure monotonicity";
          Real tau "Coefficient to ensure monotonicity";

        algorithm
          if (n>1) then
            assert(x[1] < x[n], "x must be strictly increasing.
  Received x[1] = "         + String(x[1]) + "
           x["         + String(n) + "] = " + String(x[n]));
          // Check data
            assert(isMonotonic(x, strict=true),
              "x-values must be strictly monontone increasing or decreasing.");
            if ensureMonotonicity then
              assert(isMonotonic(y, strict=false),
                "If ensureMonotonicity=true, y-values must be monontone increasing or decreasing.");
            end if;
          end if;

          // Compute derivatives at the support points
          if n == 1 then
            // only one data point
            d[1] :=0;
          elseif n == 2 then
            // linear function
            d[1] := (y[2] - y[1])/(x[2] - x[1]);
            d[2] := d[1];
          else
            // Slopes of the secant lines between i and i+1
            for i in 1:n - 1 loop
              delta[i] := (y[i + 1] - y[i])/(x[i + 1] - x[i]);
            end for;
            // Initial values for tangents at the support points.
            // End points use one-sided derivatives
            d[1] := delta[1];
            d[n] := delta[n - 1];

            for i in 2:n - 1 loop
              d[i] := (delta[i - 1] + delta[i])/2;
            end for;

          end if;
          // Ensure monotonicity
          if n > 2 and ensureMonotonicity then
            for i in 1:n - 1 loop
              if (abs(delta[i]) < Modelica.Constants.small) then
                d[i] := 0;
                d[i + 1] := 0;
              else
                alpha := d[i]/delta[i];
                beta := d[i + 1]/delta[i];
                // Constrain derivative to ensure monotonicity in this interval
                if (alpha^2 + beta^2) > 9 then
                  tau := 3/(alpha^2 + beta^2)^(1/2);
                  d[i] := delta[i]*alpha*tau;
                  d[i + 1] := delta[i]*beta*tau;
                end if;
              end if;
            end for;
          end if;
          annotation (Documentation(info="<html>
<p>
This function computes the derivatives at the support points <i>x<sub>i</sub></i>
that can be used as input for evaluating a cubic hermite spline.
If <code>ensureMonotonicity=true</code>, then the support points <i>y<sub>i</sub></i>
need to be monotone increasing (or increasing), and the computed derivatives
<i>d<sub>i</sub></i> are such that the cubic hermite is monotone increasing (or decreasing).
The algorithm to ensure monotonicity is based on the method described in Fritsch and Carlson (1980) for
<i>&rho; = &rho;<sub>2</sub></i>.
</p>
<p>
This function is typically used with
<a href=\"modelica://Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation\">
Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation</a>
which is used to evaluate the cubic spline.
Because in many applications, the shape of the spline depends on parameters,
this function has been implemented in such a way that all derivatives can be
computed at once and then stored for use during the time stepping,
in which the above function may be called.
</p>
<h4>References</h4>
<p>
F.N. Fritsch and R.E. Carlson, <a href=\"http://dx.doi.org/10.1137/0717021\">Monotone piecewise cubic interpolation</a>.
<i>SIAM J. Numer. Anal.</i>, 17 (1980), pp. 238?246.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 29, 2011 by Michael Wetter:<br/>
Added special case for one data point and two data points.
</li>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end splineDerivatives;

        function trapezoidalIntegration
          "Integration using the trapezoidal rule"
          input Integer N "Number of integrand points";
          input Real[:] f "Integrands";
          input Real deltaX "Width of interval for Trapezoidal integration";
          output Real result "Result";
        algorithm
          assert(N >= 2, "N must be no less than 2.");
          result := 0;
          for i in 1:N loop
            result := result + f[i];
          end for;

          result := 2*result;
          result := result - f[1] - f[N];
          result := result*deltaX/2;
          annotation (Documentation(info="<html>
<p>
This function computes a definite integral using the trapezoidal rule.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 23, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end trapezoidalIntegration;

        package BaseClasses
          "Package with base classes for Buildings.Utilities.Math.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_2_regNonZeroPower
            "Power function, regularized near zero, but nonzero value for x=0"
           input Real x "Abscissa value";
           input Real n "Exponent";
           input Real delta = 0.01 "Abscissa value where transition occurs";
           input Real der_x;
           input Real der_2_x;
           output Real der_2_y "Function value";
          protected
            Real a1;
            Real a3;
            Real delta2;
            Real x2;
            Real y_d "=y(delta)";
            Real yP_d "=dy(delta)/dx";
            Real yPP_d "=d^2y(delta)/dx^2";
          algorithm
            if abs(x) > delta then
             der_2_y := n*(n-1)*abs(x)^(n-2);
            else
             delta2 :=delta*delta;
             x2 :=x*x;
             y_d :=delta^n;
             yP_d :=n*delta^(n - 1);
             yPP_d :=n*(n - 1)*delta^(n - 2);
             a1 := -(yP_d/delta - yPP_d)/delta2/8;
             a3 := (yPP_d - 12 * a1 * delta2)/2;
             der_2_y := 12*a1*x2+2*a3;
            end if;
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the second derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.regNonZeroPower\">
Buildings.Utilities.Math.Functions.regNonZeroPower</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
April 9, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_2_regNonZeroPower;

          function der_polynomial "Derivative for polynomial function"
              input Real x;
              input Real a[:];
              input Real dx;
              output Real y;
          protected
           parameter Integer n = size(a, 1)-1;
           Real b[n] "Coefficients of derivative polynomial";
          algorithm
            for i in 1:n loop
               b[i] :=a[i+1]*i;
            end for;
            y := Buildings.Utilities.Math.Functions.polynomial(
                                                     a=b, x=x);
            annotation (Documentation(info="<html>
This function computes the first derivative of a polynomial of arbitrary order.
The original polynomial has the form<br/>
<p align=\"center\" style=\"font-style:italic;\">
  y = a<sub>1</sub> + a<sub>2</sub> x + a<sub>3</sub> x<sup>2</sup> + ...
</p>
<p>
This function computes new coefficients<br/>
<p align=\"center\" style=\"font-style:italic;\">
   b<sub>1</sub> = a<sub>2</sub>, b<sub>2</sub> = 2 a<sub>3</sub>, ...
</p>
<p>
and then calls recursively
<a href=\"modelica://Buildings.Utilities.Math.Functions.polynomial\">
Buildings.Utilities.Math.polynomial</a>
</html>"),revisions="<html>
<ul>
<li>
April 5, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>");
          end der_polynomial;

          function der_regNonZeroPower
            "Power function, regularized near zero, but nonzero value for x=0"
           input Real x "Abscissa value";
           input Real n "Exponent";
           input Real delta = 0.01 "Abscissa value where transition occurs";
           input Real der_x;
           output Real der_y "Function value";
          protected
            Real a1;
            Real a3;
            Real delta2;
            Real x2;
            Real y_d "=y(delta)";
            Real yP_d "=dy(delta)/dx";
            Real yPP_d "=d^2y(delta)/dx^2";
          algorithm
            if abs(x) > delta then
             der_y := sign(x)*n*abs(x)^(n-1);
            else
             delta2 :=delta*delta;
             x2 :=x*x;
             y_d :=delta^n;
             yP_d :=n*delta^(n - 1);
             yPP_d :=n*(n - 1)*delta^(n - 2);
             a1 := -(yP_d/delta - yPP_d)/delta2/8;
             a3 := (yPP_d - 12 * a1 * delta2)/2;
             der_y := x * ( 4 * a1 * x * x + 2 * a3);
            end if;
           annotation(derivative(zeroDerivative=n, zeroDerivative=delta)=der_2_regNonZeroPower,
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.regNonZeroPower\">
Buildings.Utilities.Math.Functions.regNonZeroPower</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 9, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_regNonZeroPower;

          function der_spliceFunction "Derivative of splice function"
              input Real pos;
              input Real neg;
              input Real x;
              input Real deltax=1;
              input Real dpos;
              input Real dneg;
              input Real dx;
              input Real ddeltax=0;
              output Real out;
          protected
              Real scaledX;
              Real scaledX1;
              Real dscaledX1;
              Real y;
              constant Real asin1 = Modelica.Math.asin(1);
          algorithm
              scaledX1 := x/deltax;
              if scaledX1 <= -0.99999999999 then
                out := dneg;
              elseif scaledX1 >= 0.9999999999 then
                out := dpos;
              else
                scaledX := scaledX1*asin1;
                dscaledX1 := (dx - scaledX1*ddeltax)/deltax;
                y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
                out := dpos*y + (1 - y)*dneg;
                out := out + (pos - neg)*dscaledX1*asin1/2/(
                  Modelica.Math.cosh(Modelica.Math.tan(scaledX))*Modelica.Math.cos(
                  scaledX))^2;
              end if;

          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.spliceFunction\">
Buildings.Utilities.Math.Functions.spliceFunction</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 7, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_spliceFunction;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Utilities.Math.Functions\">Buildings.Utilities.Math.Functions</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for commonly used
mathematical operations. The functions are used in
the blocks
<a href=\"modelica://Buildings.Utilities.Math\">
Buildings.Utilities.Math</a>.
</p>
</html>"));
      end Functions;

      block SmoothMax
        "Once continuously differentiable approximation to the maximum function"
        extends Modelica.Blocks.Interfaces.SI2SO;
       parameter Real deltaX "Width of transition interval";
      equation
        y =  Buildings.Utilities.Math.Functions.smoothMax(x1=u1, x2=u2, deltaX=deltaX);
        annotation (Icon(graphics={Text(
                extent={{-88,40},{92,-32}},
                lineColor={160,160,164},
                textString="smoothMax()"), Text(
                extent={{-74,-44},{68,-114}},
                lineColor={0,0,255},
                textString="dX=%deltaX%")}),
      Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <i>max(.,.)</i> function.
</p>
</html>",
      revisions="<html>
<ul>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end SmoothMax;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for commonly used
mathematical operations.
The classes in this package augment the classes
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</p>
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
              {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
                {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
                -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
                -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
                {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
                0,0,0}, smooth=Smooth.Bezier)}));
    end Math;

    package Psychrometrics "Library with psychrometric functions"
      extends Modelica.Icons.VariantsPackage;

      package Functions "Package with psychrometric functions"
        extends Modelica.Icons.Package;

        function X_pSatpphi "Humidity ratio for given water vapor pressure"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.AbsolutePressure pSat "Saturation pressure";
          input Modelica.SIunits.Pressure p "Pressure of the fluid";
          input Real phi(min=0, max=1) "Relative humidity";
          output Modelica.SIunits.MassFraction X_w(
            min=0,
            max=1,
            nominal=0.01) "Water vapor concentration per total mass of air";

        protected
          constant Real k = 0.621964713077499 "Ratio of molar masses";
        algorithm
          X_w := phi*k/(k*phi+p/pSat-phi);

          annotation (
            smoothOrder=99,
            Inline=true,
            Documentation(info="<html>
<p>
Function to compute the water vapor concentration based on
saturation pressure, absolute pressure and relative humidity.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 21, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end X_pSatpphi;

        function saturationPressureLiquid
          "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 373.16 K"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                  nominal=300)
            "Saturation temperature";
          output Modelica.SIunits.AbsolutePressure pSat(
                                              displayUnit="Pa",
                                              nominal=1000)
            "Saturation pressure";
        algorithm
          pSat := 611.657*Modelica.Math.exp(17.2799 - 4102.99/(TSat - 35.719));

          annotation (
            smoothOrder=99,
            derivative=Buildings.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid,
            Inline=true,
            Documentation(info="<html>
<p>
Saturation pressure of water above the triple point temperature computed from temperature
according to Wagner <i>et al.</i> (1993). The range of validity is between
<i>273.16</i> and <i>373.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://www.nist.gov/data/PDFfiles/jpcrd477.pdf\">
http://www.nist.gov/data/PDFfiles/jpcrd477.pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
        end saturationPressureLiquid;

        package BaseClasses
          "Package with base classes for Buildings.Utilities.Psychrometrics.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_saturationPressureLiquid
            "Derivative of the function saturationPressureLiquid"
            extends Modelica.Icons.Function;
            input Modelica.SIunits.Temperature Tsat "Saturation temperature";
            input Real dTsat(unit="K/s") "Saturation temperature derivative";
            output Real psat_der(unit="Pa/s")
              "Differential of saturation pressure";

          algorithm
            psat_der:=611.657*Modelica.Math.exp(17.2799 - 4102.99
                      /(Tsat - 35.719))*4102.99*dTsat/(Tsat - 35.719)^2;

            annotation(Inline=false,
              smoothOrder=5,
              Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid\">
Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>Buildings.Media</code>.
</li>
</ul>
</html>"));
          end der_saturationPressureLiquid;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions\">Buildings.Utilities.Psychrometrics.Functions</a>.
</p>
</html>"));
        end BaseClasses;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for psychrometric calculations.
</p>

The nomenclature used in this package is described at
<a href=\"modelica://Buildings.UsersGuide.Conventions\">
Buildings.UsersGuide.Conventions</a>.
</html>"));
      end Functions;

      package Constants "Library of constants for psychometric functions"
        extends Modelica.Icons.Package;

        constant Modelica.SIunits.SpecificHeatCapacity cpAir=1006
          "Specific heat capacity of air";

        constant Modelica.SIunits.SpecificHeatCapacity cpSte=1860
          "Specific heat capacity of water vapor";

        constant Modelica.SIunits.SpecificEnthalpy h_fg = 2501014.5
          "Enthalpy of evaporator of water";
        annotation (
          Documentation(info="<html>
<p>
This package provides constants for functions used
in the calculation of thermodynamic properties of moist air.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 24, 2014, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
            Polygon(
              origin={-9.2597,25.6673},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={-19.9923,-8.3993},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={23.753,-11.5422},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
              smooth=Smooth.Bezier)}));
      end Constants;

      block TWetBul_TDryBulPhi
        "Model to compute the wet bulb temperature based on relative humidity"
        extends Modelica.Blocks.Icons.Block;
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialCondensingGases "Medium model"
          annotation (choicesAllMatching = true);

        parameter Boolean approximateWetBulb=false
          "Set to true to approximate wet bulb temperature" annotation (Evaluate=true);
        Modelica.Blocks.Interfaces.RealInput TDryBul(
          start=Medium.T_default,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Dry bulb temperature"
          annotation (Placement(transformation(extent={{-120,70},{-100,90}})));

        Modelica.Blocks.Interfaces.RealInput phi(min=0, max=1)
          "Relative air humidity"
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));

        Modelica.Blocks.Interfaces.RealInput p(final quantity="Pressure",
                                               final unit="Pa",
                                               min = 0) "Pressure"
          annotation (Placement(transformation(extent={{-120,-90},{-100,-70}})));

        Modelica.Blocks.Interfaces.RealOutput TWetBul(
          start=Medium.T_default-2,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Wet bulb temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      protected
        Modelica.SIunits.Conversions.NonSIunits.Temperature_degC TDryBul_degC
          "Dry bulb temperature in degree Celsius";
        Real rh_per(min=0) "Relative humidity in percentage";
        Modelica.SIunits.MassFraction XiDryBul
          "Water vapor mass fraction at dry bulb state";
        Modelica.SIunits.MassFraction XiSat
          "Water vapor mass fraction at saturation";
      equation
        if approximateWetBulb then
          TDryBul_degC = TDryBul - 273.15;
          rh_per       = 100*phi;
          TWetBul      = 273.15 + TDryBul_degC
             * Modelica.Math.atan(0.151977 * sqrt(rh_per + 8.313659))
             + Modelica.Math.atan(TDryBul_degC + rh_per)
             - Modelica.Math.atan(rh_per-1.676331)
             + 0.00391838 * rh_per^(1.5) * Modelica.Math.atan( 0.023101 * rh_per)  - 4.686035;
          XiSat    = 0;
          XiDryBul = 0;
        else
          XiSat  = Buildings.Utilities.Psychrometrics.Functions.X_pSatpphi(
            pSat=  Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TWetBul),
            p=     p,
            phi=   1);
          XiDryBul =Buildings.Utilities.Psychrometrics.Functions.X_pSatpphi(
            p=     p,
            pSat=  Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TDryBul),
            phi=   phi);
          TWetBul = (TDryBul * ((1-XiDryBul) *
                     Buildings.Utilities.Psychrometrics.Constants.cpAir + XiDryBul *
                     Buildings.Utilities.Psychrometrics.Constants.cpSte) + (XiDryBul-XiSat) *
                     Buildings.Utilities.Psychrometrics.Constants.h_fg)/
                  ( (1-XiSat)*Buildings.Utilities.Psychrometrics.Constants.cpAir + XiSat *
                  Buildings.Utilities.Psychrometrics.Constants.cpSte);
          TDryBul_degC = 0;
          rh_per       = 0;
        end if;

      annotation (
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={
              Ellipse(
                extent={{-22,-94},{18,-56}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-14,44},{10,-64}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-14,44},{-14,84},{-12,90},{-8,92},{-2,94},{4,92},{8,90},{10,
                    84},{10,44},{-14,44}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Line(
                points={{-14,44},{-14,-60}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{10,44},{10,-60}},
                color={0,0,0},
                thickness=0.5),
              Line(points={{-42,-16},{-14,-16}}, color={0,0,0}),
              Line(points={{-42,24},{-14,24}}, color={0,0,0}),
              Line(points={{-42,64},{-14,64}}, color={0,0,0}),
              Text(
                extent={{-92,100},{-62,56}},
                lineColor={0,0,127},
                textString="TDryBul"),
              Text(
                extent={{-86,14},{-54,-14}},
                lineColor={0,0,127},
                textString="phi"),
              Text(
                extent={{-90,-72},{-72,-90}},
                lineColor={0,0,127},
                textString="p"),
              Text(
                extent={{62,22},{92,-22}},
                lineColor={0,0,127},
                textString="TWetBul")}),
          defaultComponentName="wetBul",
          Documentation(info="<html>
<p>
This block computes the wet bulb temperature for a given dry bulb temperature, relative air humidity
and atmospheric pressure.
</p>
<p>
If the constant <code>approximateWetBulb</code> is <code>true</code>,
then the block uses the approximation of Stull (2011) to compute
the wet bulb temperature without requiring a nonlinear equation.
Otherwise, the model will introduce one nonlinear equation.
</p>
<p>
The approximation by Stull is valid for a relative humidity of <i>5%</i> to <i>99%</i>,
a temperature range from <i>-20</i>&deg;C to <i>50</i>&deg;C
and standard sea level pressure.
For this range of data, the approximation error is <i>-1</i> Kelvin to <i>+0.65</i> Kelvin,
with a mean error of less than <i>0.3</i> Kelvin.
</p>
<p>
For a model that takes the mass fraction instead of the relative humidity as an input, see
<a href=\"modelica://Buildings.Utilities.Psychrometrics.TWetBul_TDryBulXi\">
Buildings.Utilities.Psychrometrics.TWetBul_TDryBulXi</a>.
</p>
<h4>References</h4>
<p>
Stull, Roland.
<i><a href=\"http://dx.doi.org/10.1175/JAMC-D-11-0143.1\">
Wet-Bulb Temperature from Relative Humidity and Air Temperature
Roland Stull.</a></i>
Journal of Applied Meteorology and Climatology.
Volume 50, Issue 11, pp. 2267-2269. November 2011
DOI: 10.1175/JAMC-D-11-0143.1
</p>
</html>",
      revisions="<html>
<ul>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
Updated model to use
<code>Buildings.Utilities.Psychrometrics.Functions.saturationPressure()</code>
and
<code>Buildings.Utilities.Psychrometrics.Functions.saturationPressureLiquid()</code>
as these functions have been moved from the medium to the psychrometrics package.
</li>
<li>
October 1, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TWetBul_TDryBulPhi;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for psychrometric calculations.
</p>

The nomenclature used in this package is described at
<a href=\"modelica://Buildings.UsersGuide.Conventions\">
Buildings.UsersGuide.Conventions</a>.
</html>"));
    end Psychrometrics;

    block SimulationTime "Simulation time"
      extends Modelica.Blocks.Interfaces.SO;
    equation
      y = time;
      annotation (
        defaultComponentName="simTim",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={
            Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid),
            Line(points={{0,80},{0,60}}, color={160,160,164}),
            Line(points={{80,0},{60,0}}, color={160,160,164}),
            Line(points={{0,-80},{0,-60}}, color={160,160,164}),
            Line(points={{-80,0},{-60,0}}, color={160,160,164}),
            Line(points={{37,70},{26,50}}, color={160,160,164}),
            Line(points={{70,38},{49,26}}, color={160,160,164}),
            Line(points={{71,-37},{52,-27}}, color={160,160,164}),
            Line(points={{39,-70},{29,-51}}, color={160,160,164}),
            Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
            Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
            Line(points={{-71,37},{-54,28}}, color={160,160,164}),
            Line(points={{-38,70},{-28,51}}, color={160,160,164}),
            Line(
              points={{0,0},{-50,50}},
              color={0,0,0},
              thickness=0.5),
            Line(
              points={{0,0},{40,0}},
              color={0,0,0},
              thickness=0.5)}),
        Documentation(info="<html>
<p>
This component generates a time signal by using the simulation time.
The model is used to allow the simulation to start from any
time without having to set the parameters for the clock, as
would be necessairy for the model
<a href=\"modelica://Modelica.Blocks.Sources.Clock\">
Modelica.Blocks.Sources.Clock</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
    end SimulationTime;
  annotation (
  preferredView="info", Documentation(info="<html>
<p>
This package contains utility models such as for thermal comfort calculation, input/output, co-simulation, psychrometric calculations and various functions that are used throughout the library.
</p>
</html>"),
  Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
  end Utilities;

  package BaseClasses "Package with base classes for the Buildings library"
    extends Modelica.Icons.BasesPackage;

    block BaseIcon "Base icon"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Text(
              extent={{-46,140},{52,92}},
              lineColor={0,0,255},
              textString="%name")}),
    Documentation(
    info="<html>
<p>
Basic class that provides a label with the component name above the icon.
</p>
</html>",
    revisions="<html>
<ul>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end BaseIcon;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings\">Buildings</a>.
</p>
</html>"));
  end BaseClasses;
annotation (
preferredView="info",
version="1.7",
versionBuild=0,
versionDate="2014-06-19",
dateModified = "2014-06-19",
uses(Modelica(version="3.2.1"),
     Modelica_StateGraph2(version="2.0.2")),
conversion(
 from(version="1.6",
      script="modelica://Buildings/Resources/Scripts/Dymola/ConvertBuildings_from_1.6_to_1.7.mos"),
 from(version="1.5",
      script="modelica://Buildings/Resources/Scripts/Dymola/ConvertBuildings_from_1.5_to_1.6.mos"),
 from(version="1.4",
      script="modelica://Buildings/Resources/Scripts/Dymola/ConvertBuildings_from_1.4_to_1.5.mos"),
 noneFromVersion="1.3",
 noneFromVersion="1.2",
 from(version="1.1",
      script="modelica://Buildings/Resources/Scripts/Dymola/ConvertBuildings_from_1.1_to_1.2.mos"),
 from(version="1.0",
      script="modelica://Buildings/Resources/Scripts/Dymola/ConvertBuildings_from_1.0_to_1.1.mos"),
 from(version="0.12",
      script="modelica://Buildings/Resources/Scripts/Dymola/ConvertBuildings_from_0.12_to_1.0.mos")),
revisionId="$Id$",
preferredView="info",
Documentation(info="<html>
<p>
The <code>Buildings</code> library is a free library
for modeling building energy and control systems.
Many models are based on models from the package
<code>Modelica.Fluid</code> and use
the same ports to ensure compatibility with the Modelica Standard
Library.
</p>
<p>
The figure below shows a section of the schematic view of the model
<a href=\"modelica://Buildings.Examples.HydronicHeating\">
Buildings.Examples.HydronicHeating</a>.
In the lower part of the figure, there is a dynamic model of a boiler, a pump and a stratified energy storage tank. Based on the temperatures of the storage tank, a finite state machine switches the boiler and its pump on and off.
The heat distribution is done using a hydronic heating system with a three way valve and a pump with variable revolutions. The upper right hand corner shows a room model that is connected to a radiator whose flow is controlled by a thermostatic valve.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/UsersGuide/HydronicHeating.png\" border=\"1\"/>
</p>
<p>
The web page for this library is
<a href=\"http://simulationresearch.lbl.gov/modelica\">http://simulationresearch.lbl.gov/modelica</a>,
and the development page is
<a href=\"https://github.com/lbl-srg/modelica-buildings\">https://github.com/lbl-srg/modelica-buildings</a>.
Contributions to further advance the library are welcomed.
Contributions may not only be in the form of model development, but also
through model use, model testing,
requirements definition or providing feedback regarding the model applicability
to solve specific problems.
</p>
</html>"));
end Buildings;


package UseCaseEnEffBIM

  package BoilerGasRadiator1_1

    model Buildings
      import Buildings;

      Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam="D:/EnEff-BIM/UseCaseEnEffBIM/Utilities/Buildings/DEU_Koln.105130_IWEC.mos")
        annotation (Placement(transformation(extent={{60,76},{80,96}})));
      //room1 manuell
      inner Modelica.Fluid.System system
        annotation (Placement(transformation(extent={{-98,-98},{-82,-82}})));
      Modelica.Thermal.HeatTransfer.Celsius.TemperatureSensor Sen_Room_Temp
        annotation (Placement(transformation(extent={{48,80},{36,92}})));
      Buildings.Fluid.HeatExchangers.Radiators.RadiatorEN442_2 Radiator(
        redeclare package Medium =
            Modelica.Media.Water.ConstantPropertyLiquidWater,
        Q_flow_nominal=1300,
        nEle=10,
        m_flow_nominal=0.05,
        p_start=200000,
        T_start=313.15,
        T_a_nominal=343.15,
        T_b_nominal=313.15,
        TAir_nominal=294.15,
        TRad_nominal=294.15) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=-90,
            origin={36,36})));

      Buildings.Fluid.Boilers.BoilerPolynomial Boiler(
        redeclare package Medium =
            Modelica.Media.Water.ConstantPropertyLiquidWater,
        Q_flow_nominal=1300,
        fue=Buildings.Fluid.Data.Fuels.NaturalGasHigherHeatingValue(),
        dp_nominal=0,
        a={1},
        m_flow_nominal=0.05,
        p_start=200000,
        T_start=313.15,
        T_nominal=343.15)
        annotation (Placement(transformation(extent={{-86,42},{-66,62}})));

      Buildings.Fluid.Movers.FlowMachine_dp Pump(redeclare package Medium =
            Modelica.Media.Water.ConstantPropertyLiquidWater,
        p_start=200000,
        T_start=313.15,
        m_flow_nominal=0.05)
        annotation (Placement(transformation(extent={{-54,42},{-34,62}})));
      Buildings.Fluid.Storage.ExpansionVessel Vessel(
        redeclare package Medium =
            Modelica.Media.Water.ConstantPropertyLiquidWater,
        V_start=0.01,
        p_start=200000,
        T_start=313.15,
        p=200000)
        annotation (Placement(transformation(extent={{-66,16},{-46,36}})));

      Buildings.Fluid.FixedResistances.Pipe Pipe(redeclare package Medium =
            Modelica.Media.Water.ConstantPropertyLiquidWater,
        thicknessIns=0.03,
        lambdaIns=0.035,
        length=10,
        diameter=0.015,
        p_start=200000,
        T_start=313.15,
        m_flow_nominal=0.05)
        annotation (Placement(transformation(extent={{-24,42},{-4,62}})));
      Buildings.Fluid.FixedResistances.Pipe PipeReturn(redeclare package Medium
          = Modelica.Media.Water.ConstantPropertyLiquidWater,
        thicknessIns=0.03,
        lambdaIns=0.035,
        length=10,
        diameter=0.015,
        p_start=200000,
        T_start=313.15,
        m_flow_nominal=0.05)
        annotation (Placement(transformation(extent={{-12,6},{8,26}})));
      Buildings.Fluid.Actuators.Valves.TwoWayLinear Valve(redeclare package
          Medium =
            Modelica.Media.Water.ConstantPropertyLiquidWater,
        m_flow_nominal=0.05,
        dpValve_nominal=1000)
        annotation (Placement(transformation(extent={{2,42},{22,62}})));
      Buildings.Controls.Continuous.LimPID conPID(Ti=300, Td=300)
        annotation (Placement(transformation(extent={{-70,84},{-60,94}})));
      Modelica.Blocks.Sources.Constant pump_dp_set(k=5000)
        annotation (Placement(transformation(extent={{-30,72},{-42,84}})));
      Utilities.Buildings.MixedAir_VDI6020                       roo(redeclare
          package Medium = Buildings.Media.IdealGases.SimpleAir, lat=0.88784899048952)
        annotation (Placement(transformation(extent={{58,18},{98,58}})));
      Buildings.Fluid.Sensors.Temperature senTem_vorl(redeclare package Medium
          = Modelica.Media.Water.ConstantPropertyLiquidWater)
        annotation (Placement(transformation(extent={{-54,62},{-66,74}})));
      Modelica.Blocks.Sources.Constant max_vorl_temp(k=340)
        annotation (Placement(transformation(extent={{-70,69},{-76,75}})));
      Modelica.Blocks.Continuous.LimPID PID_boiler(
        yMax=1,
        yMin=0,
        controllerType=Modelica.Blocks.Types.SimpleController.PID,
        k=0.62,
        Td=0.47,
        Ti=10)
        annotation (Placement(transformation(extent={{-80,68},{-88,76}})));
      Modelica.Blocks.Sources.Constant max_vorl_temp1(
                                                     k=340)
        annotation (Placement(transformation(extent={{-100,84},{-90,93}})));
      Modelica.Blocks.Math.Gain          pers_rad(k=80/17.5)
        annotation (Placement(transformation(extent={{-32,-36},{-22,-26}})));
      Modelica.Blocks.Math.Sum sum1(nin=2)
        annotation (Placement(transformation(extent={{4,-58},{14,-48}})));
      Modelica.Blocks.Sources.Constant lat_he_input(k=0)
        annotation (Placement(transformation(extent={{4,-76},{14,-66}})));
      Modelica.Blocks.Routing.Multiplex3 multiplex3_2
        annotation (Placement(transformation(extent={{20,-58},{30,-48}})));
      Modelica.Blocks.Math.Gain          pers_conv(k=80/17.5)
        annotation (Placement(transformation(extent={{-30,-54},{-20,-44}})));
      Modelica.Blocks.Math.Gain          mach_conv(k=200/17.5)
        annotation (Placement(transformation(extent={{-32,-74},{-22,-64}})));
      Modelica.Blocks.Sources.CombiTimeTable combiTimeTable(
        tableOnFile=true,
        tableName="InnerLoads",
        columns={2,3,4},
        fileName="InnerLoads.txt")
        annotation (Placement(transformation(extent={{-74,-60},{-54,-40}})));
    equation

      // eigener Code

      //eigener Code Ende
      connect(Boiler.port_a, Vessel.port_a) annotation (Line(
          points={{-86,52},{-86,16},{-56,16}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(Pump.port_b, Pipe.port_a) annotation (Line(
          points={{-34,52},{-24,52}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(Radiator.port_b, PipeReturn.port_b) annotation (Line(
          points={{36,26},{36,16},{8,16}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(PipeReturn.port_a, Vessel.port_a) annotation (Line(
          points={{-12,16},{-56,16}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(Pipe.port_b, Valve.port_a) annotation (Line(
          points={{-4,52},{2,52}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(Valve.port_b, Radiator.port_a) annotation (Line(
          points={{22,52},{36,52},{36,46}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(conPID.u_m, Sen_Room_Temp.T) annotation (Line(
          points={{-65,83},{-65,80},{-54,80},{-54,94},{30,94},{30,86},{36,86}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(Radiator.heatPortRad, roo.heaPorRad) annotation (Line(
          points={{43.2,34},{60,34},{60,34.2},{77,34.2}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(Radiator.heatPortCon, roo.heaPorAir) annotation (Line(
          points={{43.2,38},{77,38}},
          color={191,0,0},
          smooth=Smooth.None));

      connect(Sen_Room_Temp.port, roo.heaPorAir) annotation (Line(
          points={{48,86},{48,70},{68,70},{68,48},{77,48},{77,38}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(weaDat.weaBus, roo.weaBus) annotation (Line(
          points={{80,86},{95.9,86},{95.9,55.9}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(Pump.dp_in, pump_dp_set.y) annotation (Line(
          points={{-44.2,64},{-44.2,78},{-42.6,78}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(PID_boiler.u_s, max_vorl_temp.y) annotation (Line(
          points={{-79.2,72},{-76.3,72}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(senTem_vorl.T, PID_boiler.u_m) annotation (Line(
          points={{-64.2,68},{-68,68},{-68,64},{-84,64},{-84,67.2}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(PID_boiler.y, Boiler.y) annotation (Line(
          points={{-88.4,72},{-92,72},{-92,60},{-88,60}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(Boiler.port_b, Pump.port_a) annotation (Line(
          points={{-66,52},{-54,52}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(senTem_vorl.port, Boiler.port_b) annotation (Line(
          points={{-60,62},{-60,52},{-66,52}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(max_vorl_temp1.y, conPID.u_s) annotation (Line(
          points={{-89.5,88.5},{-80.75,88.5},{-80.75,89},{-71,89}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(conPID.y, Valve.y) annotation (Line(
          points={{-59.5,89},{12,89},{12,64}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(sum1.y,multiplex3_2. u2[1]) annotation (Line(
          points={{14.5,-53},{19,-53}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(multiplex3_2.u3[1],lat_he_input. y) annotation (Line(
          points={{19,-56.5},{16,-56.5},{16,-71},{14.5,-71}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pers_conv.y,sum1. u[1]) annotation (Line(
          points={{-19.5,-49},{-8.65,-49},{-8.65,-53.5},{3,-53.5}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(mach_conv.y,sum1. u[2]) annotation (Line(
          points={{-21.5,-69},{-8,-69},{-8,-52.5},{3,-52.5}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pers_rad.y,multiplex3_2. u1[1]) annotation (Line(
          points={{-21.5,-31},{19,-31},{19,-49.5}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(multiplex3_2.y, roo.qGai_flow) annotation (Line(
          points={{30.5,-53},{42,-53},{42,48},{50,48}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(combiTimeTable.y[3], pers_rad.u) annotation (Line(
          points={{-53,-50},{-42,-50},{-42,-31},{-33,-31}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(combiTimeTable.y[1], pers_conv.u) annotation (Line(
          points={{-53,-50},{-42,-50},{-42,-49},{-31,-49}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(combiTimeTable.y[2], mach_conv.u) annotation (Line(
          points={{-53,-50},{-42,-50},{-42,-69},{-33,-69}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation (
          Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}),     graphics),
        experiment(StopTime=3.1536e+007, Interval=60),
        __Dymola_experimentSetupOutput,
        Documentation(info="<html>
</html>"));
    end Buildings;
  end BoilerGasRadiator1_1;

  package Utilities

    package Buildings

      model MixedAir_VDI6020
        "Room according to VDI6020. Model of a room in which the air is completely mixed."
        import Buildings;
        extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
       // VDI 6020 modification
        extends Buildings.Rooms.BaseClasses.ConstructionRecords(
          nConExtWin=1,
          nConPar=0,
          nConBou=5,
          nSurBou=0,
          nConExt=0,
          datConBou(
            layers={in_floor,in_ceil,in_wall,in_wall,in_wall},
            A={17.5,17.5,15,15,10.5},
            til={Buildings.HeatTransfer.Types.Tilt.Floor,Buildings.HeatTransfer.Types.Tilt.Ceiling,
                Buildings.HeatTransfer.Types.Tilt.Wall,Buildings.HeatTransfer.Types.Tilt.Wall,
                Buildings.HeatTransfer.Types.Tilt.Wall},
            azi={Buildings.HeatTransfer.Types.Azimuth.S,Buildings.HeatTransfer.Types.Azimuth.S,
                Buildings.HeatTransfer.Types.Azimuth.E,Buildings.HeatTransfer.Types.Azimuth.W,
                Buildings.HeatTransfer.Types.Azimuth.N}),
          datConExtWin(
            layers={out_wall},
            A={10.5},
            til={Buildings.HeatTransfer.Types.Tilt.Wall},
            azi={Buildings.HeatTransfer.Types.Azimuth.S},
            glaSys={out_Window_glaSys},
            hWin={2},
            wWin={3.5},
            fFra={0.0001}));
       // VDI 6020 modification end
        parameter Integer nPorts=0 "Number of ports" annotation (Evaluate=true,
            Dialog(
            connectorSizing=true,
            tab="General",
            group="Ports"));

        parameter Modelica.SIunits.Angle lat "Latitude";
        final parameter Modelica.SIunits.Volume V=AFlo*hRoo "Volume";
       // VDI 6020 modification
        parameter Modelica.SIunits.Area AFlo=17.5 "Floor area";
        parameter Modelica.SIunits.Length hRoo=3 "Average room height";
       // VDI 6020 modification end

        ////////////////////////////////////////////////////////////////////////
        // Fluid and heat ports
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
            redeclare each package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(
              extent={{-40,-10},{40,10}},
              origin={-260,-60},
              rotation=90), iconTransformation(
              extent={{-40,-10},{40,10}},
              rotation=90,
              origin={-150,-100})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorAir
          "Heat port to air volume" annotation (Placement(transformation(extent={{-270,30},
                  {-250,50}}),   iconTransformation(extent={{-20,-10},{0,10}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorRad
          "Heat port for radiative heat gain and radiative temperature" annotation (
            Placement(transformation(extent={{-270,-10},{-250,10}}),
                                                                 iconTransformation(
                extent={{-20,-48},{0,-28}})));
        ////////////////////////////////////////////////////////////////////////
        //Constructions VDI 2060
        Buildings.HeatTransfer.Data.OpaqueConstructions.Generic out_wall(
          material={out_Fassadenplatte,out_Daemmung,out_Beton},
          final nLay=3);
        Buildings.HeatTransfer.Data.Solids.Generic out_Beton(
          x=0.24,
          k=2.035,
          c=920,
          d=2100);
        Buildings.HeatTransfer.Data.Solids.Generic out_Daemmung(
          x=0.062,
          k=0.047,
          c=840,
          d=75);
        Buildings.HeatTransfer.Data.Solids.Generic out_Fassadenplatte(
          x=0.025,
          k=0.45,
          c=1050,
          d=1300);
        Buildings.HeatTransfer.Data.GlazingSystems.Generic out_Window_glaSys(
          nLay=2,
          UFra=0,
          gas={out_Window_air},
          glass={out_Window_glas,out_Window_glas});
        Buildings.HeatTransfer.Data.Glasses.Generic out_Window_glas(
          x=0.006,
          k=2.1,
          tauSol=0.817);
        Buildings.HeatTransfer.Data.Gases.Air out_Window_air(x=0.012);
        Buildings.HeatTransfer.Data.OpaqueConstructions.Generic in_floor(
          material={mat_Beton_floor_ceil,mat_Steinw,mat_Estrich,mat_PVC},
          final nLay=4);
        Buildings.HeatTransfer.Data.Solids.Generic mat_PVC(
          x=0.002,
          k=0.21,
          c=1470,
          d=1300);
        Buildings.HeatTransfer.Data.Solids.Generic mat_Estrich(
          x=0.045,
          k=1.4,
          c=1050,
          d=2200);
        Buildings.HeatTransfer.Data.Solids.Generic mat_Steinw(
          x=0.012,
          k=0.06,
          c=840,
          d=50);
        Buildings.HeatTransfer.Data.Solids.Generic mat_Beton_floor_ceil(
          x=0.15,
          k=2.035,
          c=1050,
          d=2400);
        Buildings.HeatTransfer.Data.Solids.Generic mat_Hohlblockst(
          x=0.24,
          k=0.56,
          c=1050,
          d=1300);
        Buildings.HeatTransfer.Data.OpaqueConstructions.Generic in_wall(
          material={mat_Hohlblockst},
          final nLay=1);
        Buildings.HeatTransfer.Data.OpaqueConstructions.Generic in_ceil(
          material={mat_PVC,mat_Estrich,mat_Steinw,mat_Beton_floor_ceil},
          final nLay=4);

        // Constructions
        Buildings.Rooms.Constructions.Construction conExt[NConExt](
          A=datConExt.A,
          til=datConExt.til,
          final layers={datConExt[i].layers for i in 1:NConExt},
          steadyStateInitial=datConExt.steadyStateInitial,
          T_a_start=datConExt.T_a_start,
          T_b_start=datConExt.T_b_start) if haveConExt
          "Heat conduction through exterior construction that have no window"
          annotation (Placement(transformation(extent={{288,100},{242,146}})));
        Buildings.Rooms.Constructions.ConstructionWithWindow conExtWin[NConExtWin](
          A=datConExtWin.A,
          til=datConExtWin.til,
          final layers={datConExtWin[i].layers for i in 1:NConExtWin},
          steadyStateInitial=datConExtWin.steadyStateInitial,
          T_a_start=datConExtWin.T_a_start,
          T_b_start=datConExtWin.T_b_start,
          AWin=datConExtWin.AWin,
          fFra=datConExtWin.fFra,
          glaSys=datConExtWin.glaSys) if haveConExtWin
          "Heat conduction through exterior construction that have a window"
          annotation (Placement(transformation(extent={{280,44},{250,74}})));
        Buildings.Rooms.Constructions.Construction conPar[NConPar](
          A=datConPar.A,
          til=datConPar.til,
          final layers={datConPar[i].layers for i in 1:NConPar},
          steadyStateInitial=datConPar.steadyStateInitial,
          T_a_start=datConPar.T_a_start,
          T_b_start=datConPar.T_b_start) if haveConPar
          "Heat conduction through partitions that have both sides inside the thermal zone"
          annotation (Placement(transformation(extent={{282,-122},{244,-84}})));
        Buildings.Rooms.Constructions.Construction conBou[NConBou](
          A=datConBou.A,
          til=datConBou.til,
          final layers={datConBou[i].layers for i in 1:NConBou},
          steadyStateInitial=datConBou.steadyStateInitial,
          T_a_start=datConBou.T_a_start,
          T_b_start=datConBou.T_b_start) if haveConBou
          "Heat conduction through opaque constructions that have the boundary conditions of the other side exposed"
          annotation (Placement(transformation(extent={{282,-156},{242,-116}})));
        parameter Boolean linearizeRadiation=true
          "Set to true to linearize emissive power";
        ////////////////////////////////////////////////////////////////////////
        // Convection
        parameter Buildings.HeatTransfer.Types.InteriorConvection intConMod=Buildings.HeatTransfer.Types.InteriorConvection.Temperature
          "Convective heat transfer model for room-facing surfaces of opaque constructions"
          annotation (Dialog(group="Convective heat transfer"));
        parameter Modelica.SIunits.CoefficientOfHeatTransfer hIntFixed=3.0
          "Constant convection coefficient for room-facing surfaces of opaque constructions"
          annotation (Dialog(group="Convective heat transfer", enable=(conMod ==
                Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));
        parameter Buildings.HeatTransfer.Types.ExteriorConvection extConMod=Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind
          "Convective heat transfer model for exterior facing surfaces of opaque constructions"
          annotation (Dialog(group="Convective heat transfer"));
        parameter Modelica.SIunits.CoefficientOfHeatTransfer hExtFixed=10.0
          "Constant convection coefficient for exterior facing surfaces of opaque constructions"
          annotation (Dialog(group="Convective heat transfer", enable=(conMod ==
                Buildings.HeatTransfer.Types.ExteriorConvection.Fixed)));
        parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0) = V*1.2/3600
          "Nominal mass flow rate" annotation (Dialog(group="Nominal condition"));
        parameter Boolean homotopyInitialization "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        ////////////////////////////////////////////////////////////////////////
        // Models for boundary conditions
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a surf_conBou[nConBou] if
          haveConBou "Heat port at surface b of construction conBou" annotation (
            Placement(transformation(extent={{-270,-190},{-250,-170}}),
              iconTransformation(extent={{50,-170},{70,-150}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a surf_surBou[nSurBou] if
          haveSurBou "Heat port of surface that is connected to the room air"
          annotation (Placement(transformation(extent={{-270,-150},{-250,-130}}),
              iconTransformation(extent={{-48,-150},{-28,-130}})));
        Modelica.Blocks.Interfaces.RealInput uSha[nConExtWin](each min=0, each max=1) if
             haveShade
          "Control signal for the shading device (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-300,160},{-260,200}}),
              iconTransformation(extent={{-240,140},{-200,180}})));
        Modelica.Blocks.Interfaces.RealInput qGai_flow[3](each unit="W/m2")
          "Radiant, convective and latent heat input into room (positive if heat gain)"
          annotation (Placement(transformation(extent={{-300,80},{-260,120}})));
        // Reassign the tilt since a construction that is declared as a ceiling of the
        // room model has an exterior-facing surface that is a floor
        Buildings.Rooms.BaseClasses.ExteriorBoundaryConditions bouConExt(
          final nCon=nConExt,
          final lat=lat,
          linearizeRadiation=linearizeRadiation,
          final conMod=extConMod,
          final conPar=datConExt,
          final hFixed=hExtFixed) if haveConExt
          "Exterior boundary conditions for constructions without a window"
          annotation (Placement(transformation(extent={{352,114},{382,144}})));
        // Reassign the tilt since a construction that is declared as a ceiling of the
        // room model has an exterior-facing surface that is a floor
        Buildings.Rooms.BaseClasses.ExteriorBoundaryConditionsWithWindow bouConExtWin(
          final nCon=nConExtWin,
          final lat=lat,
          final conPar=datConExtWin,
          linearizeRadiation=linearizeRadiation,
          final conMod=extConMod,
          final hFixed=hExtFixed) if haveConExtWin
          "Exterior boundary conditions for constructions with a window"
          annotation (Placement(transformation(extent={{352,44},{382,74}})));

        Buildings.HeatTransfer.Windows.BaseClasses.WindowRadiation conExtWinRad[
          NConExtWin](
          final AWin=(1 .- datConExtWin.fFra) .* datConExtWin.AWin,
          final N=datConExtWin.glaSys.nLay,
          final tauGlaSol=datConExtWin.glaSys.glass.tauSol,
          final rhoGlaSol_a=datConExtWin.glaSys.glass.rhoSol_a,
          final rhoGlaSol_b=datConExtWin.glaSys.glass.rhoSol_b,
          final xGla=datConExtWin.glaSys.glass.x,
          final tauShaSol_a=datConExtWin.glaSys.shade.tauSol_a,
          final tauShaSol_b=datConExtWin.glaSys.shade.tauSol_b,
          final rhoShaSol_a=datConExtWin.glaSys.shade.rhoSol_a,
          final rhoShaSol_b=datConExtWin.glaSys.shade.rhoSol_b,
          final haveExteriorShade=datConExtWin.glaSys.haveExteriorShade,
          final haveInteriorShade=datConExtWin.glaSys.haveInteriorShade) if
          haveConExtWin "Model for solar radiation through shades and window"
          annotation (Placement(transformation(extent={{320,-24},{300,-4}})));
        Buildings.BoundaryConditions.WeatherData.Bus weaBus annotation (Placement(
              transformation(extent={{170,150},{190,170}}), iconTransformation(extent=
                 {{166,166},{192,192}})));

        Buildings.Rooms.BaseClasses.AirHeatMassBalanceMixed air(
          redeclare final package Medium = Medium,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          nPorts=nPorts + 1,
          final V=V,
          final nConExt=nConExt,
          final nConExtWin=nConExtWin,
          final nConPar=nConPar,
          final nConBou=nConBou,
          final nSurBou=nSurBou,
          final datConExt=datConExt,
          final datConExtWin=datConExtWin,
          final datConPar=datConPar,
          final datConBou=datConBou,
          final surBou=surBou,
          final homotopyInitialization=homotopyInitialization,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start,
          final C_nominal=C_nominal,
          final m_flow_nominal=m_flow_nominal,
          final haveShade=haveShade,
          final conMod=intConMod,
          final hFixed=hIntFixed) "Convective heat and mass balance of air"
          annotation (Placement(transformation(extent={{40,-142},{64,-118}})));

        Buildings.Rooms.BaseClasses.SolarRadiationExchange solRadExc(
          final nConExt=nConExt,
          final nConExtWin=nConExtWin,
          final nConPar=nConPar,
          final nConBou=nConBou,
          final nSurBou=nSurBou,
          final datConExt = datConExt,
          final datConExtWin = datConExtWin,
          final datConPar = datConPar,
          final datConBou = datConBou,
          final surBou = surBou,
          final isFloorConExt=isFloorConExt,
          final isFloorConExtWin=isFloorConExtWin,
          final isFloorConPar_a=isFloorConPar_a,
          final isFloorConPar_b=isFloorConPar_b,
          final isFloorConBou=isFloorConBou,
          final isFloorSurBou=isFloorSurBou,
          final tauGla={datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].tauSol for i in 1:NConExtWin}) if
             haveConExtWin "Solar radiative heat exchange"
          annotation (Placement(transformation(extent={{-100,40},{-80,60}})));

        Buildings.Rooms.BaseClasses.InfraredRadiationGainDistribution irRadGai(
          final nConExt=nConExt,
          final nConExtWin=nConExtWin,
          final nConPar=nConPar,
          final nConBou=nConBou,
          final nSurBou=nSurBou,
          final datConExt = datConExt,
          final datConExtWin = datConExtWin,
          final datConPar = datConPar,
          final datConBou = datConBou,
          final surBou = surBou,
          final haveShade=haveShade)
          "Distribution for infrared radiative heat gains (e.g., due to equipment and people)"
          annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
        Buildings.Rooms.BaseClasses.InfraredRadiationExchange irRadExc(
          final nConExt=nConExt,
          final nConExtWin=nConExtWin,
          final nConPar=nConPar,
          final nConBou=nConBou,
          final nSurBou=nSurBou,
          final datConExt = datConExt,
          final datConExtWin = datConExtWin,
          final datConPar = datConPar,
          final datConBou = datConBou,
          final surBou = surBou,
          final linearizeRadiation = linearizeRadiation)
          "Infrared radiative heat exchange"
          annotation (Placement(transformation(extent={{-100,0},{-80,20}})));

        Buildings.Rooms.BaseClasses.RadiationTemperature radTem(
          final nConExt=nConExt,
          final nConExtWin=nConExtWin,
          final nConPar=nConPar,
          final nConBou=nConBou,
          final nSurBou=nSurBou,
          final datConExt=datConExt,
          final datConExtWin=datConExtWin,
          final datConPar=datConPar,
          final datConBou=datConBou,
          final surBou=surBou,
          final haveShade=haveShade) "Radiative temperature of the room"
          annotation (Placement(transformation(extent={{-100,-80},{-80,-60}})));

        Buildings.HeatTransfer.Windows.BaseClasses.ShadeRadiation shaRad[NConExtWin](
          final A=(1 .- datConExtWin.fFra) .* datConExtWin.AWin,
          final thisSideHasShade=haveInteriorShade,
          final absIR_air=datConExtWin.glaSys.shade.absIR_a,
          final absIR_glass={(datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].absIR_b)
              for i in 1:NConExtWin},
          final tauIR_air=tauIRSha_air,
          final tauIR_glass=tauIRSha_glass,
          each final linearize=linearizeRadiation) if haveShade
          "Radiation model for room-side window shade"
          annotation (Placement(transformation(extent={{-60,90},{-40,110}})));

      protected
        final parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_air[NConExtWin]=
          datConExtWin.glaSys.shade.tauIR_a
          "Infrared transmissivity of shade for radiation coming from the exterior or the room"
          annotation (Dialog(group="Shading"));
              final parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_glass[
                                                                                NConExtWin]=
          datConExtWin.glaSys.shade.tauIR_b
          "Infrared transmissivity of shade for radiation coming from the glass"
          annotation (Dialog(group="Shading"));

        final parameter Boolean haveExteriorShade[NConExtWin]=
          {datConExtWin[i].glaSys.haveExteriorShade for i in 1:NConExtWin}
          "Set to true if window has exterior shade (at surface a)"
          annotation (Dialog(group="Shading"));
        final parameter Boolean haveInteriorShade[NConExtWin]=
          {datConExtWin[i].glaSys.haveInteriorShade for i in 1:NConExtWin}
          "Set to true if window has interior shade (at surface b)"
          annotation (Dialog(group="Shading"));

        final parameter Boolean haveShade=
          Modelica.Math.BooleanVectors.anyTrue(haveExteriorShade[:]) or
          Modelica.Math.BooleanVectors.anyTrue(haveInteriorShade[:])
          "Set to true if the windows have a shade";

        final parameter Boolean isFloorConExt[NConExt]=
          datConExt.isFloor
          "Flag to indicate if floor for exterior constructions";
        final parameter Boolean isFloorConExtWin[NConExtWin]=
          datConExtWin.isFloor "Flag to indicate if floor for constructions";
        final parameter Boolean isFloorConPar_a[NConPar]=
          datConPar.isFloor "Flag to indicate if floor for constructions";
        final parameter Boolean isFloorConPar_b[NConPar]=
          datConPar.isCeiling "Flag to indicate if floor for constructions";
        final parameter Boolean isFloorConBou[NConBou]=
          datConBou.isFloor
          "Flag to indicate if floor for constructions with exterior boundary conditions exposed to outside of room model";
        parameter Boolean isFloorSurBou[NSurBou]=
          surBou.isFloor
          "Flag to indicate if floor for constructions that are modeled outside of this room";

        Buildings.HeatTransfer.Windows.BaseClasses.ShadingSignal shaSig[NConExtWin](
            each final haveShade=haveShade) if haveConExtWin "Shading signal"
          annotation (Placement(transformation(extent={{-220,150},{-200,170}})));

        Buildings.Rooms.BaseClasses.HeatGain heaGai(redeclare package Medium = Medium, final AFlo=AFlo)
          "Model to convert internal heat gains"
          annotation (Placement(transformation(extent={{-220,90},{-200,110}})));
        Buildings.Rooms.BaseClasses.RadiationAdapter radiationAdapter
          annotation (Placement(transformation(extent={{-180,120},{-160,140}})));
        Modelica.Blocks.Math.Add add
          annotation (Placement(transformation(extent={{-140,110},{-120,130}})));

        Modelica.Blocks.Math.Add sumJToWin[NConExtWin](
          each final k1=1,
          each final k2=1) if
             haveConExtWin
          "Sum of radiosity flows from room surfaces toward the window"
          annotation (Placement(transformation(extent={{-40,-30},{-20,-10}})));

        Buildings.HeatTransfer.Radiosity.RadiositySplitter radShaOut[NConExtWin] if
          haveConExtWin
          "Splitter for radiosity that strikes shading device or unshaded part of window"
          annotation (Placement(transformation(extent={{-100,120},{-80,140}})));

        Modelica.Blocks.Math.Sum sumJFroWin[NConExtWin](each nin=if haveShade then 2
               else 1) if
             haveConExtWin "Sum of radiosity fom window to room surfaces"
          annotation (Placement(transformation(extent={{-20,4},{-40,24}})));

        Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature TSha[NConExtWin] if
             haveShade "Temperature of shading device"
          annotation (Placement(transformation(extent={{-20,-78},{-40,-58}})));

      equation
        connect(conBou.opa_a, surf_conBou) annotation (Line(
            points={{282,-122.667},{282,-122},{288,-122},{288,-216},{-240,-216},{-240,
                -180},{-260,-180}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(uSha, conExtWin.uSha) annotation (Line(
            points={{-280,180},{306,180},{306,62},{281,62}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(uSha, bouConExtWin.uSha) annotation (Line(
            points={{-280,180},{306,180},{306,64},{351,64}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(bouConExtWin.opa_a, conExtWin.opa_a) annotation (Line(
            points={{352,69},{280,69}},
            color={191,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(conExtWin.JInUns_a, bouConExtWin.JOutUns) annotation (Line(
            points={{280.5,60},{304,60},{304,58},{351.5,58}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(bouConExtWin.JInUns, conExtWin.JOutUns_a) annotation (Line(
            points={{351.5,60},{316,60},{316,58},{280.5,58}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(conExtWin.glaUns_a, bouConExtWin.glaUns) annotation (Line(
            points={{280,55},{352,55}},
            color={191,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(bouConExtWin.glaSha, conExtWin.glaSha_a) annotation (Line(
            points={{352,53},{280,53}},
            color={191,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(conExtWin.JInSha_a, bouConExtWin.JOutSha) annotation (Line(
            points={{280.5,51},{286,51},{286,52},{292,52},{292,50},{292,50},{292,49},{
                351.5,49}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(bouConExtWin.JInSha, conExtWin.JOutSha_a) annotation (Line(
            points={{351.5,51},{290,51},{290,50},{290,50},{290,49},{280.5,49}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(conExtWin.fra_a, bouConExtWin.fra) annotation (Line(
            points={{280,46},{352,46}},
            color={191,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(conExt.opa_a, bouConExt.opa_a) annotation (Line(
            points={{288,138.333},{314,138.333},{334,138.333},{334,139},{352,139}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(weaBus, bouConExtWin.weaBus) annotation (Line(
            points={{180,160},{400,160},{400,120},{400,120},{400,60.05},{378.15,60.05}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(weaBus, bouConExt.weaBus) annotation (Line(
            points={{180,160},{400,160},{400,130},{378.15,130},{378.15,130.05}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(bouConExtWin.QAbsSolSha_flow, conExtWinRad.QAbsExtSha_flow)
          annotation (Line(
            points={{351,62},{312,62},{312,46},{290,46},{290,-5},{299,-5}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(bouConExtWin.inc, conExtWinRad.incAng) annotation (Line(
            points={{382.5,68},{390,68},{390,-16},{390,-16},{390,-15},{321.5,-15}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(bouConExtWin.HDir, conExtWinRad.HDir) annotation (Line(
            points={{382.5,65},{388,65},{388,-10},{386,-10},{386,-10},{321.5,-10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(bouConExtWin.HDif, conExtWinRad.HDif) annotation (Line(
            points={{382.5,62},{392,62},{392,-6},{392,-6},{392,-6},{321.5,-6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(uSha, conExtWinRad.uSha) annotation (Line(
            points={{-280,180},{420,180},{420,-40},{310.2,-40},{310.2,-25.6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conExtWin.QAbsSha_flow, conExtWinRad.QAbsGlaSha_flow) annotation (
            Line(
            points={{261,43},{261,38},{260,38},{260,-12},{280,-12},{280,-13},{299,-13}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conExtWinRad.QAbsGlaUns_flow, conExtWin.QAbsUns_flow) annotation (
            Line(
            points={{299,-9},{284,-9},{284,-10},{268,-10},{268,36},{269,36},{269,43}},
            color={0,0,127},
            smooth=Smooth.None));

       // Connect statements from the model BaseClasses.MixedAir
        connect(conExt.opa_b, irRadExc.conExt) annotation (Line(
            points={{241.847,138.333},{160,138.333},{160,60},{-60,60},{-60,20},{-80,
                20},{-80,19.1667}},
            color={190,0,0},
            smooth=Smooth.None));
        connect(conExtWin.fra_b, irRadExc.conExtWinFra) annotation (Line(
            points={{249.9,46},{160,46},{160,60},{-60,60},{-60,10},{-79.9167,10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conPar.opa_a, irRadExc.conPar_a) annotation (Line(
            points={{282,-90.3333},{288,-90.3333},{288,-106},{160,-106},{160,60},{-60,
                60},{-60,8},{-80,8},{-80,7.5},{-79.9167,7.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conPar.opa_b, irRadExc.conPar_b) annotation (Line(
            points={{243.873,-90.3333},{160,-90.3333},{160,60},{-60,60},{-60,5.83333},
                {-79.9167,5.83333}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(conBou.opa_b, irRadExc.conBou) annotation (Line(
            points={{241.867,-122.667},{160,-122.667},{160,60},{-60,60},{-60,3.33333},
                {-79.9167,3.33333}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(surf_surBou, irRadExc.conSurBou) annotation (Line(
            points={{-260,-140},{-232,-140},{-232,-210},{160,-210},{160,60},{-60,60},
                {-60,0.833333},{-79.9583,0.833333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadGai.conExt, conExt.opa_b) annotation (Line(
            points={{-80,-20.8333},{-80,-20},{-60,-20},{-60,60},{160,60},{160,138.333},
                {241.847,138.333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadGai.conExtWinFra, conExtWin.fra_b) annotation (Line(
            points={{-79.9167,-30},{-60,-30},{-60,60},{160,60},{160,46},{249.9,46}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadGai.conPar_a, conPar.opa_a) annotation (Line(
            points={{-79.9167,-32.5},{-60,-32.5},{-60,60},{160,60},{160,-106},{288,
                -106},{288,-90.3333},{282,-90.3333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadGai.conPar_b, conPar.opa_b) annotation (Line(
            points={{-79.9167,-34.1667},{-60,-34.1667},{-60,60},{160,60},{160,
                -90.3333},{243.873,-90.3333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadGai.conBou, conBou.opa_b) annotation (Line(
            points={{-79.9167,-36.6667},{-60,-36.6667},{-60,60},{160,60},{160,
                -122.667},{241.867,-122.667}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadGai.conSurBou, surf_surBou) annotation (Line(
            points={{-79.9583,-39.1667},{-60,-39.1667},{-60,60},{160,60},{160,-210},{
                -232,-210},{-232,-140},{-260,-140}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(irRadGai.uSha, uSha)
                                   annotation (Line(
            points={{-100.833,-22.5},{-100.833,-22.5},{-112,-22.5},{-112,180},{-280,
                180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(heaGai.qGai_flow, qGai_flow) annotation (Line(
            points={{-222,100},{-280,100}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conExtWin.opa_b, irRadExc.conExtWin) annotation (Line(
            points={{249.9,69},{160,69},{160,60},{-60,60},{-60,16},{-80,16},{-80,17.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conExtWin.opa_b, irRadGai.conExtWin) annotation (Line(
            points={{249.9,69},{160,69},{160,60},{-60,60},{-60,-22},{-70,-22},{-70,-22.5},
                {-80,-22.5}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(conExt.opa_b, solRadExc.conExt) annotation (Line(
            points={{241.847,138.333},{160,138.333},{160,60},{-80,60},{-80,59.1667}},
            color={190,0,0},
            smooth=Smooth.None));
        connect(conExtWin.fra_b, solRadExc.conExtWinFra) annotation (Line(
            points={{249.9,46},{160,46},{160,60},{-60,60},{-60,50},{-79.9167,50}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conPar.opa_a, solRadExc.conPar_a) annotation (Line(
            points={{282,-90.3333},{288,-90.3333},{288,-106},{160,-106},{160,60},{-60,
                60},{-60,48},{-79.9167,48},{-79.9167,47.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conPar.opa_b, solRadExc.conPar_b) annotation (Line(
            points={{243.873,-90.3333},{160,-90.3333},{160,60},{-60,60},{-60,46},{-70,
                46},{-70,45.8333},{-79.9167,45.8333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conBou.opa_b, solRadExc.conBou) annotation (Line(
            points={{241.867,-122.667},{160,-122.667},{160,60},{-60,60},{-60,43.3333},
                {-79.9167,43.3333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(surf_surBou, solRadExc.conSurBou) annotation (Line(
            points={{-260,-140},{-232,-140},{-232,-210},{160,-210},{160,60},{-60,60},
                {-60,40},{-70,40},{-70,40.8333},{-79.9583,40.8333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conExtWin.opa_b, solRadExc.conExtWin) annotation (Line(
            points={{249.9,69},{160,69},{160,60},{-60,60},{-60,57.5},{-80,57.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(solRadExc.JInConExtWin, conExtWinRad.QTra_flow) annotation (Line(
            points={{-79.5833,53.3333},{-74,53.3333},{-74,52},{14,52},{14,-22},{299,
                -22}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solRadExc.HOutConExtWin,conExtWinRad.HRoo)  annotation (Line(
            points={{-79.5833,55},{10,55},{10,-34},{328,-34},{328,-21.6},{321.5,-21.6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(uSha, radTem.uSha) annotation (Line(
            points={{-280,180},{-112,180},{-112,-62},{-100.833,-62},{-100.833,-62.5}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conExt.opa_b, radTem.conExt) annotation (Line(
            points={{241.847,138.333},{160,138.333},{160,60},{-60,60},{-60,-60.8333},
                {-80,-60.8333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conExtWin.opa_b, radTem.conExtWin) annotation (Line(
            points={{249.9,69},{160,69},{160,60},{-60,60},{-60,-62.5},{-80,-62.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conExtWin.fra_b, radTem.conExtWinFra) annotation (Line(
            points={{249.9,46},{160,46},{160,4},{160,4},{160,60},{-60,60},{-60,-70},{
                -79.9167,-70}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conPar.opa_a, radTem.conPar_a) annotation (Line(
            points={{282,-90.3333},{288,-90.3333},{288,-106},{160,-106},{160,60},{-60,
                60},{-60,-72.5},{-79.9167,-72.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conPar.opa_b, radTem.conPar_b) annotation (Line(
            points={{243.873,-90.3333},{160,-90.3333},{160,60},{-60,60},{-60,-74.1667},
                {-79.9167,-74.1667}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(conBou.opa_b, radTem.conBou) annotation (Line(
            points={{241.867,-122.667},{160,-122.667},{160,60},{-60,60},{-60,-76.6667},
                {-79.9167,-76.6667}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(surf_surBou, radTem.conSurBou) annotation (Line(
            points={{-260,-140},{-232,-140},{-232,-210},{160,-210},{160,60},{-60,60},
                {-60,-79.1667},{-79.9583,-79.1667}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(radTem.glaUns, conExtWin.glaUns_b) annotation (Line(
            points={{-80,-65},{-60,-65},{-60,60},{160,60},{160,55},{250,55}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(radTem.glaSha, conExtWin.glaSha_b) annotation (Line(
            points={{-80,-66.6667},{-60,-66.6667},{-60,60},{160,60},{160,53},{250,53}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(radTem.TRad, radiationAdapter.TRad) annotation (Line(
            points={{-100.417,-77.6667},{-166,-77.6667},{-192,-77.6667},{-192,130},{
                -182,130}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radiationAdapter.rad, heaPorRad)
                                           annotation (Line(
            points={{-170.2,120},{-170,120},{-170,118},{-170,118},{-170,114},{-226,114},
                {-226,4.44089e-16},{-260,4.44089e-16}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(radiationAdapter.QRad_flow, add.u1) annotation (Line(
            points={{-159,130},{-154,130},{-154,126},{-142,126}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(heaGai.QRad_flow, add.u2) annotation (Line(
            points={{-199,106},{-160,106},{-160,114},{-142,114}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(add.y, irRadGai.Q_flow) annotation (Line(
            points={{-119,120},{-116,120},{-116,-30},{-100.833,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(irRadExc.JOutConExtWin, sumJToWin.u1)
                                                 annotation (Line(
            points={{-79.5833,15},{-50,15},{-50,-14},{-42,-14}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(irRadGai.JOutConExtWin, sumJToWin.u2)
                                                 annotation (Line(
            points={{-79.5833,-25},{-46,-25},{-46,-26},{-42,-26}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(uSha, shaSig.u) annotation (Line(
            points={{-280,180},{-250,180},{-250,160},{-222,160}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaSig.y, radShaOut.u) annotation (Line(
            points={{-199,160},{-110,160},{-110,124},{-102,124}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaSig.y, shaRad.u) annotation (Line(
            points={{-199,160},{-64,160},{-64,108},{-61,108}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(sumJToWin.y, radShaOut.JIn)
                                       annotation (Line(
            points={{-19,-20},{0,-20},{0,148},{-106,148},{-106,136},{-101,136}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(radShaOut.JOut_1, shaRad.JIn_air) annotation (Line(
            points={{-79,136},{-70,136},{-70,96},{-61,96}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(radShaOut.JOut_2, conExtWin.JInUns_b) annotation (Line(
            points={{-79,124},{-20,124},{-20,58},{249.5,58}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(shaRad.JOut_glass, conExtWin.JInSha_b) annotation (Line(
            points={{-39,96},{20,96},{20,72},{220,72},{220,49},{249.5,49}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(conExtWin.JOutSha_b, shaRad.JIn_glass) annotation (Line(
            points={{249.5,51},{222,51},{222,70},{16,70},{16,92},{-39,92}},
            color={0,127,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));

        connect(irRadExc.JInConExtWin, sumJFroWin.y) annotation (Line(
            points={{-79.5833,13.3333},{-46,13.3333},{-46,14},{-41,14}},
            color={0,127,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));

        connect(shaRad.QSolAbs_flow, conExtWinRad.QAbsIntSha_flow) annotation (Line(
            points={{-50,89},{-50,86},{148,86},{148,-17},{299,-17}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(sumJFroWin.u[1], conExtWin.JOutUns_b) annotation (Line(
            points={{-18,14},{164,14},{164,60},{249.5,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(sumJFroWin.u[2], shaRad.JOut_air) annotation (Line(
            points={{-18,14},{-10,14},{-10,40},{-40,40},{-40,64},{-66,64},{-66,92},{
                -61,92}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(radTem.sha, TSha.port) annotation (Line(
            points={{-80,-68.4167},{-64,-68.4167},{-64,-68},{-40,-68}},
            color={191,0,0},
            smooth=Smooth.None));

        for i in 1:nPorts loop
          connect(ports[i],air. ports[i])
                                        annotation (Line(
            points={{-260,-60},{-218,-60},{-218,-204},{52,-204},{52,-141.9}},
            color={0,127,255},
            smooth=Smooth.None));
        end for;
        connect(heaGai.QLat_flow,air. ports[nPorts + 1])
                                                       annotation (Line(
            points={{-200,94},{-186,94},{-186,-170},{52,-170},{52,-141.9}},
            color={0,127,255},
            smooth=Smooth.None));

        connect(air.heaPorAir, heaGai.QCon_flow) annotation (Line(
            points={{40,-130},{-180,-130},{-180,100},{-200,100}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(air.conExt, conExt.opa_b) annotation (Line(
            points={{64,-119},{160,-119},{160,138.333},{241.847,138.333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(air.conExtWin, conExtWin.opa_b) annotation (Line(
            points={{64,-121},{160,-121},{160,69},{249.9,69}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(air.glaUns, conExtWin.glaUns_b) annotation (Line(
            points={{64,-124},{160,-124},{160,55},{250,55}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(air.glaSha, conExtWin.glaSha_b) annotation (Line(
            points={{64,-126},{160,-126},{160,53},{250,53}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(air.conExtWinFra, conExtWin.fra_b) annotation (Line(
            points={{64.1,-130},{160,-130},{160,46},{249.9,46}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(air.conPar_a, conPar.opa_a) annotation (Line(
            points={{64.1,-133},{160,-133},{160,-106},{288,-106},{288,-90.3333},{282,
                -90.3333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(air.conPar_b, conPar.opa_b) annotation (Line(
            points={{64.1,-135},{160,-135},{160,-90},{243.873,-90},{243.873,-90.3333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(air.conBou, conBou.opa_b) annotation (Line(
            points={{64.1,-138},{160,-138},{160,-122.667},{241.867,-122.667}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(air.conSurBou, surf_surBou) annotation (Line(
            points={{64.05,-141},{160,-141},{160,-210},{-232,-210},{-232,-140},{-260,-140}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(air.uSha, uSha) annotation (Line(
            points={{39.6,-120},{6,-120},{6,180},{-280,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaRad.QRadAbs_flow,air. QRadAbs_flow) annotation (Line(
            points={{-55,89},{-55,72},{4,72},{4,-125},{39.5,-125}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(air.TSha, shaRad.TSha) annotation (Line(
            points={{39.5,-127},{2,-127},{2,70},{-45,70},{-45,89}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(air.heaPorAir, heaPorAir) annotation (Line(
            points={{40,-130},{-180,-130},{-180,40},{-260,40}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(air.TSha, TSha.T) annotation (Line(
            points={{39.5,-127},{2,-127},{2,-68},{-18,-68}},
            color={0,0,127},
            smooth=Smooth.None));

        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-260,-220},{460,
                  200}}), graphics),
              Icon(coordinateSystem(preserveAspectRatio=false,extent={{-200,-200},{
                  200,200}}),
                          graphics={
              Text(
                extent={{-104,210},{84,242}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="%name"),
              Text(
                extent={{-214,114},{-138,82}},
                lineColor={0,0,127},
                textString="q"),
              Text(
                extent={{-212,176},{-136,144}},
                lineColor={0,0,127},
                textString="u"),
              Text(
                extent={{-14,-160},{44,-186}},
                lineColor={0,0,0},
                fillColor={61,61,61},
                fillPattern=FillPattern.Solid,
                textString="boundary"),
              Rectangle(
                extent={{-160,-160},{160,160}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-140,138},{140,-140}},
                pattern=LinePattern.None,
                lineColor={117,148,176},
                fillColor={170,213,255},
                fillPattern=FillPattern.Sphere),
              Rectangle(
                extent={{140,70},{160,-70}},
                lineColor={95,95,95},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{146,70},{154,-70}},
                lineColor={95,95,95},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-60,12},{-22,-10}},
                lineColor={0,0,0},
                fillColor={61,61,61},
                fillPattern=FillPattern.Solid,
                textString="air"),
              Text(
                extent={{-72,-22},{-22,-50}},
                lineColor={0,0,0},
                fillColor={61,61,61},
                fillPattern=FillPattern.Solid,
                textString="radiation"),
              Text(
                extent={{-104,-124},{-54,-152}},
                lineColor={0,0,0},
                fillColor={61,61,61},
                fillPattern=FillPattern.Solid,
                textString="surface"),
              Text(
                extent={{-138,-82},{-96,-100}},
                lineColor={0,0,0},
                fillColor={61,61,61},
                fillPattern=FillPattern.Solid,
                textString="fluid")}),
          preferredView="info",
          defaultComponentName="roo",
          Documentation(info="<html>
<p>
Room model that assumes the air to be completely mixed. 
</p>
<p>
See 
<a href=\"modelica://Buildings.Rooms.UsersGuide\">Buildings.Rooms.UsersGuide</a>
for detailed explanations.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 16, 2013, by Michael Wetter:<br/>
Redesigned implementation to remove one level of model hierarchy on the room-side heat and mass balance.
This change was done to facilitate the implementation of non-uniform room air heat and mass balance,
which required separating the convection and long-wave radiation models.<br/>
Changed assignment 
<code>solRadExc(tauGla={0.6 for i in 1:NConExtWin})</code> to
<code>solRadExc(tauGla={datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].tauSol for i in 1:NConExtWin})</code> to
better take into account the solar properties of the glass.
</li>
<li>
March 7 2012, by Michael Wetter:<br/>
Added optional parameters <code>ove</code> and <code>sidFin</code> to
the parameter <code>datConExtWin</code>.
This allows modeling windows with an overhang or with side fins.
</li>
<li>
February 8 2012, by Michael Wetter:<br/>
Changed model to use new implementation of
<a href=\"modelica://Buildings.HeatTransfer.Radiosity.OutdoorRadiosity\">
Buildings.HeatTransfer.Radiosity.OutdoorRadiosity</a>.
This change leads to the use of the same equations for the radiative
heat transfer between window and ambient as is used for 
the opaque constructions.
</li>
<li>
December 12, 2011, by Wangda Zuo:<br/>
Add glass thickness as a parameter for conExtWinRad. It is needed by the claculation of property for uncoated glass.
</li>
<li>
December 6, 2011, by Michael Wetter:<br/>
Fixed bug that caused convective heat gains to be 
removed from the room instead of added to the room.
This error was caused by a wrong sign in
<a href=\"modelica://Buildings.Rooms.BaseClasses.HeatGain\">
Buildings.Rooms.BaseClasses.HeatGain</a>.
This closes ticket <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/46\">issue 46</a>.
</li>
<li>
August 9, 2011, by Michael Wetter:<br/>
Fixed bug that caused too high a surface temperature of the window frame.
The previous version did not compute the infrared radiation exchange between the
window frame and the sky. This has been corrected by adding the instance
<code>skyRadExcWin</code> and the parameter <code>absIRFra</code> to the 
model 
<a href=\"modelica://Buildings.Rooms.BaseClasses.ExteriorBoundaryConditionsWithWindow\">
Buildings.Rooms.BaseClasses.ExteriorBoundaryConditionsWithWindow</a>.
This closes ticket <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/36\">issue 36</a>.
</li>
<li>
August 9, 2011 by Michael Wetter:<br/>
Changed assignment of tilt in instances <code>bouConExt</code> and <code>bouConExtWin</code>.
This fixes the bug in <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/35\">issue 35</a>
that led to the wrong solar radiation gain for roofs and floors.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Propagated convection model to exterior boundary condition models.
</li>
<li>
December 14, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end MixedAir_VDI6020;
    end Buildings;
  end Utilities;
annotation (uses(
    Modelica(version="3.2.1"),
    AixLib(version="0.1.0"),
    BuildingSystems(version="0.14"),
    Buildings(version="1.7"),
    IDEAS(version="0.1")),            version="1");
end UseCaseEnEffBIM;


model UseCaseEnEffBIM_BoilerGasRadiator1_1_Buildings
 extends UseCaseEnEffBIM.BoilerGasRadiator1_1.Buildings(weaDat(filNam=
          "D:/EnEff-BIM/WP1_2_BIM/DEU_Koln.105130_IWEC.mos"), max_vorl_temp1(k=
          20));
  annotation(experiment(StopTime=864000, Interval=1800),   uses(UseCaseEnEffBIM(version="1"),
        Modelica(version="3.2.1")),
    __Dymola_experimentSetupOutput);
end UseCaseEnEffBIM_BoilerGasRadiator1_1_Buildings;
